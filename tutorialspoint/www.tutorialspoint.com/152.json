{"title_html": "<h1>MongoDB - Quick Guide</h1>", "content": "\n MongoDB - Quick Guide \n  \n Advertisements \n \n<!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//-->\n\n\n \n  \n \n Previous Page\n \n \nNext Page \u00a0\n \n  \n  \n MongoDB - Overview \n MongoDB is a cross-platform, document oriented database that provides, high performance, high availability, and easy scalability. MongoDB works on concept of collection and document. \n Database \n Database is a physical container for collections. Each database gets its own set of files on the file system. A single MongoDB server typically has multiple databases. \n Collection \n Collection is a group of MongoDB documents. It is the equivalent of an RDBMS table. A collection exists within a single database. Collections do not enforce a schema. Documents within a collection can have different fields. Typically, all documents in a collection are of similar or related purpose. \n Document \n A document is a set of key-value pairs. Documents have dynamic schema. Dynamic schema means that documents in the same collection do not need to have the same set of fields or structure, and common fields in a collection's documents may hold different types of data. \n The following table shows the relationship of RDBMS terminology with MongoDB. \n \n\nRDBMS\nMongoDB\n\n\nDatabase\nDatabase\n\n\nTable\nCollection\n\n\nTuple/Row\nDocument\n\n\ncolumn\nField\n\n\nTable Join\nEmbedded Documents\n\n\nPrimary Key\nPrimary Key (Default key _id provided by mongodb itself)\n\n\nDatabase Server and Client\n\n\nMysqld/Oracle\nmongod\n\n\nmysql/sqlplus\nmongo\n\n \n Sample Document \n Following example shows the document structure of a blog site, which is simply a comma separated key value pair. \n \n{\n   _id: ObjectId(7df78ad8902c)\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100, \n   comments: [\t\n      {\n         user:'user1',\n         message: 'My first comment',\n         dateCreated: new Date(2011,1,20,2,15),\n         like: 0 \n      },\n      {\n         user:'user2',\n         message: 'My second comments',\n         dateCreated: new Date(2011,1,25,7,45),\n         like: 5\n      }\n   ]\n}\n \n _id is a 12 bytes hexadecimal number which assures the uniqueness of every document. You can provide _id while inserting the document. If you don\u2019t provide then MongoDB provides a unique id for every document. These 12 bytes first 4 bytes for the current timestamp, next 3 bytes for machine id, next 2 bytes for process id of MongoDB server and remaining 3 bytes are simple incremental VALUE. \n MongoDB - Advantages \n Any relational database has a typical schema design that shows number of tables and the relationship between these tables. While in MongoDB, there is no concept of relationship. \n Advantages of MongoDB over RDBMS \n \nSchema less \u2212 MongoDB is a document database in which one collection holds different documents. Number of fields, content and size of the document can differ from one document to another.\nStructure of a single object is clear.\nNo complex joins.\nDeep query-ability. MongoDB supports dynamic queries on documents using a document-based query language that's nearly as powerful as SQL.\nTuning.\nEase of scale-out \u2212 MongoDB is easy to scale.\nConversion/mapping of application objects to database objects not needed.\nUses internal memory for storing the (windowed) working set, enabling faster access of data.\n \n Why Use MongoDB? \n \nDocument Oriented Storage \u2212 Data is stored in the form of JSON style documents.\nIndex on any attribute\nReplication and high availability\nAuto-sharding\nRich queries\nFast in-place updates\nProfessional support by MongoDB\n \n Where to Use MongoDB? \n \nBig Data\nContent Management and Delivery\nMobile and Social Infrastructure\nUser Data Management\nData Hub\n \n MongoDB - Environment \n Let us now see how to install MongoDB on Windows. \n Install MongoDB On Windows \n To install MongoDB on Windows, first download the latest release of MongoDB from https://www.mongodb.org/downloads. Make sure you get correct version of MongoDB depending upon your Windows version. To get your Windows version, open command prompt and execute the following command. \n \nC:\\>wmic os get osarchitecture\nOSArchitecture\n64-bit\nC:\\>\n \n 32-bit versions of MongoDB only support databases smaller than 2GB and suitable only for testing and evaluation purposes. \n Now extract your downloaded file to c:\\ drive or any other location. Make sure the name of the extracted folder is mongodb-win32-i386-[version] or mongodb-win32-x86_64-[version]. Here [version] is the version of MongoDB download. \n Next, open the command prompt and run the following command. \n \nC:\\>move mongodb-win64-* mongodb\n   1 dir(s) moved.\nC:\\>\n \n In case you have extracted the MongoDB at different location, then go to that path by using command cd FOLDER/DIR and now run the above given process. \n MongoDB requires a data folder to store its files. The default location for the MongoDB data directory is c:\\data\\db. So you need to create this folder using the Command Prompt. Execute the following command sequence. \n \nC:\\>md data\nC:\\md data\\db\n \n If you have to install the MongoDB at a different location, then you need to specify an alternate path for \\data\\db by setting the path dbpath in mongod.exe. For the same, issue the following commands. \n In the command prompt, navigate to the bin directory present in the MongoDB installation folder. Suppose my installation folder is D:\\set up\\mongodb \n \nC:\\Users\\XYZ>d:\nD:\\>cd \"set up\"\nD:\\set up>cd mongodb\nD:\\set up\\mongodb>cd bin\nD:\\set up\\mongodb\\bin>mongod.exe --dbpath \"d:\\set up\\mongodb\\data\" \n \n This will show waiting for connections message on the console output, which indicates that the mongod.exe process is running successfully. \n Now to run the MongoDB, you need to open another command prompt and issue the following command. \n \nD:\\set up\\mongodb\\bin>mongo.exe\nMongoDB shell version: 2.4.6\nconnecting to: test\n>db.test.save( { a: 1 } )\n>db.test.find()\n{ \"_id\" : ObjectId(5879b0f65a56a454), \"a\" : 1 }\n>\n \n This will show that MongoDB is installed and run successfully. Next time when you run MongoDB, you need to issue only commands. \n \nD:\\set up\\mongodb\\bin>mongod.exe --dbpath \"d:\\set up\\mongodb\\data\" \nD:\\set up\\mongodb\\bin>mongo.exe\n \n Install MongoDB on Ubuntu \n Run the following command to import the MongoDB public GPG key \u2212 \n \nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10\n \n Create a /etc/apt/sources.list.d/mongodb.list file using the following command. \n \necho 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' \n   | sudo tee /etc/apt/sources.list.d/mongodb.list\n \n Now issue the following command to update the repository \u2212 \n \nsudo apt-get update\n \n Next install the MongoDB by using the following command \u2212 \n \napt-get install mongodb-10gen = 2.2.3\n \n In the above installation, 2.2.3 is currently released MongoDB version. Make sure to install the latest version always. Now MongoDB is installed successfully. \n Start MongoDB \n \nsudo service mongodb start\n \n Stop MongoDB \n \nsudo service mongodb stop\n \n Restart MongoDB \n \nsudo service mongodb restart\n \n To use MongoDB run the following command. \n \nmongo\n \n This will connect you to running MongoDB instance. \n MongoDB Help \n To get a list of commands, type db.help() in MongoDB client. This will give you a list of commands as shown in the following screenshot. \n \nMongoDB Statistics\nTo get stats about MongoDB server, type the command db.stats() in MongoDB client. This will show the database name, number of collection and documents in the database. Output of the command is shown in the following screenshot.\n\nMongoDB - Data Modelling\nData in MongoDB has a flexible schema.documents in the same collection. They do not need to have the same set of fields or structure, and common fields in a collection\u2019s documents may hold different types of data.\nSome considerations while designing Schema in MongoDB\n\nDesign your schema according to user requirements.\nCombine objects into one document if you will use them together. Otherwise separate them (but make sure there should not be need of joins).\nDuplicate the data (but limited) because disk space is cheap as compare to compute time.\nDo joins while write, not on read.\nOptimize your schema for most frequent use cases.\nDo complex aggregation in the schema.\n\nExample\nSuppose a client needs a database design for his blog/website and see the differences between RDBMS and MongoDB schema design. Website has the following requirements.\n\nEvery post has the unique title, description and url.\nEvery post can have one or more tags.\nEvery post has the name of its publisher and total number of likes.\nEvery post has comments given by users along with their name, message, data-time and likes.\nOn each post, there can be zero or more comments.\n\nIn RDBMS schema, design for above requirements will have minimum three tables.\n\nWhile in MongoDB schema, design will have one collection post and the following structure \u2212\n\n{\n   _id: POST_ID\n   title: TITLE_OF_POST, \n   description: POST_DESCRIPTION,\n   by: POST_BY,\n   url: URL_OF_POST,\n   tags: [TAG1, TAG2, TAG3],\n   likes: TOTAL_LIKES, \n   comments: [\t\n      {\n         user:'COMMENT_BY',\n         message: TEXT,\n         dateCreated: DATE_TIME,\n         like: LIKES \n      },\n      {\n         user:'COMMENT_BY',\n         message: TEXT,\n         dateCreated: DATE_TIME,\n         like: LIKES\n      }\n   ]\n}\n\nSo while showing the data, in RDBMS you need to join three tables and in MongoDB, data will be shown from one collection only.\nMongoDB - Create Database\nIn this chapter, we will see how to create a database in MongoDB.\nThe use Command\nMongoDB use DATABASE_NAME is used to create database. The command will create a new database if it doesn't exist, otherwise it will return the existing database.\nSyntax\nBasic syntax of use DATABASE statement is as follows \u2212\n\nuse DATABASE_NAME\n\nExample\nIf you want to use a database with name <mydb>, then use DATABASE statement would be as follows \u2212\n\n>use mydb\nswitched to db mydb\n\nTo check your currently selected database, use the command db\n\n>db\nmydb\n\nIf you want to check your databases list, use the command show dbs.\n\n>show dbs\nlocal     0.78125GB\ntest      0.23012GB\n\nYour created database (mydb) is not present in list. To display database, you need to insert at least one document into it.\n\n>db.movie.insert({\"name\":\"tutorials point\"})\n>show dbs\nlocal      0.78125GB\nmydb       0.23012GB\ntest       0.23012GB\n\nIn MongoDB default database is test. If you didn't create any database, then collections will be stored in test database.\nMongoDB - Drop Database\nIn this chapter, we will see how to drop a database using MongoDB command.\nThe dropDatabase() Method\nMongoDB db.dropDatabase() command is used to drop a existing database.\nSyntax\nBasic syntax of dropDatabase() command is as follows \u2212\n\ndb.dropDatabase()\n\nThis will delete the selected database. If you have not selected any database, then it will delete default 'test' database.\nExample\nFirst, check the list of available databases by using the command, show dbs.\n\n>show dbs\nlocal      0.78125GB\nmydb       0.23012GB\ntest       0.23012GB\n>\n\nIf you want to delete new database <mydb>, then dropDatabase() command would be as follows \u2212\n\n>use mydb\nswitched to db mydb\n>db.dropDatabase()\n>{ \"dropped\" : \"mydb\", \"ok\" : 1 }\n>\n\nNow check list of databases.\n\n>show dbs\nlocal      0.78125GB\ntest       0.23012GB\n>\n\nMongoDB - Create Collection\nIn this chapter, we will see how to create a collection using MongoDB.\nThe createCollection() Method\nMongoDB db.createCollection(name, options) is used to create collection.\nSyntax\nBasic syntax of createCollection() command is as follows \u2212\n\ndb.createCollection(name, options)\n\nIn the command, name is name of collection to be created. Options is a document and is used to specify configuration of collection.\n\n\nParameter\nType\nDescription\n\n\nName\nString\nName of the collection to be created\n\n\nOptions\nDocument\n(Optional) Specify options about memory size and indexing\n\n\nOptions parameter is optional, so you need to specify only the name of the collection. Following is the list of options you can use \u2212\n\n\nField\nType\nDescription\n\ncapped\nBoolean\n(Optional) If true, enables a capped collection. Capped collection is a fixed size collection that automatically overwrites its oldest entries when it reaches its maximum size. If you specify true, you need to specify size parameter also.\n\n\nautoIndexId\nBoolean\n(Optional) If true, automatically create index on _id field.s Default value is false.\n\n\nsize\nnumber\n(Optional) Specifies a maximum size in bytes for a capped collection. If capped is true, then you need to specify this field also.\n\n\nmax\nnumber\n(Optional) Specifies the maximum number of documents allowed in the capped collection.\n\n\nWhile inserting the document, MongoDB first checks size field of capped collection, then it checks max field.\nExamples\nBasic syntax of createCollection() method without options is as follows \u2212\n\n>use test\nswitched to db test\n>db.createCollection(\"mycollection\")\n{ \"ok\" : 1 }\n>\n\nYou can check the created collection by using the command show collections.\n\n>show collections\nmycollection\nsystem.indexes\n\nThe following example shows the syntax of createCollection() method with few important options \u2212\n\n>db.createCollection(\"mycol\", { capped : true, autoIndexId : true, size : \n   6142800, max : 10000 } )\n{ \"ok\" : 1 }\n>\n\nIn MongoDB, you don't need to create collection. MongoDB creates collection automatically, when you insert some document.\n\n>db.tutorialspoint.insert({\"name\" : \"tutorialspoint\"})\n>show collections\nmycol\nmycollection\nsystem.indexes\ntutorialspoint\n>\n\nMongoDB - Drop Collection\nIn this chapter, we will see how to drop a collection using MongoDB.\nThe drop() Method\nMongoDB's db.collection.drop() is used to drop a collection from the database.\nSyntax\nBasic syntax of drop() command is as follows \u2212\n\ndb.COLLECTION_NAME.drop()\n\nExample\nFirst, check the available collections into your database mydb.\n\n>use mydb\nswitched to db mydb\n>show collections\nmycol\nmycollection\nsystem.indexes\ntutorialspoint\n>\n\nNow drop the collection with the name mycollection.\n\n>db.mycollection.drop()\ntrue\n>\n\nAgain check the list of collections into database.\n\n>show collections\nmycol\nsystem.indexes\ntutorialspoint\n>\n\ndrop() method will return true, if the selected collection is dropped successfully, otherwise it will return false.\nMongoDB - Datatypes\nMongoDB supports many datatypes. Some of them are \u2212\n\nString \u2212 This is the most commonly used datatype to store the data. String in MongoDB must be UTF-8 valid.\nInteger \u2212 This type is used to store a numerical value. Integer can be 32 bit or 64 bit depending upon your server.\nBoolean \u2212 This type is used to store a boolean (true/ false) value.\nDouble \u2212 This type is used to store floating point values.\nMin/ Max keys \u2212 This type is used to compare a value against the lowest and highest BSON elements.\nArrays \u2212 This type is used to store arrays or list or multiple values into one key.\nTimestamp \u2212 ctimestamp. This can be handy for recording when a document has been modified or added.\nObject \u2212 This datatype is used for embedded documents.\nNull \u2212 This type is used to store a Null value.\nSymbol \u2212 This datatype is used identically to a string; however, it's generally reserved for languages that use a specific symbol type.\nDate  \u2212 This datatype is used to store the current date or time in UNIX time format. You can specify your own date time by creating object of Date and passing day, month, year into it.\nObject ID \u2212 This datatype is used to store the document\u2019s ID.\nBinary data \u2212 This datatype is used to store binary data.\nCode \u2212 This datatype is used to store JavaScript code into the document.\nRegular expression \u2212 This datatype is used to store regular expression.\n\nMongoDB - Insert Document\nIn this chapter, we will learn how to insert document in MongoDB collection.\nThe insert() Method\nTo insert data into MongoDB collection, you need to use MongoDB's insert() or save() method.\nSyntax\nThe basic syntax of insert() command is as follows \u2212\n\n>db.COLLECTION_NAME.insert(document)\n\nExample\n\n>db.mycol.insert({\n   _id: ObjectId(7df78ad8902c),\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100\n})\n\nHere mycol is our collection name, as created in the previous chapter. If the collection doesn't exist in the database, then MongoDB will create this collection and then insert a document into it.\nIn the inserted document, if we don't specify the _id parameter, then MongoDB assigns a unique ObjectId for this document.\n_id is 12 bytes hexadecimal number unique for every document in a collection. 12 bytes are divided as follows \u2212\n\n_id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, \n   3 bytes incrementer)\n\nTo insert multiple documents in a single query, you can pass an array of documents in insert() command.\nExample\n\n>db.post.insert([\n   {\n      title: 'MongoDB Overview', \n      description: 'MongoDB is no sql database',\n      by: 'tutorials point',\n      url: 'http://www.tutorialspoint.com',\n      tags: ['mongodb', 'database', 'NoSQL'],\n      likes: 100\n   },\n\t\n   {\n      title: 'NoSQL Database', \n      description: \"NoSQL database doesn't have tables\",\n      by: 'tutorials point',\n      url: 'http://www.tutorialspoint.com',\n      tags: ['mongodb', 'database', 'NoSQL'],\n      likes: 20, \n      comments: [\t\n         {\n            user:'user1',\n            message: 'My first comment',\n            dateCreated: new Date(2013,11,10,2,35),\n            like: 0 \n         }\n      ]\n   }\n])\n\nTo insert the document you can use db.post.save(document) also. If you don't specify _id in the document then save() method will work same as insert() method. If you specify _id then it will replace whole data of document containing _id as specified in save() method.\nMongoDB - Query Document\nIn this chapter, we will learn how to query document from MongoDB collection.\nThe find() Method\nTo query data from MongoDB collection, you need to use MongoDB's find() method.\nSyntax\nThe basic syntax of find() method is as follows \u2212\n\n>db.COLLECTION_NAME.find()\n\nfind() method will display all the documents in a non-structured way.\nThe pretty() Method\nTo display the results in a formatted way, you can use pretty() method.\nSyntax\n\n>db.mycol.find().pretty()\n\nExample\n\n>db.mycol.find().pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n>\n\nApart from find() method, there is findOne() method, that returns only one document.\nRDBMS Where Clause Equivalents in MongoDB\nTo query the document on the basis of some condition, you can use following operations.\n\n\nOperation\nSyntax\nExample\nRDBMS Equivalent\n\n\nEquality\n{<key>:<value>}\ndb.mycol.find({\"by\":\"tutorials point\"}).pretty()\nwhere by = 'tutorials point'\n\n\nLess Than\n{<key>:{$lt:<value>}}\ndb.mycol.find({\"likes\":{$lt:50}}).pretty()\nwhere likes < 50\n\n\nLess Than Equals\n{<key>:{$lte:<value>}}\ndb.mycol.find({\"likes\":{$lte:50}}).pretty()\nwhere likes <= 50\n\n\nGreater Than\n{<key>:{$gt:<value>}}\ndb.mycol.find({\"likes\":{$gt:50}}).pretty()\nwhere likes > 50\n\n\nGreater Than Equals\n{<key>:{$gte:<value>}}\ndb.mycol.find({\"likes\":{$gte:50}}).pretty()\nwhere likes >= 50\n\n\nNot Equals\n{<key>:{$ne:<value>}}\ndb.mycol.find({\"likes\":{$ne:50}}).pretty()\nwhere likes != 50\n\n\nAND in MongoDB\nSyntax\nIn the find() method, if you pass multiple keys by separating them by ',' then MongoDB treats it as AND condition. Following is the basic syntax of AND \u2212\n\n>db.mycol.find(\n   {\n      $and: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n\nExample\nFollowing example will show all the tutorials written by 'tutorials point' and whose title is 'MongoDB Overview'.\n\n>db.mycol.find({$and:[{\"by\":\"tutorials point\"},{\"title\": \"MongoDB Overview\"}]}).pretty() {\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n\nFor the above given example, equivalent where clause will be ' where by = 'tutorials point' AND title = 'MongoDB Overview' '. You can pass any number of key, value pairs in find clause.\nOR in MongoDB\nSyntax\nTo query documents based on the OR condition, you need to use $or keyword. Following is the basic syntax of OR \u2212\n\n>db.mycol.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n\nExample\nFollowing example will show all the tutorials written by 'tutorials point' or whose title is 'MongoDB Overview'.\n\n>db.mycol.find({$or:[{\"by\":\"tutorials point\"},{\"title\": \"MongoDB Overview\"}]}).pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n>\n\nUsing AND and OR Together\nExample\nThe following example will show the documents that have likes greater than 10 and whose title is either 'MongoDB Overview' or by is 'tutorials point'. Equivalent SQL where clause is 'where likes>10 AND (by = 'tutorials point' OR title = 'MongoDB Overview')'\n\n>db.mycol.find({\"likes\": {$gt:10}, $or: [{\"by\": \"tutorials point\"},\n   {\"title\": \"MongoDB Overview\"}]}).pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n>\n\nMongoDB - Update Document\nMongoDB's update() and save() methods are used to update document into a collection. The update() method updates the values in the existing document while the save() method replaces the existing document with the document passed in save() method.\nMongoDB Update() Method\nThe update() method updates the values in the existing document.\nSyntax\nThe basic syntax of update() method is as follows \u2212\n\n>db.COLLECTION_NAME.update(SELECTION_CRITERIA, UPDATED_DATA)\n\nExample\nConsider the mycol collection has the following data.\n\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n\nFollowing example will set the new title 'New MongoDB Tutorial' of the documents whose title is 'MongoDB Overview'.\n\n>db.mycol.update({'title':'MongoDB Overview'},{$set:{'title':'New MongoDB Tutorial'}})\n>db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"New MongoDB Tutorial\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n>\n\nBy default, MongoDB will update only a single document. To update multiple documents, you need to set a parameter 'multi' to true.\n\n>db.mycol.update({'title':'MongoDB Overview'},\n   {$set:{'title':'New MongoDB Tutorial'}},{multi:true})\n\nMongoDB Save() Method\nThe save() method replaces the existing document with the new document passed in the save() method.\nSyntax\nThe basic syntax of MongoDB save() method is shown below \u2212\n\n>db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})\n\nExample\nFollowing example will replace the document with the _id '5983548781331adf45ec5'.\n\n>db.mycol.save(\n   {\n      \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"Tutorials Point New Topic\",\n      \"by\":\"Tutorials Point\"\n   }\n)\n>db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"Tutorials Point New Topic\",\n   \"by\":\"Tutorials Point\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n>\n\nMongoDB - Delete Document\nIn this chapter, we will learn how to delete a document using MongoDB.\nThe remove() Method\nMongoDB's remove() method is used to remove a document from the collection. remove() method accepts two parameters. One is deletion criteria and second is justOne flag.\n\ndeletion criteria \u2212 (Optional) deletion criteria according to documents will be removed.\njustOne \u2212 (Optional) if set to true or 1, then remove only one document.\n\nSyntax\nBasic syntax of remove() method is as follows \u2212\n\n>db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)\n\nExample\nConsider the mycol collection has the following data.\n\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n\nFollowing example will remove all the documents whose title is 'MongoDB Overview'.\n\n>db.mycol.remove({'title':'MongoDB Overview'})\n>db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n>\n\nRemove Only One\nIf there are multiple records and you want to delete only the first record, then set justOne parameter in remove() method.\n\n>db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\n\nRemove All Documents\nIf you don't specify deletion criteria, then MongoDB will delete whole documents from the collection. This is equivalent of SQL's truncate command.\n\n>db.mycol.remove()\n>db.mycol.find()\n>\n\nMongoDB - Projection\nIn MongoDB, projection means selecting only the necessary data rather than selecting whole of the data of a document. If a document has 5 fields and you need to show only 3, then select only 3 fields from them.\nThe find() Method\nMongoDB's find() method, explained in MongoDB Query Document accepts second optional parameter that is list of fields that you want to retrieve. In MongoDB, when you execute find() method, then it displays all fields of a document. To limit this, you need to set a list of fields with value 1 or 0. 1 is used to show the field while 0 is used to hide the fields.\nSyntax\nThe basic syntax of find() method with projection is as follows \u2212\n\n>db.COLLECTION_NAME.find({},{KEY:1})\n\nExample\nConsider the collection mycol has the following data \u2212\n\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n\nFollowing example will display the title of the document while querying the document.\n\n>db.mycol.find({},{\"title\":1,_id:0})\n{\"title\":\"MongoDB Overview\"}\n{\"title\":\"NoSQL Overview\"}\n{\"title\":\"Tutorials Point Overview\"}\n>\n\nPlease note _id field is always displayed while executing find() method, if you don't want this field, then you need to set it as 0.\nMongoDB - Limit Records\nIn this chapter, we will learn how to limit records using MongoDB.\nThe Limit() Method\nTo limit the records in MongoDB, you need to use limit() method. The method accepts one number type argument, which is the number of documents that you want to be displayed.\nSyntax\nThe basic syntax of limit() method is as follows \u2212\n\n>db.COLLECTION_NAME.find().limit(NUMBER)\n\nExample\nConsider the collection myycol has the following data.\n\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n\nFollowing example will display only two documents while querying the document.\n\n>db.mycol.find({},{\"title\":1,_id:0}).limit(2)\n{\"title\":\"MongoDB Overview\"}\n{\"title\":\"NoSQL Overview\"}\n>\n\nIf you don't specify the number argument in limit() method then it will display all documents from the collection.\nMongoDB Skip() Method\nApart from limit() method, there is one more method skip() which also accepts number type argument and is used to skip the number of documents.\nSyntax\nThe basic syntax of skip() method is as follows \u2212\n\n>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n\nExample\nFollowing example will display only the second document.\n\n>db.mycol.find({},{\"title\":1,_id:0}).limit(1).skip(1)\n{\"title\":\"NoSQL Overview\"}\n>\n\nPlease note, the default value in skip() method is 0.\nMongoDB - Sort Records\nIn this chapter, we will learn how to sort records in MongoDB.\nThe sort() Method\nTo sort documents in MongoDB, you need to use sort() method. The method accepts a document containing a list of fields along with their sorting order. To specify sorting order 1 and -1 are used. 1 is used for ascending order while -1 is used for descending order.\nSyntax\nThe basic syntax of sort() method is as follows \u2212\n\n>db.COLLECTION_NAME.find().sort({KEY:1})\n\nExample\nConsider the collection myycol has the following data.\n\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n\nFollowing example will display the documents sorted by title in the descending order.\n\n>db.mycol.find({},{\"title\":1,_id:0}).sort({\"title\":-1})\n{\"title\":\"Tutorials Point Overview\"}\n{\"title\":\"NoSQL Overview\"}\n{\"title\":\"MongoDB Overview\"}\n>\n\nPlease note, if you don't specify the sorting preference, then sort() method will display the documents in ascending order.\nMongoDB - Indexing\nIndexes support the efficient resolution of queries. Without indexes, MongoDB must scan every document of a collection to select those documents that match the query statement. This scan is highly inefficient and require MongoDB to process a large volume of data.\nIndexes are special data structures, that store a small portion of the data set in an easy-to-traverse form. The index stores the value of a specific field or set of fields, ordered by the value of the field as specified in the index.\nThe ensureIndex() Method\nTo create an index you need to use ensureIndex() method of MongoDB.\nSyntax\nThe basic syntax of ensureIndex() method is as follows().\n\n>db.COLLECTION_NAME.ensureIndex({KEY:1})\n\nHere key is the name of the field on which you want to create index and 1 is for ascending order. To create index in descending order you need to use -1.\nExample\n\n>db.mycol.ensureIndex({\"title\":1})\n>\n\nIn ensureIndex() method you can pass multiple fields, to create index on multiple fields.\n\n>db.mycol.ensureIndex({\"title\":1,\"description\":-1})\n>\n\nensureIndex() method also accepts list of options (which are optional). Following is the list \u2212\n\n\nParameter\nType\nDescription\n\nbackground\nBoolean\nBuilds the index in the background so that building an index does not block other database activities. Specify true to build in the background. The default value is false.\n\n\nunique\nBoolean\nCreates a unique index so that the collection will not accept insertion of documents where the index key or keys match an existing value in the index. Specify true to create a unique index. The default value is false.\n\nname\nstring\nThe name of the index. If unspecified, MongoDB generates an index name by concatenating the names of the indexed fields and the sort order.\n\n\ndropDups\nBoolean\nCreates a unique index on a field that may have duplicates. MongoDB indexes only the first occurrence of a key and removes all documents from the collection that contain subsequent occurrences of that key. Specify true to create unique index. The default value is false.\n\nsparse\nBoolean\nIf true, the index only references documents with the specified field. These indexes use less space but behave differently in some situations (particularly sorts). The default value is false.\n\nexpireAfterSeconds\ninteger\nSpecifies a value, in seconds, as a TTL to control how long MongoDB retains documents in this collection.\n\nv\nindex version\nThe index version number. The default index version depends on the version of MongoDB running when creating the index.\n\nweights\ndocument\nThe weight is a number ranging from 1 to 99,999 and denotes the significance of the field relative to the other indexed fields in terms of the score.\n\ndefault_language\nstring\nFor a text index, the language that determines the list of stop words and the rules for the stemmer and tokenizer. The default value is english.\n\nlanguage_override\nstring\nFor a text index, specify the name of the field in the document that contains, the language to override the default language. The default value is language.\n\nMongoDB - Aggregation\nAggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result. In SQL count(*) and with group by is an equivalent of mongodb aggregation.\nThe aggregate() Method\nFor the aggregation in MongoDB, you should use aggregate() method.\nSyntax\nBasic syntax of aggregate() method is as follows \u2212\n\n>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n\nExample\nIn the collection you have the following data \u2212\n\n{\n   _id: ObjectId(7df78ad8902c)\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by_user: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100\n},\n{\n   _id: ObjectId(7df78ad8902d)\n   title: 'NoSQL Overview', \n   description: 'No sql database is very fast',\n   by_user: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 10\n},\n{\n   _id: ObjectId(7df78ad8902e)\n   title: 'Neo4j Overview', \n   description: 'Neo4j is no sql database',\n   by_user: 'Neo4j',\n   url: 'http://www.neo4j.com',\n   tags: ['neo4j', 'database', 'NoSQL'],\n   likes: 750\n},\n\nNow from the above collection, if you want to display a list stating how many tutorials are written by each user, then you will use the following aggregate() method \u2212\n\n> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : 1}}}])\n{\n   \"result\" : [\n      {\n         \"_id\" : \"tutorials point\",\n         \"num_tutorial\" : 2\n      },\n      {\n         \"_id\" : \"Neo4j\",\n         \"num_tutorial\" : 1\n      }\n   ],\n   \"ok\" : 1\n}\n>\n\nSql equivalent query for the above use case will be select by_user, count(*) from mycol group by by_user.\nIn the above example, we have grouped documents by field by_user and on each occurrence of by_user previous value of sum is incremented. Following is a list of available aggregation expressions.\n\n\nExpression\nDescription\nExample\n\n\n$sum\nSums up the defined value from all documents in the collection.\ndb.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}])\n\n$avg\nCalculates the average of all given values from all documents in the collection.\ndb.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}])\n\n$min\nGets the minimum of the corresponding values from all documents in the collection.\ndb.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}])\n\n$max\nGets the maximum of the corresponding values from all documents in the collection.\ndb.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}])\n\n$push\nInserts the value to an array in the resulting document.\ndb.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}])\n\n$addToSet\nInserts the value to an array in the resulting document but does not create duplicates.\ndb.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}])\n\n$first\nGets the first document from the source documents according to the grouping. Typically this makes only sense together with some previously applied \u201c$sort\u201d-stage.\ndb.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}])\n\n$last\nGets the last document from the source documents according to the grouping. Typically this makes only sense together with some previously applied \u201c$sort\u201d-stage.\ndb.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}])\n\nPipeline Concept\nIn UNIX command, shell pipeline means the possibility to execute an operation on some input and use the output as the input for the next command and so on. MongoDB also supports same concept in aggregation framework. There is a set of possible stages and each of those is taken as a set of documents as an input and produces a resulting set of documents (or the final resulting JSON document at the end of the pipeline). This can then in turn be used for the next stage and so on.\nFollowing are the possible stages in aggregation framework \u2212\n\n$project \u2212 Used to select some specific fields from a collection.\n$match \u2212 This is a filtering operation and thus this can reduce the amount of documents that are given as input to the next stage.\n$group \u2212 This does the actual aggregation as discussed above.\n$sort \u2212 Sorts the documents.\n$skip \u2212 With this, it is possible to skip forward in the list of documents for a given amount of documents.\n$limit \u2212 This limits the amount of documents to look at, by the given number starting from the current positions.\n$unwind \u2212 This is used to unwind document that are using arrays. When using an array, the data is kind of pre-joined and this operation will be undone with this to have individual documents again. Thus with this stage we will increase the amount of documents for the next stage.\n\nMongoDB - Replication\nReplication is the process of synchronizing data across multiple servers. Replication provides redundancy and increases data availability with multiple copies of data on different database servers. Replication protects a database from the loss of a single server. Replication also allows you to recover from hardware failure and service interruptions. With additional copies of the data, you can dedicate one to disaster recovery, reporting, or backup.\nWhy Replication?\n\nTo keep your data safe\nHigh (24*7) availability of data\nDisaster recovery\nNo downtime for maintenance (like backups, index rebuilds, compaction)\nRead scaling (extra copies to read from)\nReplica set is transparent to the application\n\nHow Replication Works in MongoDB\nMongoDB achieves replication by the use of replica set. A replica set is a group of mongod instances that host the same data set. In a replica, one node is primary node that receives all write operations. All other instances, such as secondaries, apply operations from the primary so that they have the same data set. Replica set can have only one primary node.\n\nReplica set is a group of two or more nodes (generally minimum 3 nodes are required).\nIn a replica set, one node is primary node and remaining nodes are secondary.\nAll data replicates from primary to secondary node.\nAt the time of automatic failover or maintenance, election establishes for primary and a new primary node is elected.\nAfter the recovery of failed node, it again join the replica set and works as a secondary node.\n\nA typical diagram of MongoDB replication is shown in which client application always interact with the primary node and the primary node then replicates the data to the secondary nodes.\n\nReplica Set Features\n\nA cluster of N nodes\nAny one node can be primary\nAll write operations go to primary\nAutomatic failover\nAutomatic recovery\nConsensus election of primary\n\nSet Up a Replica Set\nIn this tutorial, we will convert standalone MongoDB instance to a replica set. To convert to replica set, following are the steps \u2212\n\nShutdown already running MongoDB server.\n\nStart the MongoDB server by specifying -- replSet option. Following is the basic syntax of --replSet \u2212\n\n\nmongod --port \"PORT\" --dbpath \"YOUR_DB_DATA_PATH\" --replSet \"REPLICA_SET_INSTANCE_NAME\"\n\nExample\n\nmongod --port 27017 --dbpath \"D:\\set up\\mongodb\\data\" --replSet rs0\n\n\nIt will start a mongod instance with the name rs0, on port 27017.\nNow start the command prompt and connect to this mongod instance.\nIn Mongo client, issue the command rs.initiate() to initiate a new replica set.\nTo check the replica set configuration, issue the command rs.conf(). To check the status of replica set issue the command rs.status().\n\nAdd Members to Replica Set\nTo add members to replica set, start mongod instances on multiple machines. Now start a mongo client and issue a command rs.add().\nSyntax\nThe basic syntax of rs.add() command is as follows \u2212\n\n>rs.add(HOST_NAME:PORT)\n\nExample\nSuppose your mongod instance name is mongod1.net and it is running on port 27017. To add this instance to replica set, issue the command rs.add() in Mongo client.\n\n>rs.add(\"mongod1.net:27017\")\n>\n\nYou can add mongod instance to replica set only when you are connected to primary node. To check whether you are connected to primary or not, issue the command db.isMaster() in mongo client.\nMongoDB - Sharding\nSharding is the process of storing data records across multiple machines and it is MongoDB's approach to meeting the demands of data growth. As the size of the data increases, a single machine may not be sufficient to store the data nor provide an acceptable read and write throughput. Sharding solves the problem with horizontal scaling. With sharding, you add more machines to support data growth and the demands of read and write operations.\nWhy Sharding?\n\nIn replication, all writes go to master node\nLatency sensitive queries still go to master\nSingle replica set has limitation of 12 nodes\nMemory can't be large enough when active dataset is big\nLocal disk is not big enough\nVertical scaling is too expensive\n\nSharding in MongoDB\nThe following diagram shows the sharding in MongoDB using sharded cluster.\n\nIn the following diagram, there are three main components \u2212\n\nShards \u2212 Shards are used to store data. They provide high availability and data consistency. In production environment, each shard is a separate replica set.\nConfig Servers \u2212 Config servers store the cluster's metadata. This data contains a mapping of the cluster's data set to the shards. The query router uses this metadata to target operations to specific shards. In production environment, sharded clusters have exactly 3 config servers.\nQuery Routers \u2212 Query routers are basically mongo instances, interface with client applications and direct operations to the appropriate shard. The query router processes and targets the operations to shards and then returns results to the clients. A sharded cluster can contain more than one query router to divide the client request load. A client sends requests to one query router. Generally, a sharded cluster have many query routers.\n\nMongoDB - Create Backup\nIn this chapter, we will see how to create a backup in MongoDB.\nDump MongoDB Data\nTo create backup of database in MongoDB, you should use mongodump command. This command will dump the entire data of your server into the dump directory. There are many options available by which you can limit the amount of data or create backup of your remote server.\nSyntax\nThe basic syntax of mongodump command is as follows \u2212\n\n>mongodump\n\nExample\nStart your mongod server. Assuming that your mongod server is running on the localhost and port 27017, open a command prompt and go to the bin directory of your mongodb instance and type the command mongodump\nConsider the mycol collection has the following data.\n\n>mongodump\n\nThe command will connect to the server running at 127.0.0.1 and port 27017 and back all data of the server to directory /bin/dump/. Following is the output of the command \u2212\n\nFollowing is a list of available options that can be used with the mongodump command.\n\n\nSyntax\nDescription\nExample\n\n\nmongodump --host HOST_NAME --port PORT_NUMBER\nThis commmand will backup all databases of specified mongod instance.\nmongodump --host tutorialspoint.com --port 27017\n\nmongodump --dbpath DB_PATH --out BACKUP_DIRECTORY\nThis command will backup only specified database at specified path.\nmongodump --dbpath /data/db/ --out /data/backup/\n\nmongodump --collection COLLECTION --db DB_NAME\nThis command will backup only specified collection of specified database.\nmongodump --collection mycol --db test\n\nRestore data\nTo restore backup data MongoDB's mongorestore command is used. This command restores all of the data from the backup directory.\nSyntax\nThe basic syntax of mongorestore command is \u2212\n\n>mongorestore\n\nFollowing is the output of the command \u2212\n\nMongoDB - Deployment\nWhen you are preparing a MongoDB deployment, you should try to understand how your application is going to hold up in production. It\u2019s a good idea to develop a consistent, repeatable approach to managing your deployment environment so that you can minimize any surprises once you\u2019re in production.\nThe best approach incorporates prototyping your set up, conducting load testing, monitoring key metrics, and using that information to scale your set up. The key part of the approach is to proactively monitor your entire system - this will help you understand how your production system will hold up before deploying, and determine where you will need to add capacity. Having insight into potential spikes in your memory usage, for example, could help put out a write-lock fire before it starts.\nTo monitor your deployment, MongoDB provides some of the following commands \u2212\nmongostat\nThis command checks the status of all running mongod instances and return counters of database operations. These counters include inserts, queries, updates, deletes, and cursors. Command also shows when you\u2019re hitting page faults, and showcase your lock percentage. This means that you're running low on memory, hitting write capacity or have some performance issue.\nTo run the command, start your mongod instance. In another command prompt, go to bin directory of your mongodb installation and type mongostat.\n\nD:\\set up\\mongodb\\bin>mongostat\n\nFollowing is the output of the command \u2212\n\nmongotop\nThis command tracks and reports the read and write activity of MongoDB instance on a collection basis. By default, mongotop returns information in each second, which you can change it accordingly. You should check that this read and write activity matches your application intention, and you\u2019re not firing too many writes to the database at a time, reading too frequently from a disk, or are exceeding your working set size.\nTo run the command, start your mongod instance. In another command prompt, go to bin directory of your mongodb installation and type mongotop.\n\nD:\\set up\\mongodb\\bin>mongotop\n\nFollowing is the output of the command \u2212\n\nTo change mongotop command to return information less frequently, specify a specific number after the mongotop command.\n\nD:\\set up\\mongodb\\bin>mongotop 30\n\nThe above example will return values every 30 seconds.\nApart from the MongoDB tools, 10gen provides a free, hosted monitoring service, MongoDB Management Service (MMS), that provides a dashboard and gives you a view of the metrics from your entire cluster.\nMongoDB - Java\nIn this chapter, we will learn how to set up MongoDB JDBC driver.\nInstallation\nBefore you start using MongoDB in your Java programs, you need to make sure that you have MongoDB JDBC driver and Java set up on the machine. You can check Java tutorial for Java installation on your machine. Now, let us check how to set up MongoDB JDBC driver.\n\nYou need to download the jar from the path Download mongo.jar. Make sure to download the latest release of it.\nYou need to include the mongo.jar into your classpath.\n\nConnect to Database\nTo connect database, you need to specify the database name, if the database doesn't exist then MongoDB creates it automatically.\nFollowing is the code snippet to connect to the database \u2212\n\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class ConnectToDB { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n   \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n      System.out.println(\"Credentials ::\"+ credential);     \n   } \n}\n\nNow, let's compile and run the above program to create our database myDb as shown below.\n\n$javac ConnectToDB.java \n$java ConnectToDB\n\nOn executing, the above program gives you the following output.\n\nConnected to the database successfully \nCredentials ::MongoCredential{\n   mechanism = null, \n   userName = 'sampleUser', \n   source = 'myDb', \n   password = <hidden>, \n   mechanismProperties = {}\n}\n\nCreate a Collection\nTo create a collection, createCollection() method of com.mongodb.client.MongoDatabase class is used.\nFollowing is the code snippet to create a collection \u2212\n\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class CreatingCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      //Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      //Creating a collection \n      database.createCollection(\"sampleCollection\"); \n      System.out.println(\"Collection created successfully\"); \n   } \n} \n\nOn compiling, the above program gives you the following result \u2212\n\nConnected to the database successfully \nCollection created successfully\n\nGetting/Selecting a Collection\nTo get/select a collection from the database, getCollection() method of com.mongodb.client.MongoDatabase class is used.\nFollowing is the program to get/select a collection \u2212\n\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \n\nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class selectingCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Creating a collection \n      System.out.println(\"Collection created successfully\"); \n\n      // Retieving a collection\n      MongoCollection<Document> collection = database.getCollection(\"myCollection\"); \n      System.out.println(\"Collection myCollection selected successfully\"); \n   }\n}\n\nOn compiling, the above program gives you the following result \u2212\n\nConnected to the database successfully \nCollection created successfully \nCollection myCollection selected successfully\n\nInsert a Document\nTo insert a document into MongoDB, insert() method of com.mongodb.client.MongoCollection class is used.\nFollowing is the code snippet to insert a document \u2212\n\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \n\nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class InsertingDocument { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection\n      MongoCollection<Document> collection = database.getCollection(\"sampleCollection\"); \n      System.out.println(\"Collection sampleCollection selected successfully\");\n\n      Document document = new Document(\"title\", \"MongoDB\") \n      .append(\"id\", 1)\n      .append(\"description\", \"database\") \n      .append(\"likes\", 100) \n      .append(\"url\", \"http://www.tutorialspoint.com/mongodb/\") \n      .append(\"by\", \"tutorials point\");  \n      collection.insertOne(document); \n      System.out.println(\"Document inserted successfully\");     \n   } \n}\n\nOn compiling, the above program gives you the following result \u2212\n\nConnected to the database successfully \nCollection sampleCollection selected successfully \nDocument inserted successfully\n\nRetrieve All Documents\nTo select all documents from the collection, find() method of com.mongodb.client.MongoCollection class is used. This method returns a cursor, so you need to iterate this cursor.\nFollowing is the program to select all documents \u2212\n\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase;  \n\nimport java.util.Iterator; \nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class RetrievingAllDocuments { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential;\n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Retrieving a collection \n      MongoCollection<Document> collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection sampleCollection selected successfully\"); \n\n      // Getting the iterable object \n      FindIterable<Document> iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n    \n      while (it.hasNext()) {  \n         System.out.println(it.next());  \n      i++; \n      }\n   } \n}\n\nOn compiling, the above program gives you the following result \u2212\n\nDocument{{\n   _id = 5967745223993a32646baab8, \n   title = MongoDB, \n   id = 1, \n   description = database, \n   likes = 100, \n   url = http://www.tutorialspoint.com/mongodb/, by = tutorials point\n}}  \nDocument{{\n   _id = 7452239959673a32646baab8, \n   title = RethinkDB, \n   id = 2, \n   description = database, \n   likes = 200, \n   url = http://www.tutorialspoint.com/rethinkdb/, by = tutorials point\n}}\n\nUpdate Document\nTo update a document from the collection, updateOne() method of com.mongodb.client.MongoCollection class is used.\nFollowing is the program to select the first document \u2212\n\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.client.model.Filters; \nimport com.mongodb.client.model.Updates; \n\nimport java.util.Iterator; \nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class UpdatingDocuments { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection \n      MongoCollection<Document> collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection myCollection selected successfully\"); \n\n      collection.updateOne(Filters.eq(\"id\", 1), Updates.set(\"likes\", 150));       \n      System.out.println(\"Document update successfully...\");  \n      \n      // Retrieving the documents after updation \n      // Getting the iterable object\n      FindIterable<Document> iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n\n      while (it.hasNext()) {  \n         System.out.println(it.next());  \n         i++; \n      }     \n   }  \n}\n\nOn compiling, the above program gives you the following result \u2212\n\nDocument update successfully... \nDocument {{\n   _id = 5967745223993a32646baab8, \n   title = MongoDB, \n   id = 1, \n   description = database, \n   likes = 150, \n   url = http://www.tutorialspoint.com/mongodb/, by = tutorials point\n}}\n\nDelete a Document\nTo delete a document from the collection, you need to use the deleteOne() method of the com.mongodb.client.MongoCollection class.\nFollowing is the program to delete a document \u2212\n\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.client.model.Filters;  \n\nimport java.util.Iterator; \nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class DeletingDocuments { \n   \n   public static void main( String args[] ) {  \n   \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 );\n      \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection\n      MongoCollection<Document> collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection sampleCollection selected successfully\"); \n\n      // Deleting the documents \n      collection.deleteOne(Filters.eq(\"id\", 1)); \n      System.out.println(\"Document deleted successfully...\");  \n      \n      // Retrieving the documents after updation \n      // Getting the iterable object \n      FindIterable<Document> iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n\n      while (it.hasNext()) {  \n         System.out.println(\"Inserted Document: \"+i);  \n         System.out.println(it.next());  \n         i++; \n      }       \n   } \n}\n\nOn compiling, the above program gives you the following result \u2212\n\nConnected to the database successfully \nCollection sampleCollection selected successfully \nDocument deleted successfully...\n\nDropping a Collection\nTo drop a collection from a database, you need to use the drop() method of the com.mongodb.client.MongoCollection class.\nFollowing is the program to delete a collection \u2212\n\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase;  \n\nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class DropingCollection { \n   \n   public static void main( String args[] ) {  \n\n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Creating a collection \n      System.out.println(\"Collections created successfully\"); \n\n      // Retieving a collection\n      MongoCollection<Document> collection = database.getCollection(\"sampleCollection\");\n\n      // Dropping a Collection \n      collection.drop(); \n      System.out.println(\"Collection dropped successfully\");\n   } \n}\n\nOn compiling, the above program gives you the following result \u2212\n\nConnected to the database successfully \nCollection sampleCollection selected successfully \nCollection dropped successfully\n\nListing All the Collections\nTo list all the collections in a database, you need to use the listCollectionNames()  method of the com.mongodb.client.MongoDatabase class.\nFollowing is the program to list all the collections of a database \u2212\n\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class ListOfCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n\n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n      System.out.println(\"Collection created successfully\"); \n      for (String name : database.listCollectionNames()) { \n         System.out.println(name); \n      } \n   }\n} \n\nOn compiling, the above program gives you the following result \u2212\n\nConnected to the database successfully \nCollection created successfully \nmyCollection \nmyCollection1 \nmyCollection5\n\nRemaining MongoDB methods save(), limit(), skip(), sort() etc. work same as explained in the subsequent tutorial.\nMongoDB - PHP\nTo use MongoDB with PHP, you need to use MongoDB PHP driver. Download the driver from the url Download PHP Driver. Make sure to download the latest release of it. Now unzip the archive and put php_mongo.dll in your PHP extension directory (\"ext\" by default) and add the following line to your php.ini file \u2212\n\nextension = php_mongo.dll\n\nMake a Connection and Select a Database\nTo make a connection, you need to specify the database name, if the database doesn't exist then MongoDB creates it automatically.\nFollowing is the code snippet to connect to the database \u2212\n\n<?php\n   // connect to mongodb\n   $m = new MongoClient();\n\t\n   echo \"Connection to database successfully\";\n   // select a database\n   $db = $m->mydb;\n\t\n   echo \"Database mydb selected\";\n?>\n\nWhen the program is executed, it will produce the following result \u2212\n\nConnection to database successfully\nDatabase mydb selected\n\nCreate a Collection\nFollowing is the code snippet to create a collection \u2212\n\n<?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m->mydb;\n   echo \"Database mydb selected\";\n   $collection = $db->createCollection(\"mycol\");\n   echo \"Collection created succsessfully\";\n?>\n\nWhen the program is executed, it will produce the following result \u2212\n\nConnection to database successfully\nDatabase mydb selected\nCollection created succsessfully\n\nInsert a Document\nTo insert a document into MongoDB, insert() method is used.\nFollowing is the code snippet to insert a document \u2212\n\n<?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m->mydb;\n   echo \"Database mydb selected\";\n   $collection = $db->mycol;\n   echo \"Collection selected succsessfully\";\n\t\n   $document = array( \n      \"title\" => \"MongoDB\", \n      \"description\" => \"database\", \n      \"likes\" => 100,\n      \"url\" => \"http://www.tutorialspoint.com/mongodb/\",\n      \"by\" => \"tutorials point\"\n   );\n\t\n   $collection->insert($document);\n   echo \"Document inserted successfully\";\n?>\n\nWhen the program is executed, it will produce the following result \u2212\n\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocument inserted successfully\n\nFind All Documents\nTo select all documents from the collection, find() method is used.\nFollowing is the code snippet to select all documents \u2212\n\n<?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m->mydb;\n   echo \"Database mydb selected\";\n   $collection = $db->mycol;\n   echo \"Collection selected succsessfully\";\n\n   $cursor = $collection->find();\n   // iterate cursor to display title of documents\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?>\n\nWhen the program is executed, it will produce the following result \u2212\n\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully {\n   \"title\": \"MongoDB\"\n}\n\nUpdate a Document\nTo update a document, you need to use the update() method.\nIn the following example, we will update the title of inserted document to MongoDB Tutorial. Following is the code snippet to update a document \u2212\n\n<?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m->mydb;\n   echo \"Database mydb selected\";\n   $collection = $db->mycol;\n   echo \"Collection selected succsessfully\";\n\n   // now update the document\n   $collection->update(array(\"title\"=>\"MongoDB\"), \n      array('$set'=>array(\"title\"=>\"MongoDB Tutorial\")));\n   echo \"Document updated successfully\";\n\t\n   // now display the updated document\n   $cursor = $collection->find();\n\t\n   // iterate cursor to display title of documents\n   echo \"Updated document\";\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?>\n\nWhen the program is executed, it will produce the following result \u2212\n\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocument updated successfully\nUpdated document {\n   \"title\": \"MongoDB Tutorial\"\n}\n\nDelete a Document\nTo delete a document, you need to use remove() method.\nIn the following example, we will remove the documents that has the title MongoDB Tutorial. Following is the code snippet to delete a document \u2212\n\n<?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m->mydb;\n   echo \"Database mydb selected\";\n   $collection = $db->mycol;\n   echo \"Collection selected succsessfully\";\n   \n   // now remove the document\n   $collection->remove(array(\"title\"=>\"MongoDB Tutorial\"),false);\n   echo \"Documents deleted successfully\";\n   \n   // now display the available documents\n   $cursor = $collection->find();\n\t\n   // iterate cursor to display title of documents\n   echo \"Updated document\";\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?>\n\nWhen the program is executed, it will produce the following result \u2212\n\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocuments deleted successfully\n\nIn the above example, the second parameter is boolean type and used for justOne field of remove() method.\nRemaining MongoDB methods findOne(), save(), limit(), skip(), sort() etc. works same as explained above.\nMongoDB - Relationships\nRelationships in MongoDB represent how various documents are logically related to each other. Relationships can be modeled via Embedded and Referenced approaches. Such relationships can be either 1:1, 1:N, N:1 or N:N.\nLet us consider the case of storing addresses for users. So, one user can have multiple addresses making this a 1:N relationship.\nFollowing is the sample document structure of user document \u2212\n\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"name\": \"Tom Hanks\",\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\"\n}\n\nFollowing is the sample document structure of address document \u2212\n\n{\n   \"_id\":ObjectId(\"52ffc4a5d85242602e000000\"),\n   \"building\": \"22 A, Indiana Apt\",\n   \"pincode\": 123456,\n   \"city\": \"Los Angeles\",\n   \"state\": \"California\"\n} \n\nModeling Embedded Relationships\nIn the embedded approach, we will embed the address document inside the user document.\n\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\",\n   \"address\": [\n      {\n         \"building\": \"22 A, Indiana Apt\",\n         \"pincode\": 123456,\n         \"city\": \"Los Angeles\",\n         \"state\": \"California\"\n      },\n      {\n         \"building\": \"170 A, Acropolis Apt\",\n         \"pincode\": 456789,\n         \"city\": \"Chicago\",\n         \"state\": \"Illinois\"\n      }\n   ]\n} \n\nThis approach maintains all the related data in a single document, which makes it easy to retrieve and maintain. The whole document can be retrieved in a single query such as \u2212\n\n>db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address\":1})\n\nNote that in the above query, db and users are the database and collection respectively.\nThe drawback is that if the embedded document keeps on growing too much in size, it can impact the read/write performance.\nModeling Referenced Relationships\nThis is the approach of designing normalized relationship. In this approach, both the user and address documents will be maintained separately but the user document will contain a field that will reference the address document's id field.\n\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\",\n   \"address_ids\": [\n      ObjectId(\"52ffc4a5d85242602e000000\"),\n      ObjectId(\"52ffc4a5d85242602e000001\")\n   ]\n}\n\nAs shown above, the user document contains the array field address_ids which contains ObjectIds of corresponding addresses. Using these ObjectIds, we can query the address documents and get address details from there. With this approach, we will need two queries: first to fetch the address_ids fields from user document and second to fetch these addresses from address collection.\n\n>var result = db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address_ids\":1})\n>var addresses = db.address.find({\"_id\":{\"$in\":result[\"address_ids\"]}})\n\nMongoDB - Database References\nAs seen in the last chapter of MongoDB relationships, to implement a normalized database structure in MongoDB, we use the concept of Referenced Relationships also referred to as Manual References in which we manually store the referenced document's id inside other document. However, in cases where a document contains references from different collections, we can use MongoDB DBRefs.\nDBRefs vs Manual References\nAs an example scenario, where we would use DBRefs instead of manual references, consider a database where we are storing different types of addresses (home, office, mailing, etc.) in different collections (address_home, address_office, address_mailing, etc). Now, when a user collection's document references an address, it also needs to specify which collection to look into based on the address type. In such scenarios where a document references documents from many collections, we should use DBRefs.\nUsing DBRefs\nThere are three fields in DBRefs \u2212\n\n$ref \u2212 This field specifies the collection of the referenced document\n$id \u2212 This field specifies the _id field of the referenced document\n$db \u2212 This is an optional field and contains the name of the database in which the referenced document lies\n\nConsider a sample user document having DBRef field address as shown in the code snippet \u2212\n\n{\n   \"_id\":ObjectId(\"53402597d852426020000002\"),\n   \"address\": {\n   \"$ref\": \"address_home\",\n   \"$id\": ObjectId(\"534009e4d852427820000002\"),\n   \"$db\": \"tutorialspoint\"},\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\"\n}\n\nThe address DBRef field here specifies that the referenced address document lies in address_home collection under tutorialspoint database and has an id of 534009e4d852427820000002.\nThe following code dynamically looks in the collection specified by $ref parameter (address_home in our case) for a document with id as specified by $id parameter in DBRef.\n\n>var user = db.users.findOne({\"name\":\"Tom Benzamin\"})\n>var dbRef = user.address\n>db[dbRef.$ref].findOne({\"_id\":(dbRef.$id)})\n\nThe above code returns the following address document present in address_home collection \u2212\n\n{\n   \"_id\" : ObjectId(\"534009e4d852427820000002\"),\n   \"building\" : \"22 A, Indiana Apt\",\n   \"pincode\" : 123456,\n   \"city\" : \"Los Angeles\",\n   \"state\" : \"California\"\n}\n\nMongoDB - Covered Queries\nIn this chapter, we will learn about covered queries.\nWhat is a Covered Query?\nAs per the official MongoDB documentation, a covered query is a query in which \u2212\n\nAll the fields in the query are part of an index.\nAll the fields returned in the query are in the same index.\n\nSince all the fields present in the query are part of an index, MongoDB matches the query conditions and returns the result using the same index without actually looking inside the documents. Since indexes are present in RAM, fetching data from indexes is much faster as compared to fetching data by scanning documents.\nUsing Covered Queries\nTo test covered queries, consider the following document in the users collection \u2212\n\n{\n   \"_id\": ObjectId(\"53402597d852426020000002\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"gender\": \"M\",\n   \"name\": \"Tom Benzamin\",\n   \"user_name\": \"tombenzamin\"\n}\n\nWe will first create a compound index for the users collection on the fields gender and user_name using the following query \u2212\n\n>db.users.ensureIndex({gender:1,user_name:1})\n\nNow, this index will cover the following query \u2212\n\n>db.users.find({gender:\"M\"},{user_name:1,_id:0})\n\nThat is to say that for the above query, MongoDB would not go looking into database documents. Instead it would fetch the required data from indexed data which is very fast.\nSince our index does not include _id field, we have explicitly excluded it from result set of our query, as MongoDB by default returns _id field in every query. So the following query would not have been covered inside the index created above \u2212\n\n>db.users.find({gender:\"M\"},{user_name:1})\n\nLastly, remember that an index cannot cover a query if \u2212\n\nAny of the indexed fields is an array\nAny of the indexed fields is a subdocument\n\nMongoDB - Analyzing Queries\nAnalyzing queries is a very important aspect of measuring how effective the database and indexing design is. We will learn about the frequently used $explain and $hint queries.\nUsing $explain\nThe $explain operator provides information on the query, indexes used in a query and other statistics. It is very useful when analyzing how well your indexes are optimized.\nIn the last chapter, we had already created an index for the users collection on fields gender and user_name using the following query \u2212\n\n>db.users.ensureIndex({gender:1,user_name:1})\n\nWe will now use $explain on the following query \u2212\n\n>db.users.find({gender:\"M\"},{user_name:1,_id:0}).explain()\n\nThe above explain() query returns the following analyzed result \u2212\n\n{\n   \"cursor\" : \"BtreeCursor gender_1_user_name_1\",\n   \"isMultiKey\" : false,\n   \"n\" : 1,\n   \"nscannedObjects\" : 0,\n   \"nscanned\" : 1,\n   \"nscannedObjectsAllPlans\" : 0,\n   \"nscannedAllPlans\" : 1,\n   \"scanAndOrder\" : false,\n   \"indexOnly\" : true,\n   \"nYields\" : 0,\n   \"nChunkSkips\" : 0,\n   \"millis\" : 0,\n   \"indexBounds\" : {\n      \"gender\" : [\n         [\n            \"M\",\n            \"M\"\n         ]\n      ],\n      \"user_name\" : [\n         [\n            {\n               \"$minElement\" : 1\n            },\n            {\n               \"$maxElement\" : 1\n            }\n         ]\n      ]\n   }\n}\n\nWe will now look at the fields in this result set \u2212\n\nThe true value of indexOnly indicates that this query has used indexing.\nThe cursor field specifies the type of cursor used. BTreeCursor type indicates that an index was used and also gives the name of the index used. BasicCursor indicates that a full scan was made without using any indexes.\nn indicates the number of documents matching returned.\nnscannedObjects indicates the total number of documents scanned.\nnscanned indicates the total number of documents or index entries scanned.\n\nUsing $hint\nThe $hint operator forces the query optimizer to use the specified index to run a query. This is particularly useful when you want to test performance of a query with different indexes. For example, the following query specifies the index on fields gender and user_name to be used for this query \u2212\n\n>db.users.find({gender:\"M\"},{user_name:1,_id:0}).hint({gender:1,user_name:1})\n\nTo analyze the above query using $explain \u2212\n\n>db.users.find({gender:\"M\"},{user_name:1,_id:0}).hint({gender:1,user_name:1}).explain()\n\nMongoDB - Atomic Operations\nMongoDB does not support multi-document atomic transactions. However, it does provide atomic operations on a single document. So if a document has hundred fields the update statement will either update all the fields or none, hence maintaining atomicity at the document-level.\nModel Data for Atomic Operations\nThe recommended approach to maintain atomicity would be to keep all the related information, which is frequently updated together in a single document using embedded documents. This would make sure that all the updates for a single document are atomic.\nConsider the following products document \u2212\n\n{\n   \"_id\":1,\n   \"product_name\": \"Samsung S3\",\n   \"category\": \"mobiles\",\n   \"product_total\": 5,\n   \"product_available\": 3,\n   \"product_bought_by\": [\n      {\n         \"customer\": \"john\",\n         \"date\": \"7-Jan-2014\"\n      },\n      {\n         \"customer\": \"mark\",\n         \"date\": \"8-Jan-2014\"\n      }\n   ]\n}\n\nIn this document, we have embedded the information of the customer who buys the product in the product_bought_by field. Now, whenever a new customer buys the product, we will first check if the product is still available using product_available field. If available, we will reduce the value of product_available field as well as insert the new customer's embedded document in the product_bought_by field. We will use findAndModify command for this functionality because it searches and updates the document in the same go.\n\n>db.products.findAndModify({ \n   query:{_id:2,product_available:{$gt:0}}, \n   update:{ \n      $inc:{product_available:-1}, \n      $push:{product_bought_by:{customer:\"rob\",date:\"9-Jan-2014\"}} \n   }    \n})\n\nOur approach of embedded document and using findAndModify query makes sure that the product purchase information is updated only if it the product is available. And the whole of this transaction being in the same query, is atomic.\nIn contrast to this, consider the scenario where we may have kept the product availability and the information on who has bought the product, separately. In this case, we will first check if the product is available using the first query. Then in the second query we will update the purchase information. However, it is possible that between the executions of these two queries, some other user has purchased the product and it is no more available. Without knowing this, our second query will update the purchase information based on the result of our first query. This will make the database inconsistent because we have sold a product which is not available.\nMongoDB - Advanced Indexing\nConsider the following document of the users collection \u2212\n\n{\n   \"address\": {\n      \"city\": \"Los Angeles\",\n      \"state\": \"California\",\n      \"pincode\": \"123\"\n   },\n   \"tags\": [\n      \"music\",\n      \"cricket\",\n      \"blogs\"\n   ],\n   \"name\": \"Tom Benzamin\"\n}\n\nThe above document contains an address sub-document and a tags array.\nIndexing Array Fields\nSuppose we want to search user documents based on the user\u2019s tags. For this, we will create an index on tags array in the collection.\nCreating an index on array in turn creates separate index entries for each of its fields. So in our case when we create an index on tags array, separate indexes will be created for its values music, cricket and blogs.\nTo create an index on tags array, use the following code \u2212\n\n>db.users.ensureIndex({\"tags\":1})\n\nAfter creating the index, we can search on the tags field of the collection like this \u2212\n\n>db.users.find({tags:\"cricket\"})\n\nTo verify that proper indexing is used, use the following explain command \u2212\n\n>db.users.find({tags:\"cricket\"}).explain()\n\nThe above command resulted in \"cursor\" : \"BtreeCursor tags_1\" which confirms that proper indexing is used.\nIndexing Sub-Document Fields\nSuppose that we want to search documents based on city, state and pincode fields. Since all these fields are part of address sub-document field, we will create an index on all the fields of the sub-document.\nFor creating an index on all the three fields of the sub-document, use the following code \u2212\n\n>db.users.ensureIndex({\"address.city\":1,\"address.state\":1,\"address.pincode\":1})\n\nOnce the index is created, we can search for any of the sub-document fields utilizing this index as follows \u2212\n\n>db.users.find({\"address.city\":\"Los Angeles\"})   \n\nRemember that the query expression has to follow the order of the index specified. So the index created above would support the following queries \u2212\n\n>db.users.find({\"address.city\":\"Los Angeles\",\"address.state\":\"California\"}) \n\nIt will also support the following query \u2212\n\n>db.users.find({\"address.city\":\"LosAngeles\",\"address.state\":\"California\",\n   \"address.pincode\":\"123\"})\n\nMongoDB - Indexing Limitations\nIn this chapter, we will learn about Indexing Limitations and its other components.\nExtra Overhead\nEvery index occupies some space as well as causes an overhead on each insert, update and delete. So if you rarely use your collection for read operations, it makes sense not to use indexes.\nRAM Usage\nSince indexes are stored in RAM, you should make sure that the total size of the index does not exceed the RAM limit. If the total size increases the RAM size, it will start deleting some indexes, causing performance loss.\nQuery Limitations\nIndexing can't be used in queries which use \u2212\n\nRegular expressions or negation operators like $nin, $not, etc.\nArithmetic operators like $mod, etc.\n$where clause\n\nHence, it is always advisable to check the index usage for your queries.\nIndex Key Limits\nStarting from version 2.6, MongoDB will not create an index if the value of existing index field exceeds the index key limit.\nInserting Documents Exceeding Index Key Limit\nMongoDB will not insert any document into an indexed collection if the indexed field value of this document exceeds the index key limit. Same is the case with mongorestore and mongoimport utilities.\nMaximum Ranges\n\nA collection cannot have more than 64 indexes.\nThe length of the index name cannot be longer than 125 characters.\nA compound index can have maximum 31 fields indexed.\n\nMongoDB - ObjectId\nWe have been using MongoDB Object Id in all the previous chapters. In this chapter, we will understand the structure of ObjectId.\nAn ObjectId is a 12-byte BSON type having the following structure \u2212\n\nThe first 4 bytes representing the seconds since the unix epoch\nThe next 3 bytes are the machine identifier\nThe next 2 bytes consists of process id\nThe last 3 bytes are a random counter value\n\nMongoDB uses ObjectIds as the default value of _id field of each document, which is generated while the creation of any document. The complex combination of ObjectId makes all the _id fields unique.\nCreating New ObjectId\nTo generate a new ObjectId use the following code \u2212\n\n>newObjectId = ObjectId()\n\nThe above statement returned the following uniquely generated id \u2212\n\nObjectId(\"5349b4ddd2781d08c09890f3\")\n\nInstead of MongoDB generating the ObjectId, you can also provide a 12-byte id \u2212\n\n>myObjectId = ObjectId(\"5349b4ddd2781d08c09890f4\")\n\nCreating Timestamp of a Document\nSince the _id ObjectId by default stores the 4-byte timestamp, in most cases you do not need to store the creation time of any document. You can fetch the creation time of a document using getTimestamp method \u2212\n\n>ObjectId(\"5349b4ddd2781d08c09890f4\").getTimestamp()\n\nThis will return the creation time of this document in ISO date format \u2212\n\nISODate(\"2014-04-12T21:49:17Z\")\n\nConverting ObjectId to String\nIn some cases, you may need the value of ObjectId in a string format. To convert the ObjectId in string, use the following code \u2212\n\n>newObjectId.str\n\nThe above code will return the string format of the Guid \u2212\n\n5349b4ddd2781d08c09890f3\n\nMongoDB - Map Reduce\nAs per the MongoDB documentation, Map-reduce is a data processing paradigm for condensing large volumes of data into useful aggregated results. MongoDB uses mapReduce command for map-reduce operations. MapReduce is generally used for processing large data sets.\nMapReduce Command\nFollowing is the syntax of the basic mapReduce command \u2212\n\n>db.collection.mapReduce(\n   function() {emit(key,value);},  //map function\n   function(key,values) {return reduceFunction}, {   //reduce function\n      out: collection,\n      query: document,\n      sort: document,\n      limit: number\n   }\n)\n\nThe map-reduce function first queries the collection, then maps the result documents to emit key-value pairs, which is then reduced based on the keys that have multiple values.\nIn the above syntax \u2212\n\nmap is a javascript function that maps a value with a key and emits a key-value pair\nreduce is a javascript function that reduces or groups all the documents having the same key\nout specifies the location of the map-reduce query result\nquery specifies the optional selection criteria for selecting documents\nsort specifies the optional sort criteria\nlimit specifies the optional maximum number of documents to be returned\n\nUsing MapReduce\nConsider the following document structure storing user posts. The document stores user_name of the user and the status of post.\n\n{\n   \"post_text\": \"tutorialspoint is an awesome website for tutorials\",\n   \"user_name\": \"mark\",\n   \"status\":\"active\"\n}\n\nNow, we will use a mapReduce function on our posts collection to select all the active posts, group them on the basis of user_name and then count the number of posts by each user using the following code \u2212\n\n>db.posts.mapReduce( \n   function() { emit(this.user_id,1); }, \n\t\n   function(key, values) {return Array.sum(values)}, {  \n      query:{status:\"active\"},  \n      out:\"post_total\" \n   }\n)\n\nThe above mapReduce query outputs the following result \u2212\n\n{\n   \"result\" : \"post_total\",\n   \"timeMillis\" : 9,\n   \"counts\" : {\n      \"input\" : 4,\n      \"emit\" : 4,\n      \"reduce\" : 2,\n      \"output\" : 2\n   },\n   \"ok\" : 1,\n}\n\nThe result shows that a total of 4 documents matched the query (status:\"active\"), the map function emitted 4 documents with key-value pairs and finally the reduce function grouped mapped documents having the same keys into 2.\nTo see the result of this mapReduce query, use the find operator \u2212\n\n>db.posts.mapReduce( \n   function() { emit(this.user_id,1); }, \n   function(key, values) {return Array.sum(values)}, {  \n      query:{status:\"active\"},  \n      out:\"post_total\" \n   }\n\t\n).find()\n\nThe above query gives the following result which indicates that both users tom and mark have two posts in active states \u2212\n\n{ \"_id\" : \"tom\", \"value\" : 2 }\n{ \"_id\" : \"mark\", \"value\" : 2 }\n\nIn a similar manner, MapReduce queries can be used to construct large complex aggregation queries. The use of custom Javascript functions make use of MapReduce which is very flexible and powerful.\nMongoDB - Text Search\nStarting from version 2.4, MongoDB started supporting text indexes to search inside string content. The Text Search uses stemming techniques to look for specified words in the string fields by dropping stemming stop words like a, an, the, etc. At present, MongoDB supports around 15 languages.\nEnabling Text Search\nInitially, Text Search was an experimental feature but starting from version 2.6, the configuration is enabled by default. But if you are using the previous version of MongoDB, you have to enable text search with the following code \u2212\n\n>db.adminCommand({setParameter:true,textSearchEnabled:true})\n\nCreating Text Index\nConsider the following document under posts collection containing the post text and its tags \u2212\n\n{\n   \"post_text\": \"enjoy the mongodb articles on tutorialspoint\",\n   \"tags\": [\n      \"mongodb\",\n      \"tutorialspoint\"\n   ]\n}\n\nWe will create a text index on post_text field so that we can search inside our posts' text \u2212\n\n>db.posts.ensureIndex({post_text:\"text\"})\n\nUsing Text Index\nNow that we have created the text index on post_text field, we will search for all the posts having the word tutorialspoint in their text.\n\n>db.posts.find({$text:{$search:\"tutorialspoint\"}})\n\nThe above command returned the following result documents having the word tutorialspoint in their post text \u2212\n\n{ \n   \"_id\" : ObjectId(\"53493d14d852429c10000002\"), \n   \"post_text\" : \"enjoy the mongodb articles on tutorialspoint\", \n   \"tags\" : [ \"mongodb\", \"tutorialspoint\" ]\n}\n{\n   \"_id\" : ObjectId(\"53493d1fd852429c10000003\"), \n   \"post_text\" : \"writing tutorials on mongodb\",\n   \"tags\" : [ \"mongodb\", \"tutorial\" ] \n}\n\nIf you are using old versions of MongoDB, you have to use the following command \u2212\n\n>db.posts.runCommand(\"text\",{search:\" tutorialspoint \"})\n\nUsing Text Search highly improves the search efficiency as compared to normal search.\nDeleting Text Index\nTo delete an existing text index, first find the name of index using the following query \u2212\n\n>db.posts.getIndexes()\n\nAfter getting the name of your index from above query, run the following command. Here, post_text_text is the name of the index.\n\n>db.posts.dropIndex(\"post_text_text\")\n\nMongoDB - Regular Expression\nRegular Expressions are frequently used in all languages to search for a pattern or word in any string. MongoDB also provides functionality of regular expression for string pattern matching using the $regex operator. MongoDB uses PCRE (Perl Compatible Regular Expression) as regular expression language.\nUnlike text search, we do not need to do any configuration or command to use regular expressions.\nConsider the following document structure under posts collection containing the post text and its tags \u2212\n\n{\n   \"post_text\": \"enjoy the mongodb articles on tutorialspoint\",\n   \"tags\": [\n      \"mongodb\",\n      \"tutorialspoint\"\n   ]\n}\n\nUsing regex Expression\nThe following regex query searches for all the posts containing string tutorialspoint in it \u2212\n\n>db.posts.find({post_text:{$regex:\"tutorialspoint\"}})\n\nThe same query can also be written as \u2212\n\n>db.posts.find({post_text:/tutorialspoint/})\n\nUsing regex Expression with Case Insensitive\nTo make the search case insensitive, we use the $options parameter with value $i. The following command will look for strings having the word tutorialspoint, irrespective of smaller or capital case \u2212\n\n>db.posts.find({post_text:{$regex:\"tutorialspoint\",$options:\"$i\"}})\n\nOne of the results returned from this query is the following document which contains the word tutorialspoint in different cases \u2212\n\n{\n   \"_id\" : ObjectId(\"53493d37d852429c10000004\"),\n   \"post_text\" : \"hey! this is my post on TutorialsPoint\", \n   \"tags\" : [ \"tutorialspoint\" ]\n} \n \nUsing regex for Array Elements\nWe can also use the concept of regex on array field. This is particularly very important when we implement the functionality of tags. So, if you want to search for all the posts having tags beginning from the word tutorial (either tutorial or tutorials or tutorialpoint or tutorialphp), you can use the following code \u2212\n\n>db.posts.find({tags:{$regex:\"tutorial\"}})\n\nOptimizing Regular Expression Queries\n\nIf the document fields are indexed, the query will use make use of indexed values to match the regular expression. This makes the search very fast as compared to the regular expression scanning the whole collection.\nIf the regular expression is a prefix expression, all the matches are meant to start with a certain string characters. For e.g., if the regex expression is ^tut, then the query has to search for only those strings that begin with tut.\n\nWorking with RockMongo\nRockMongo is a MongoDB administration tool using which you can manage your server, databases, collections, documents, indexes, and a lot more. It provides a very user-friendly way for reading, writing, and creating documents. It is similar to PHPMyAdmin tool for PHP and MySQL.\nDownloading RockMongo\nYou can download the latest version of RockMongo from here: http://rockmongo.com/downloads\nInstalling RockMongo\nOnce downloaded, you can unzip the package in your server root folder and rename the extracted folder to rockmongo. Open any web browser and access the index.php page from the folder rockmongo. Enter admin/admin as username/password respectively.\nWorking with RockMongo\nWe will now be looking at some basic operations that you can perform with RockMongo.\nCreating New Database\nTo create a new database, click Databases tab. Click Create New Database. On the next screen, provide the name of the new database and click on Create. You will see a new database getting added in the left panel.\nCreating New Collection\nTo create a new collection inside a database, click on that database from the left panel. Click on the New Collection link on top. Provide the required name of the collection. Do not worry about the other fields of Is Capped, Size and Max. Click on Create. A new collection will be created and you will be able to see it in the left panel.\nCreating New Document\nTo create a new document, click on the collection under which you want to add documents. When you click on a collection, you will be able to see all the documents within that collection listed there. To create a new document, click on the Insert link at the top. You can enter the document's data either in JSON or array format and click on Save.\nExport/Import Data\nTo import/export data of any collection, click on that collection and then click on Export/Import link on the top panel. Follow the next instructions to export your data in a zip format and then import the same zip file to import back data.\nMongoDB - GridFS\nGridFS is the MongoDB specification for storing and retrieving large files such as images, audio files, video files, etc. It is kind of a file system to store files but its data is stored within MongoDB collections. GridFS has the capability to store files even greater than its document size limit of 16MB.\nGridFS divides a file into chunks and stores each chunk of data in a separate document, each of maximum size 255k.\nGridFS by default uses two collections fs.files and fs.chunks to store the file's metadata and the chunks. Each chunk is identified by its unique _id ObjectId field. The fs.files serves as a parent document. The files_id field in the fs.chunks document links the chunk to its parent.\nFollowing is a sample document of fs.files collection \u2212\n\n{\n   \"filename\": \"test.txt\",\n   \"chunkSize\": NumberInt(261120),\n   \"uploadDate\": ISODate(\"2014-04-13T11:32:33.557Z\"),\n   \"md5\": \"7b762939321e146569b07f72c62cca4f\",\n   \"length\": NumberInt(646)\n}\n\nThe document specifies the file name, chunk size, uploaded date, and length.\nFollowing is a sample document of fs.chunks document \u2212\n\n{\n   \"files_id\": ObjectId(\"534a75d19f54bfec8a2fe44b\"),\n   \"n\": NumberInt(0),\n   \"data\": \"Mongo Binary Data\"\n}\n\nAdding Files to GridFS\nNow, we will store an mp3 file using GridFS using the put command. For this, we will use the mongofiles.exe utility present in the bin folder of the MongoDB installation folder.\nOpen your command prompt, navigate to the mongofiles.exe in the bin folder of MongoDB installation folder and type the following code \u2212\n\n>mongofiles.exe -d gridfs put song.mp3\n\nHere, gridfs is the name of the database in which the file will be stored. If the database is not present, MongoDB will automatically create a new document on the fly. Song.mp3 is the name of the file uploaded. To see the file's document in database, you can use find query \u2212\n\n>db.fs.files.find()\n\nThe above command returned the following document \u2212\n\n{\n   _id: ObjectId('534a811bf8b4aa4d33fdf94d'), \n   filename: \"song.mp3\", \n   chunkSize: 261120, \n   uploadDate: new Date(1397391643474), md5: \"e4f53379c909f7bed2e9d631e15c1c41\",\n   length: 10401959 \n}\n\nWe can also see all the chunks present in fs.chunks collection related to the stored file with the following code, using the document id returned in the previous query \u2212\n\n>db.fs.chunks.find({files_id:ObjectId('534a811bf8b4aa4d33fdf94d')})\n\nIn my case, the query returned 40 documents meaning that the whole mp3 document was divided in 40 chunks of data.\nMongoDB - Capped Collections\nCapped collections are fixed-size circular collections that follow the insertion order to support high performance for create, read, and delete operations. By circular, it means that when the fixed size allocated to the collection is exhausted, it will start deleting the oldest document in the collection without providing any explicit commands.\nCapped collections restrict updates to the documents if the update results in increased document size. Since capped collections store documents in the order of the disk storage, it ensures that the document size does not increase the size allocated on the disk. Capped collections are best for storing log information, cache data, or any other high volume data.\nCreating Capped Collection\nTo create a capped collection, we use the normal createCollection command but with capped option as true and specifying the maximum size of collection in bytes.\n\n>db.createCollection(\"cappedLogCollection\",{capped:true,size:10000})\n\nIn addition to collection size, we can also limit the number of documents in the collection using the max parameter \u2212\n\n>db.createCollection(\"cappedLogCollection\",{capped:true,size:10000,max:1000})\n\nIf you want to check whether a collection is capped or not, use the following isCapped command \u2212\n\n>db.cappedLogCollection.isCapped()\n\nIf there is an existing collection which you are planning to convert to capped, you can do it with the following code \u2212\n\n>db.runCommand({\"convertToCapped\":\"posts\",size:10000})\n\nThis code would convert our existing collection posts to a capped collection.\nQuerying Capped Collection\nBy default, a find query on a capped collection will display results in insertion order. But if you want the documents to be retrieved in reverse order, use the sort command as shown in the following code \u2212\n\n>db.cappedLogCollection.find().sort({$natural:-1})\n\nThere are few other important points regarding capped collections worth knowing \u2212\n\nWe cannot delete documents from a capped collection.\nThere are no default indexes present in a capped collection, not even on _id field.\nWhile inserting a new document, MongoDB does not have to actually look for a place to accommodate new document on the disk. It can blindly insert the new document at the tail of the collection. This makes insert operations in capped collections very fast.\nSimilarly, while reading documents MongoDB returns the documents in the same order as present on disk. This makes the read operation very fast.\n\nMongoDB - Auto-Increment Sequence\nMongoDB does not have out-of-the-box auto-increment functionality, like SQL databases. By default, it uses the 12-byte ObjectId for the _id field as the primary key to uniquely identify the documents. However, there may be scenarios where we may want the _id field to have some auto-incremented value other than the ObjectId.\nSince this is not a default feature in MongoDB, we will programmatically achieve this functionality by using a counters collection as suggested by the MongoDB documentation.\nUsing Counter Collection\nConsider the following products document. We want the _id field to be an auto-incremented integer sequence starting from 1,2,3,4 upto n.\n\n{\n  \"_id\":1,\n  \"product_name\": \"Apple iPhone\",\n  \"category\": \"mobiles\"\n}\n\nFor this, create a counters collection, which will keep track of the last sequence value for all the sequence fields.\n\n>db.createCollection(\"counters\")\n\nNow, we will insert the following document in the counters collection with productid as its key \u2212\n\n{\n  \"_id\":\"productid\",\n  \"sequence_value\": 0\n}\n\nThe field sequence_value keeps track of the last value of the sequence.\nUse the following code to insert this sequence document in the counters collection \u2212\n\n>db.counters.insert({_id:\"productid\",sequence_value:0})\n\nCreating Javascript Function\nNow, we will create a function getNextSequenceValue which will take the sequence name as its input, increment the sequence number by 1 and return the updated sequence number. In our case, the sequence name is productid.\n\n>function getNextSequenceValue(sequenceName){\n\n   var sequenceDocument = db.counters.findAndModify({\n      query:{_id: sequenceName },\n      update: {$inc:{sequence_value:1}},\n      new:true\n   });\n\t\n   return sequenceDocument.sequence_value;\n}\n\nUsing the Javascript Function\nWe will now use the function getNextSequenceValue while creating a new document and assigning the returned sequence value as document's _id field.\nInsert two sample documents using the following code \u2212\n\n>db.products.insert({\n   \"_id\":getNextSequenceValue(\"productid\"),\n   \"product_name\":\"Apple iPhone\",\n   \"category\":\"mobiles\"\n})\n\n>db.products.insert({\n   \"_id\":getNextSequenceValue(\"productid\"),\n   \"product_name\":\"Samsung S3\",\n   \"category\":\"mobiles\"\n})\n\nAs you can see, we have used the getNextSequenceValue function to set value for the _id field.\nTo verify the functionality, let us fetch the documents using find command \u2212\n\n>db.products.find()\n\nThe above query returned the following documents having the auto-incremented _id field \u2212\n\n{ \"_id\" : 1, \"product_name\" : \"Apple iPhone\", \"category\" : \"mobiles\"}\n\n{ \"_id\" : 2, \"product_name\" : \"Samsung S3\", \"category\" : \"mobiles\" }\n\n\n\n Previous Page\n\n\n Print\n\n\nNext Page \u00a0\n\n\n\n\nAdvertisements\n<!--\nvar width = 580;\nvar height = 400;\nvar format = \"580x400_as\";\nif( window.innerWidth < 468 ){\n   width = 300;\n   height = 250;\n   format = \"300x250_as\";\n}\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = width;\ngoogle_ad_height = height;\ngoogle_ad_format = format;\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//-->\n\n\n\n", "url": "https://www.tutorialspoint.com/mongodb/mongodb_quick_guide.htm", "html": "<!DOCTYPE html>\n\n<!--[if IE 8]><html class=\"ie ie8\"> <![endif]-->\n<!--[if IE 9]><html class=\"ie ie9\"> <![endif]-->\n<!--[if gt IE 9]><!--> <html> <!--<![endif]-->\n<head>\n<!-- Basic -->\n<meta charset=\"utf-8\"/>\n<title>MongoDB Quick Guide</title>\n<meta content=\"MongoDB Quick Guide - Learn MongoDB in simple and easy steps starting from basic to advanced concepts with examples including what is mongoD?, why and where you should use it?, Environment Setup, creating collection, document.\" name=\"description\">\n<meta content=\"Mongodb, overview, Advantages, Environment, Data Modelling, Create Database, Drop Database, Create Collection, Drop Collection, Data Types, Insert Document, Query Document, Update Document, Delete Document, Projection, Limiting Records, Sorting, Records, Indexing, Aggregration, Replication, Sharding, Create Backup, Deployment, Java, PHP, Relationships, Database References, Covered Queries, Analyzing Queries, Atomic Operations, Advanced Indexing, Indexing Limitations, ObjectId, Map Reduce, Text Search, Regular Expression, Rockmongo, GridFS, Capped Collections, Auto-Increment Sequence.\" name=\"keywords\"/>\n<base href=\"https://www.tutorialspoint.com/\"/>\n<link href=\"/favicon.ico\" rel=\"shortcut icon\" type=\"image/x-icon\"/>\n<meta content=\"width=device-width,initial-scale=1.0,user-scalable=yes\" name=\"viewport\"/>\n<meta content=\"en_US\" property=\"og:locale\">\n<meta content=\"website\" property=\"og:type\"/>\n<meta content=\"471319149685276\" property=\"fb:app_id\"/>\n<meta content=\"www.tutorialspoint.com\" property=\"og:site_name\"/>\n<meta content=\"yes\" name=\"apple-mobile-web-app-capable\"/>\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"/>\n<meta content=\"tutorialspoint.com\" name=\"author\"/>\n<script src=\"https://www.tutorialspoint.com/theme/js/script-min-v4.js?v=2\" type=\"text/javascript\"></script>\n<link href=\"https://www.tutorialspoint.com/theme/css/style-min.css?v=3.1\" rel=\"stylesheet\"/>\n<script>\r\nfunction openNav() {\t\r\n  document.getElementById(\"mySidenav\").style.width = \"250px\";\r\n  document.getElementById(\"right_obs\").style.display = \"block\";\r\n}\r\nfunction closeNav() {\r\n  document.getElementById(\"mySidenav\").style.width = \"0\";\r\n  document.getElementById(\"right_obs\").style.display = \"none\";\r\n}\r\nfunction close_obs_sidenav(){\r\n  document.getElementById(\"mySidenav\").style.width = \"0\";\r\n  document.getElementById(\"right_obs\").style.display = \"none\";\r\n}\r\n</script>\n<!-- Head Libs -->\n<!--[if IE 8]>\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/theme/css/ie8.css\">\r\n<![endif]-->\n<style>\r\n#privacy-banner {\r\n    position: fixed;\r\n    bottom: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    max-width: 100%;\r\n    padding: 1rem .5rem;\r\n    background: #fff;\r\n    z-index: 1030;\r\n    color: #000;\r\n    font-size: 14px;\r\n    margin: 0;\r\n    display: none;\r\n    border-top: 2px solid rgb(130, 130, 130);\r\n  }\r\n  #privacy-banner p {\r\n    margin: 0;\r\n    color: #000;\r\n    text-align: center;\r\n  }\r\n  #privacy-banner a {\r\n    text-decoration: none;\r\n    margin: 20px auto 0 auto;\r\n    display: block;\r\n    max-width: 150px;\r\n  }\r\n  #privacy-banner a:hover {\r\n    text-decoration: underline;\r\n  }\r\n  #banner-learn {\r\n    color: #000;\r\n  }\r\n  #banner-accept {\r\n    padding: 7px 15px;\r\n    color: #fff;\r\n    border-radius: 5px;\r\n    background:#737373 !important;\r\n  }\r\n  @media (min-width: 768px) {\r\n    #privacy-banner {\r\n      padding: 1.5rem .5rem;\r\n    }\r\n    #privacy-banner a {\r\n      display: inline-block;\r\n      margin: 0 10px;\r\n    }\r\n}\r\nselect{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }\r\n.btnsbmt{ background: #459e36 !important;}\r\nul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}\r\ndiv.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #459e36 url(/images/pattern.png) repeat center center !important;}\r\n.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #459e36 !important;}\r\n.submenu-item{ border-bottom: 2px solid #459e36 !important; border-top: 2px solid #459e36 !important }\r\n.ace_scroller{overflow: auto!important;}\r\na.demo{font-family: \"Open Sans\",Arial,sans-serif; background:#459e36; color:#fff; font-size:13px; padding:3px 10px; border:1px solid #d6d6d6; position:absolute; right:5px; margin:-6px 17px 0px 0px;}\r\na.demo:hover{opacity:.8}\r\n</style>\n<script>\r\n$(document).ready(function() {\r\n  $('input[name=\"q\"]').keydown(function(event){\r\n    if(event.keyCode == 13) {\r\n      event.preventDefault();\r\n      return false;\r\n    }\r\n  });\r\n});\r\n</script>\n</meta></meta></head>\n<body onload=\"prettyPrint()\">\n<div class=\"wrapLoader\">\n<div class=\"imgLoader\">\n<img alt=\"\" height=\"70\" src=\"/images/loading-cg.gif\" width=\"70\"/>\n</div>\n</div>\n<div class=\"display-none\" id=\"right_obs\" onclick=\"close_obs_sidenav()\"></div>\n<header>\n<div class=\"container\">\n<h1 class=\"logo\">\n<a href=\"index.htm\" title=\"tutorialspoint\">\n<img alt=\"tutorialspoint\" src=\"/mongodb/images/logo.png\"/>\n</a>\n</h1>\n<ul class=\"tp-inline-block pull-right\" id=\"tp-head-icons\">\n<li>\n<div class=\"tp-second-nav tp-display-none tp-pointer\" onclick=\"openNav()\">\n<i class=\"fa fa-th-large fa-lg\"></i>\n</div>\n</li>\n</ul>\n<button class=\"btn btn-responsive-nav btn-inverse\" data-target=\".nav-main-collapse\" data-toggle=\"collapse\" id=\"pull\" style=\"top: 24px!important\"> <i class=\"icon icon-bars\"></i> </button>\n<nav>\n<ul class=\"nav nav-pills nav-top\">\n<li><a href=\"/about/about_careers.htm\" style=\"background: #fffb09; font-weight: bold;\"><i class=\"icon icon-suitcase\"></i> Jobs</a></li>\n<li> <a href=\"/programming_examples/\" target=\"_blank\"><i class=\"fa fa-cubes\"></i> \u00a0Examples</a> </li>\n<li> <a href=\"https://www.tutorialspoint.com/whiteboard.htm\"><img alt=\"Whiteboard\" src=\"theme/css/icons/image-editor.png\" title=\"Whiteboard\"/> \u00a0Whiteboard</a> </li>\n<li> <a href=\"https://www.tutorialspoint.com/netmeeting.php\"><i class=\"fa-camera\"></i> \u00a0Net Meeting</a> </li>\n<li> <a href=\"/online_dev_tools.htm\"> <i class=\"dev-tools-menu\" style=\"opacity:.5\"></i> Tools </a> </li>\n<li> <a href=\"/articles/index.php\"><i class=\"icon icon-file-text-o\"></i> \u00a0Articles</a> </li>\n<li class=\"top-icons\">\n<ul class=\"social-icons\">\n<li class=\"facebook\"><a data-placement=\"bottom\" href=\"https://www.facebook.com/tutorialspointindia\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Facebook\">Facebook</a></li>\n<li class=\"googleplus\"><a data-placement=\"bottom\" href=\"https://plus.google.com/u/0/116678774017490391259/posts\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Google+\">Google+</a></li>\n<li class=\"twitter\"><a data-placement=\"bottom\" href=\"https://www.twitter.com/tutorialspoint\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Twitter\">Twitter</a></li>\n<li class=\"linkedin\"><a data-placement=\"bottom\" href=\"https://www.linkedin.com/company/tutorialspoint\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Linkedin\">Linkedin</a></li>\n<li class=\"youtube\"><a data-placement=\"bottom\" href=\"https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint YouTube\">YouTube</a></li>\n</ul>\n</li>\n</ul>\n</nav>\n</div>\n<div class=\"sidenav\" id=\"mySidenav\">\n<div class=\"navbar nav-main\">\n<div class=\"container\">\n<nav class=\"nav-main mega-menu\">\n<ul class=\"nav nav-pills nav-main\" id=\"mainMenu\">\n<li class=\"dropdown no-sub-menu\"> <a class=\"dropdown\" href=\"index.htm\"><i class=\"icon icon-home\"></i> Home</a> </li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"/questions/index.php\"><i class=\"fa fa-send\"></i> Q/A </a> </li>\n<li class=\"dropdown\"><a class=\"dropdown\" href=\"tutorialslibrary.htm\"><span class=\"tut-lib\"> Library </span></a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"videotutorials/index.htm\"><i class=\"fa-toggle-right\"></i> Videos </a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"tutor_connect/index.php\"><i class=\"fa-user\"> </i> Tutors</a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"codingground.htm\"><i class=\"fa-code\"></i> Coding Ground </a> </li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"https://store.tutorialspoint.com/\"><i class=\"fa-usd\"></i> Store </a> </li>\n<li class=\"dropdown no-sub-menu\">\n<div class=\"searchform-popup\">\n<input autocomplete=\"off\" class=\"header-search-box\" id=\"search-string\" name=\"q\" onblur=\"if (this.value == '') {this.value = 'Search your favorite tutorials...';}\" onfocus=\"if (this.value == 'Search your favorite tutorials...') {this.value = '';}\" placeholder=\"Search your favorite tutorials...\" type=\"text\"/>\n<div class=\"magnifying-glass\"><i class=\"icon-search\"></i> Search </div>\n</div>\n</li>\n</ul>\n</nav>\n</div>\n</div>\n</div>\n</header></body></html>\n\n<div style=\"clear:both;\"></div>\n<div class=\"main\" role=\"main\">\n<div class=\"container\">\n<div class=\"row\">\n<div class=\"col-md-2\">\n<aside class=\"sidebar\">\n<div class=\"mini-logo\">\n<img alt=\"MongoDB Tutorial\" src=\"/mongodb/images/mongodb-mini-logo.jpg\">\n</img></div>\n<ul class=\"nav nav-list primary left-menu\">\n<li class=\"heading\">MongoDB Tutorial</li>\n<li><a href=\"/mongodb/index.htm\">MongoDB - Home</a></li>\n<li><a href=\"/mongodb/mongodb_overview.htm\">MongoDB - Overview</a></li>\n<li><a href=\"/mongodb/mongodb_advantages.htm\">MongoDB - Advantages</a></li>\n<li><a href=\"/mongodb/mongodb_environment.htm\">MongoDB - Environment</a></li>\n<li><a href=\"/mongodb/mongodb_data_modeling.htm\">MongoDB - Data Modeling</a></li>\n<li><a href=\"/mongodb/mongodb_create_database.htm\">MongoDB - Create Database</a></li>\n<li><a href=\"/mongodb/mongodb_drop_database.htm\">MongoDB - Drop Database</a></li>\n<li><a href=\"/mongodb/mongodb_create_collection.htm\">MongoDB - Create Collection</a></li>\n<li><a href=\"/mongodb/mongodb_drop_collection.htm\">MongoDB - Drop Collection</a></li>\n<li><a href=\"/mongodb/mongodb_datatype.htm\">MongoDB - Data Types</a></li>\n<li><a href=\"/mongodb/mongodb_insert_document.htm\">MongoDB - Insert Document</a></li>\n<li><a href=\"/mongodb/mongodb_query_document.htm\">MongoDB - Query Document</a></li>\n<li><a href=\"/mongodb/mongodb_update_document.htm\">MongoDB - Update Document</a></li>\n<li><a href=\"/mongodb/mongodb_delete_document.htm\">MongoDB - Delete Document</a></li>\n<li><a href=\"/mongodb/mongodb_projection.htm\">MongoDB - Projection</a></li>\n<li><a href=\"/mongodb/mongodb_limit_record.htm\">MongoDB - Limiting Records</a></li>\n<li><a href=\"/mongodb/mongodb_sort_record.htm\">MongoDB - Sorting Records</a></li>\n<li><a href=\"/mongodb/mongodb_indexing.htm\">MongoDB - Indexing</a></li>\n<li><a href=\"/mongodb/mongodb_aggregation.htm\">MongoDB - Aggregation</a></li>\n<li><a href=\"/mongodb/mongodb_replication.htm\">MongoDB - Replication</a></li>\n<li><a href=\"/mongodb/mongodb_sharding.htm\">MongoDB - Sharding</a></li>\n<li><a href=\"/mongodb/mongodb_create_backup.htm\">MongoDB - Create Backup</a></li>\n<li><a href=\"/mongodb/mongodb_deployment.htm\">MongoDB - Deployment</a></li>\n<li><a href=\"/mongodb/mongodb_java.htm\">MongoDB - Java</a></li>\n<li><a href=\"/mongodb/mongodb_php.htm\">MongoDB - PHP</a></li>\n</ul>\n<ul class=\"nav nav-list primary left-menu\">\n<li class=\"heading\">Advanced MongoDB</li>\n<li><a href=\"/mongodb/mongodb_relationships.htm\">MongoDB - Relationships</a></li>\n<li><a href=\"/mongodb/mongodb_database_references.htm\">MongoDB - Database References</a></li>\n<li><a href=\"/mongodb/mongodb_covered_queries.htm\">MongoDB - Covered Queries</a></li>\n<li><a href=\"/mongodb/mongodb_analyzing_queries.htm\">MongoDB - Analyzing Queries</a></li>\n<li><a href=\"/mongodb/mongodb_atomic_operations.htm\">MongoDB - Atomic Operations</a></li>\n<li><a href=\"/mongodb/mongodb_advanced_indexing.htm\">MongoDB - Advanced Indexing</a></li>\n<li><a href=\"/mongodb/mongodb_indexing_limitations.htm\">MongoDB - Indexing Limitations</a></li>\n<li><a href=\"/mongodb/mongodb_objectid.htm\">MongoDB - ObjectId</a></li>\n<li><a href=\"/mongodb/mongodb_map_reduce.htm\">MongoDB - Map Reduce</a></li>\n<li><a href=\"/mongodb/mongodb_text_search.htm\">MongoDB - Text Search</a></li>\n<li><a href=\"/mongodb/mongodb_regular_expression.htm\">MongoDB - Regular Expression</a></li>\n<li><a href=\"/mongodb/working_with_rockmongo.htm\">Working with Rockmongo</a></li>\n<li><a href=\"/mongodb/mongodb_gridfs.htm\">MongoDB - GridFS</a></li>\n<li><a href=\"/mongodb/mongodb_capped_collections.htm\">MongoDB - Capped Collections</a></li>\n<li><a href=\"/mongodb/mongodb_autoincrement_sequence.htm\">Auto-Increment Sequence</a></li>\n</ul>\n<ul class=\"nav nav-list primary left-menu\">\n<li class=\"heading\">MongoDB Useful Resources</li>\n<li><a href=\"/mongodb/mongodb_questions_answers.htm\">MongoDB - Questions and Answers</a></li>\n<li><a href=\"/mongodb/mongodb_quick_guide.htm\">MongoDB - Quick Guide</a></li>\n<li><a href=\"/mongodb/mongodb_useful_resources.htm\">MongoDB - Useful Resources</a></li>\n<li><a href=\"/mongodb/mongodb_discussion.htm\">MongoDB - Discussion</a></li>\n</ul>\n<ul class=\"nav nav-list primary push-bottom left-menu special\">\n<li class=\"sreading\">Selected Reading</li>\n<li><a href=\"/upsc_ias_exams.htm\" target=\"_top\">UPSC IAS Exams Notes</a></li>\n<li><a href=\"/developers_best_practices/index.htm\" target=\"_top\">Developer's Best Practices</a></li>\n<li><a href=\"/questions_and_answers.htm\" target=\"_top\">Questions and Answers</a></li>\n<li><a href=\"/effective_resume_writing.htm\" target=\"_top\">Effective Resume Writing</a></li>\n<li><a href=\"/hr_interview_questions/index.htm\" target=\"_top\">HR Interview Questions</a></li>\n<li><a href=\"/computer_glossary.htm\" target=\"_top\">Computer Glossary</a></li>\n<li><a href=\"/computer_whoiswho.htm\" target=\"_top\">Who is Who</a></li>\n</ul>\n</aside>\n</div>\n<!-- PRINTING STARTS HERE -->\n<div class=\"row\">\n<div class=\"content\">\n<div class=\"col-md-7 middle-col\">\n<h1>MongoDB - Quick Guide</h1>\n<hr/>\n<div style=\"padding-bottom:5px;padding-left:10px;text-align: center;\">Advertisements</div>\n<div style=\"text-align: center;\">\n<script type=\"text/javascript\"><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\" type=\"text/javascript\">\n</script>\n</div>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/mongodb/mongodb_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/mongodb/mongodb_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<div class=\"clearer\"></div>\n<hr/>\n<h1>MongoDB - Overview</h1>\n<p>MongoDB is a cross-platform, document oriented database that provides, high performance, high availability, and easy scalability. MongoDB works on concept of collection and document.</p>\n<h2>Database</h2>\n<p>Database is a physical container for collections. Each database gets its own set of files on the file system. A single MongoDB server typically has multiple databases.</p>\n<h2>Collection</h2>\n<p>Collection is a group of MongoDB documents. It is the equivalent of an RDBMS table. A collection exists within a single database. Collections do not enforce a schema. Documents within a collection can have different fields. Typically, all documents in a collection are of similar or related purpose.</p>\n<h2>Document</h2>\n<p>A document is a set of key-value pairs. Documents have dynamic schema. Dynamic schema means that documents in the same collection do not need to have the same set of fields or structure, and common fields in a collection's documents may hold different types of data.</p>\n<p>The following table shows the relationship of RDBMS terminology with MongoDB.</p>\n<table class=\"table table-bordered\" style=\"text-align:center;\">\n<tr>\n<th style=\"text-align:center;width:50%;\">RDBMS</th>\n<th style=\"text-align:center;\">MongoDB</th>\n</tr>\n<tr>\n<td>Database</td>\n<td>Database</td>\n</tr>\n<tr>\n<td>Table</td>\n<td>Collection</td>\n</tr>\n<tr>\n<td>Tuple/Row</td>\n<td>Document</td>\n</tr>\n<tr>\n<td>column</td>\n<td>Field</td>\n</tr>\n<tr>\n<td>Table Join</td>\n<td>Embedded Documents</td>\n</tr>\n<tr>\n<td>Primary Key</td>\n<td>Primary Key (Default key _id provided by mongodb itself)</td>\n</tr>\n<tr>\n<th colspan=\"2\" style=\"text-align:center;\">Database Server and Client</th>\n</tr>\n<tr>\n<td>Mysqld/Oracle</td>\n<td>mongod</td>\n</tr>\n<tr>\n<td>mysql/sqlplus</td>\n<td>mongo</td>\n</tr>\n</table>\n<h2>Sample Document</h2>\n<p>Following example shows the document structure of a blog site, which is simply a comma separated key value pair.</p>\n<pre class=\"prettyprint notranslate\">\n{\n   _id: ObjectId(7df78ad8902c)\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100, \n   comments: [\t\n      {\n         user:'user1',\n         message: 'My first comment',\n         dateCreated: new Date(2011,1,20,2,15),\n         like: 0 \n      },\n      {\n         user:'user2',\n         message: 'My second comments',\n         dateCreated: new Date(2011,1,25,7,45),\n         like: 5\n      }\n   ]\n}\n</pre>\n<p><b>_id</b> is a 12 bytes hexadecimal number which assures the uniqueness of every document. You can provide _id while inserting the document. If you don\u2019t provide then MongoDB provides a unique id for every document. These 12 bytes first 4 bytes for the current timestamp, next 3 bytes for machine id, next 2 bytes for process id of MongoDB server and remaining 3 bytes are simple incremental VALUE.</p>\n<h1>MongoDB - Advantages</h1>\n<p>Any relational database has a typical schema design that shows number of tables and the relationship between these tables. While in MongoDB, there is no concept of relationship.</p>\n<h2>Advantages of MongoDB over RDBMS</h2>\n<ul class=\"list\">\n<li><p><b>Schema less</b> \u2212 MongoDB is a document database in which one collection holds different documents. Number of fields, content and size of the document can differ from one document to another.</p></li>\n<li><p>Structure of a single object is clear.</p></li>\n<li><p>No complex joins.</p></li>\n<li><p>Deep query-ability. MongoDB supports dynamic queries on documents using a document-based query language that's nearly as powerful as SQL.</p></li>\n<li><p>Tuning.</p></li>\n<li><p><b>Ease of scale-out</b> \u2212 MongoDB is easy to scale.</p></li>\n<li><p>Conversion/mapping of application objects to database objects not needed.</p></li>\n<li><p>Uses internal memory for storing the (windowed) working set, enabling faster access of data.</p></li>\n</ul>\n<h2>Why Use MongoDB?</h2>\n<ul class=\"list\">\n<li><p><b>Document Oriented Storage</b> \u2212 Data is stored in the form of JSON style documents.</p></li>\n<li><p>Index on any attribute</p></li>\n<li><p>Replication and high availability</p></li>\n<li><p>Auto-sharding</p></li>\n<li><p>Rich queries</p></li>\n<li><p>Fast in-place updates</p></li>\n<li><p>Professional support by MongoDB</p></li>\n</ul>\n<h2>Where to Use MongoDB?</h2>\n<ul class=\"list\">\n<li>Big Data</li>\n<li>Content Management and Delivery</li>\n<li>Mobile and Social Infrastructure</li>\n<li>User Data Management</li>\n<li>Data Hub</li>\n</ul>\n<h1>MongoDB - Environment</h1>\n<p>Let us now see how to install MongoDB on Windows.</p>\n<h2>Install MongoDB On Windows</h2>\n<p>To install MongoDB on Windows, first download the latest release of MongoDB from <a href=\"https://www.mongodb.org/downloads\" rel=\"nofollow\" target=\"_blank\">https://www.mongodb.org/downloads</a>. Make sure you get correct version of MongoDB depending upon your Windows version. To get your Windows version, open command prompt and execute the following command.</p>\n<pre class=\"result notranslate\">\nC:\\&gt;wmic os get osarchitecture\nOSArchitecture\n64-bit\nC:\\&gt;\n</pre>\n<p>32-bit versions of MongoDB only support databases smaller than 2GB and suitable only for testing and evaluation purposes.</p>\n<p>Now extract your downloaded file to c:\\ drive or any other location. Make sure the name of the extracted folder is mongodb-win32-i386-[version] or mongodb-win32-x86_64-[version]. Here [version] is the version of MongoDB download.</p>\n<p>Next, open the command prompt and run the following command.</p>\n<pre class=\"result notranslate\">\nC:\\&gt;move mongodb-win64-* mongodb\n   1 dir(s) moved.\nC:\\&gt;\n</pre>\n<p>In case you have extracted the MongoDB at different location, then go to that path by using command <b>cd FOLDER/DIR</b> and now run the above given process.</p>\n<p>MongoDB requires a data folder to store its files. The default location for the MongoDB data directory is c:\\data\\db. So you need to create this folder using the Command Prompt. Execute the following command sequence.</p>\n<pre class=\"result notranslate\">\nC:\\&gt;md data\nC:\\md data\\db\n</pre>\n<p>If you have to install the MongoDB at a different location, then you need to specify an alternate path for <b>\\data\\db</b> by setting the path <b>dbpath</b> in <b>mongod.exe</b>. For the same, issue the following commands.</p>\n<p>In the command prompt, navigate to the bin directory present in the MongoDB installation folder. Suppose my installation folder is <b>D:\\set up\\mongodb</b></p>\n<pre class=\"result notranslate\">\nC:\\Users\\XYZ&gt;d:\nD:\\&gt;cd \"set up\"\nD:\\set up&gt;cd mongodb\nD:\\set up\\mongodb&gt;cd bin\nD:\\set up\\mongodb\\bin&gt;mongod.exe --dbpath \"d:\\set up\\mongodb\\data\" \n</pre>\n<p>This will show <b>waiting for connections</b> message on the console output, which indicates that the mongod.exe process is running successfully.</p>\n<p>Now to run the MongoDB, you need to open another command prompt and issue the following command.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongo.exe\nMongoDB shell version: 2.4.6\nconnecting to: test\n&gt;db.test.save( { a: 1 } )\n&gt;db.test.find()\n{ \"_id\" : ObjectId(5879b0f65a56a454), \"a\" : 1 }\n&gt;\n</pre>\n<p>This will show that MongoDB is installed and run successfully. Next time when you run MongoDB, you need to issue only commands.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongod.exe --dbpath \"d:\\set up\\mongodb\\data\" \nD:\\set up\\mongodb\\bin&gt;mongo.exe\n</pre>\n<h2>Install MongoDB on Ubuntu</h2>\n<p>Run the following command to import the MongoDB public GPG key \u2212</p>\n<pre class=\"result notranslate\">\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10\n</pre>\n<p>Create a /etc/apt/sources.list.d/mongodb.list file using the following command.</p>\n<pre class=\"result notranslate\">\necho 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' \n   | sudo tee /etc/apt/sources.list.d/mongodb.list\n</pre>\n<p>Now issue the following command to update the repository \u2212</p>\n<pre class=\"result notranslate\">\nsudo apt-get update\n</pre>\n<p>Next install the MongoDB by using the following command \u2212</p>\n<pre class=\"result notranslate\">\napt-get install mongodb-10gen = 2.2.3\n</pre>\n<p>In the above installation, 2.2.3 is currently released MongoDB version. Make sure to install the latest version always. Now MongoDB is installed successfully.</p>\n<h2>Start MongoDB</h2>\n<pre class=\"result notranslate\">\nsudo service mongodb start\n</pre>\n<h2>Stop MongoDB</h2>\n<pre class=\"result notranslate\">\nsudo service mongodb stop\n</pre>\n<h2>Restart MongoDB</h2>\n<pre class=\"result notranslate\">\nsudo service mongodb restart\n</pre>\n<p>To use MongoDB run the following command.</p>\n<pre class=\"result notranslate\">\nmongo\n</pre>\n<p>This will connect you to running MongoDB instance.</p>\n<h2>MongoDB Help</h2>\n<p>To get a list of commands, type <b>db.help()</b> in MongoDB client. This will give you a list of commands as shown in the following screenshot.</p>\n<img alt=\"DB Help\" src=\"/mongodb/images/db_help.png\">\n<h2>MongoDB Statistics</h2>\n<p>To get stats about MongoDB server, type the command <b>db.stats()</b> in MongoDB client. This will show the database name, number of collection and documents in the database. Output of the command is shown in the following screenshot.</p>\n<img alt=\"DB Stats\" src=\"/mongodb/images/db_stats.png\"/>\n<h1>MongoDB - Data Modelling</h1>\n<p>Data in MongoDB has a flexible schema.documents in the same collection. They do not need to have the same set of fields or structure, and common fields in a collection\u2019s documents may hold different types of data.</p>\n<h2 style=\"font-size:22px;\">Some considerations while designing Schema in MongoDB</h2>\n<ul class=\"list\">\n<li><p>Design your schema according to user requirements.</p></li>\n<li><p>Combine objects into one document if you will use them together. Otherwise separate them (but make sure there should not be need of joins).</p></li>\n<li><p>Duplicate the data (but limited) because disk space is cheap as compare to compute time.</p></li>\n<li><p>Do joins while write, not on read.</p></li>\n<li><p>Optimize your schema for most frequent use cases.</p></li>\n<li><p>Do complex aggregation in the schema.</p></li>\n</ul>\n<h2>Example</h2>\n<p>Suppose a client needs a database design for his blog/website and see the differences between RDBMS and MongoDB schema design. Website has the following requirements.</p>\n<ul class=\"list\">\n<li>Every post has the unique title, description and url.</li>\n<li>Every post can have one or more tags.</li>\n<li>Every post has the name of its publisher and total number of likes.</li>\n<li>Every post has comments given by users along with their name, message, data-time and likes.</li>\n<li>On each post, there can be zero or more comments.</li>\n</ul>\n<p>In RDBMS schema, design for above requirements will have minimum three tables.</p>\n<img alt=\"RDBMS Schema Design\" src=\"/mongodb/images/rdbms.png\"/>\n<p>While in MongoDB schema, design will have one collection post and the following structure \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   _id: POST_ID\n   title: TITLE_OF_POST, \n   description: POST_DESCRIPTION,\n   by: POST_BY,\n   url: URL_OF_POST,\n   tags: [TAG1, TAG2, TAG3],\n   likes: TOTAL_LIKES, \n   comments: [\t\n      {\n         user:'COMMENT_BY',\n         message: TEXT,\n         dateCreated: DATE_TIME,\n         like: LIKES \n      },\n      {\n         user:'COMMENT_BY',\n         message: TEXT,\n         dateCreated: DATE_TIME,\n         like: LIKES\n      }\n   ]\n}\n</pre>\n<p>So while showing the data, in RDBMS you need to join three tables and in MongoDB, data will be shown from one collection only.</p>\n<h1>MongoDB - Create Database</h1>\n<p>In this chapter, we will see how to create a database in MongoDB.</p>\n<h2>The use Command</h2>\n<p>MongoDB <b>use DATABASE_NAME</b> is used to create database. The command will create a new database if it doesn't exist, otherwise it will return the existing database.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>use DATABASE</b> statement is as follows \u2212</p>\n<pre class=\"result notranslate\">\nuse DATABASE_NAME\n</pre>\n<h3>Example</h3>\n<p>If you want to use a database with name <b>&lt;mydb&gt;</b>, then <b>use DATABASE</b> statement would be as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;use mydb\nswitched to db mydb\n</pre>\n<p>To check your currently selected database, use the command <b>db</b></p>\n<pre class=\"result notranslate\">\n&gt;db\nmydb\n</pre>\n<p>If you want to check your databases list, use the command <b>show dbs</b>.</p>\n<pre class=\"result notranslate\">\n&gt;show dbs\nlocal     0.78125GB\ntest      0.23012GB\n</pre>\n<p>Your created database (mydb) is not present in list. To display database, you need to insert at least one document into it.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.movie.insert({\"name\":\"tutorials point\"})\n&gt;show dbs\nlocal      0.78125GB\nmydb       0.23012GB\ntest       0.23012GB\n</pre>\n<p>In MongoDB default database is test. If you didn't create any database, then collections will be stored in test database.</p>\n<h1>MongoDB - Drop Database</h1>\n<p>In this chapter, we will see how to drop a database using MongoDB command.</p>\n<h2>The dropDatabase() Method</h2>\n<p>MongoDB <b>db.dropDatabase()</b> command is used to drop a existing database.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>dropDatabase()</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\ndb.dropDatabase()\n</pre>\n<p>This will delete the selected database. If you have not selected any database, then it will delete default 'test' database.</p>\n<h3>Example</h3>\n<p>First, check the list of available databases by using the command, <b>show dbs</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;show dbs\nlocal      0.78125GB\nmydb       0.23012GB\ntest       0.23012GB\n&gt;\n</pre>\n<p>If you want to delete new database <b>&lt;mydb&gt;</b>, then <b>dropDatabase()</b> command would be as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;use mydb\nswitched to db mydb\n&gt;db.dropDatabase()\n&gt;{ \"dropped\" : \"mydb\", \"ok\" : 1 }\n&gt;\n</pre>\n<p>Now check list of databases.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;show dbs\nlocal      0.78125GB\ntest       0.23012GB\n&gt;\n</pre>\n<h1>MongoDB - Create Collection</h1>\n<p>In this chapter, we will see how to create a collection using MongoDB.</p>\n<h2>The createCollection() Method</h2>\n<p>MongoDB <b>db.createCollection(name, options)</b> is used to create collection.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>createCollection()</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\ndb.createCollection(name, options)\n</pre>\n<p>In the command, <b>name</b> is name of collection to be created. <b>Options</b> is a document and is used to specify configuration of collection.</p>\n<table class=\"table table-bordered\" style=\"text-align:center;\">\n<tr>\n<th style=\"width:25%;text-align:center;\">Parameter</th>\n<th style=\"width:25%;text-align:center;\">Type</th>\n<th style=\"text-align:center;\">Description</th>\n</tr>\n<tr>\n<td>Name</td>\n<td>String</td>\n<td>Name of the collection to be created</td>\n</tr>\n<tr>\n<td>Options</td>\n<td>Document</td>\n<td>(Optional) Specify options about memory size and indexing</td>\n</tr>\n</table>\n<p>Options parameter is optional, so you need to specify only the name of the collection. Following is the list of options you can use \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:15%;text-align:center;\">Field</th>\n<th style=\"width:15%;text-align:center;\">Type</th>\n<th style=\"text-align:center;\">Description</th></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">capped</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>(Optional) If true, enables a capped collection. Capped collection is a fixed size collection that automatically overwrites its oldest entries when it reaches its maximum size. <b>If you specify true, you need to specify size parameter also.</b></td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">autoIndexId</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>(Optional) If true, automatically create index on _id field.s Default value is false.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">size</td>\n<td style=\"text-align:center;vertical-align:middle;\">number</td>\n<td>(Optional) Specifies a maximum size in bytes for a capped collection. <b>If capped is true, then you need to specify this field also.</b></td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">max</td>\n<td style=\"text-align:center;vertical-align:middle;\">number</td>\n<td>(Optional) Specifies the maximum number of documents allowed in the capped collection.</td>\n</tr>\n</table>\n<p>While inserting the document, MongoDB first checks size field of capped collection, then it checks max field.</p>\n<h3>Examples</h3>\n<p>Basic syntax of <b>createCollection()</b> method without options is as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;use test\nswitched to db test\n&gt;db.createCollection(\"mycollection\")\n{ \"ok\" : 1 }\n&gt;\n</pre>\n<p>You can check the created collection by using the command <b>show collections</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;show collections\nmycollection\nsystem.indexes\n</pre>\n<p>The following example shows the syntax of <b>createCollection()</b> method with few important options \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.createCollection(\"mycol\", { capped : true, autoIndexId : true, size : \n   6142800, max : 10000 } )\n{ \"ok\" : 1 }\n&gt;\n</pre>\n<p>In MongoDB, you don't need to create collection. MongoDB creates collection automatically, when you insert some document.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.tutorialspoint.insert({\"name\" : \"tutorialspoint\"})\n&gt;show collections\nmycol\nmycollection\nsystem.indexes\ntutorialspoint\n&gt;\n</pre>\n<h1>MongoDB - Drop Collection</h1>\n<p>In this chapter, we will see how to drop a collection using MongoDB.</p>\n<h2>The drop() Method</h2>\n<p>MongoDB's <b>db.collection.drop()</b> is used to drop a collection from the database.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>drop()</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\ndb.COLLECTION_NAME.drop()\n</pre>\n<h3>Example</h3>\n<p>First, check the available collections into your database <b>mydb</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;use mydb\nswitched to db mydb\n&gt;show collections\nmycol\nmycollection\nsystem.indexes\ntutorialspoint\n&gt;\n</pre>\n<p>Now drop the collection with the name <b>mycollection</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycollection.drop()\ntrue\n&gt;\n</pre>\n<p>Again check the list of collections into database.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;show collections\nmycol\nsystem.indexes\ntutorialspoint\n&gt;\n</pre>\n<p>drop() method will return true, if the selected collection is dropped successfully, otherwise it will return false.</p>\n<h1>MongoDB - Datatypes</h1>\n<p>MongoDB supports many datatypes. Some of them are \u2212</p>\n<ul class=\"list\">\n<li><p><b>String</b> \u2212 This is the most commonly used datatype to store the data. String in MongoDB must be UTF-8 valid.</p></li>\n<li><p><b>Integer</b> \u2212 This type is used to store a numerical value. Integer can be 32 bit or 64 bit depending upon your server.</p></li>\n<li><p><b>Boolean</b> \u2212 This type is used to store a boolean (true/ false) value.</p></li>\n<li><p><b>Double</b> \u2212 This type is used to store floating point values.</p></li>\n<li><p><b>Min/ Max keys</b> \u2212 This type is used to compare a value against the lowest and highest BSON elements.</p></li>\n<li><p><b>Arrays</b> \u2212 This type is used to store arrays or list or multiple values into one key.</p></li>\n<li><p><b>Timestamp</b> \u2212 ctimestamp. This can be handy for recording when a document has been modified or added.</p></li>\n<li><p><b>Object</b> \u2212 This datatype is used for embedded documents.</p></li>\n<li><p><b>Null</b> \u2212 This type is used to store a Null value.</p></li>\n<li><p><b>Symbol</b> \u2212 This datatype is used identically to a string; however, it's generally reserved for languages that use a specific symbol type.</p></li>\n<li><p><b>Date </b> \u2212 This datatype is used to store the current date or time in UNIX time format. You can specify your own date time by creating object of Date and passing day, month, year into it.</p></li>\n<li><p><b>Object ID</b> \u2212 This datatype is used to store the document\u2019s ID.</p></li>\n<li><p><b>Binary data</b> \u2212 This datatype is used to store binary data.</p></li>\n<li><p><b>Code</b> \u2212 This datatype is used to store JavaScript code into the document.</p></li>\n<li><p><b>Regular expression</b> \u2212 This datatype is used to store regular expression.</p></li>\n</ul>\n<h1>MongoDB - Insert Document</h1>\n<p>In this chapter, we will learn how to insert document in MongoDB collection.</p>\n<h2>The insert() Method</h2>\n<p>To insert data into MongoDB collection, you need to use MongoDB's <b>insert()</b> or <b>save()</b> method.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>insert()</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.insert(document)\n</pre>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.insert({\n   _id: ObjectId(7df78ad8902c),\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100\n})\n</pre>\n<p>Here <b>mycol</b> is our collection name, as created in the previous chapter. If the collection doesn't exist in the database, then MongoDB will create this collection and then insert a document into it.</p>\n<p>In the inserted document, if we don't specify the _id parameter, then MongoDB assigns a unique ObjectId for this document.</p>\n<p>_id is 12 bytes hexadecimal number unique for every document in a collection. 12 bytes are divided as follows \u2212</p>\n<pre class=\"result notranslate\">\n_id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, \n   3 bytes incrementer)\n</pre>\n<p>To insert multiple documents in a single query, you can pass an array of documents in insert() command.</p>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\n&gt;db.post.insert([\n   {\n      title: 'MongoDB Overview', \n      description: 'MongoDB is no sql database',\n      by: 'tutorials point',\n      url: 'http://www.tutorialspoint.com',\n      tags: ['mongodb', 'database', 'NoSQL'],\n      likes: 100\n   },\n\t\n   {\n      title: 'NoSQL Database', \n      description: \"NoSQL database doesn't have tables\",\n      by: 'tutorials point',\n      url: 'http://www.tutorialspoint.com',\n      tags: ['mongodb', 'database', 'NoSQL'],\n      likes: 20, \n      comments: [\t\n         {\n            user:'user1',\n            message: 'My first comment',\n            dateCreated: new Date(2013,11,10,2,35),\n            like: 0 \n         }\n      ]\n   }\n])\n</pre>\n<p>To insert the document you can use <b>db.post.save(document)</b> also. If you don't specify <b>_id</b> in the document then <b>save()</b> method will work same as <b>insert()</b> method. If you specify _id then it will replace whole data of document containing _id as specified in save() method.</p>\n<h1>MongoDB - Query Document</h1>\n<p>In this chapter, we will learn how to query document from MongoDB collection.</p>\n<h2>The find() Method</h2>\n<p>To query data from MongoDB collection, you need to use MongoDB's <b>find()</b> method.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>find()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.find()\n</pre>\n<p><b>find()</b> method will display all the documents in a non-structured way.</p>\n<h2>The pretty() Method</h2>\n<p>To display the results in a formatted way, you can use <b>pretty()</b> method.</p>\n<h3>Syntax</h3>\n<pre class=\"result notranslate\">\n&gt;db.mycol.find().pretty()\n</pre>\n<h2>Example</h2>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find().pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n&gt;\n</pre>\n<p>Apart from find() method, there is <b>findOne()</b> method, that returns only one document.</p>\n<h2>RDBMS Where Clause Equivalents in MongoDB</h2>\n<p>To query the document on the basis of some condition, you can use following operations.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Operation</th>\n<th style=\"text-align:center;\">Syntax</th>\n<th style=\"text-align:center;\">Example</th>\n<th style=\"width:35%; text-align:center;\">RDBMS Equivalent</th>\n</tr>\n<tr>\n<td>Equality</td>\n<td>{&lt;key&gt;:&lt;value&gt;}</td>\n<td>db.mycol.find({\"by\":\"tutorials point\"}).pretty()</td>\n<td>where by = 'tutorials point'</td>\n</tr>\n<tr>\n<td>Less Than</td>\n<td>{&lt;key&gt;:{$lt:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$lt:50}}).pretty()</td>\n<td>where likes &lt; 50</td>\n</tr>\n<tr>\n<td style=\"width:35%;\">Less Than Equals</td>\n<td>{&lt;key&gt;:{$lte:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$lte:50}}).pretty()</td>\n<td>where likes &lt;= 50</td>\n</tr>\n<tr>\n<td>Greater Than</td>\n<td>{&lt;key&gt;:{$gt:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$gt:50}}).pretty()</td>\n<td>where likes &gt; 50</td>\n</tr>\n<tr>\n<td>Greater Than Equals</td>\n<td>{&lt;key&gt;:{$gte:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$gte:50}}).pretty()</td>\n<td>where likes &gt;= 50</td>\n</tr>\n<tr>\n<td>Not Equals</td>\n<td>{&lt;key&gt;:{$ne:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$ne:50}}).pretty()</td>\n<td>where likes != 50</td>\n</tr>\n</table>\n<h2>AND in MongoDB</h2>\n<h3>Syntax</h3>\n<p>In the <b>find()</b> method, if you pass multiple keys by separating them by ',' then MongoDB treats it as <b>AND</b> condition. Following is the basic syntax of <b>AND</b> \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.mycol.find(\n   {\n      $and: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n</pre>\n<h3>Example</h3>\n<p>Following example will show all the tutorials written by 'tutorials point' and whose title is 'MongoDB Overview'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({$and:[{\"by\":\"tutorials point\"},{\"title\": \"MongoDB Overview\"}]}).pretty() {\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n</pre>\n<p>For the above given example, equivalent where clause will be <b>' where by = 'tutorials point' AND title = 'MongoDB Overview' '</b>. You can pass any number of key, value pairs in find clause.</p>\n<h2>OR in MongoDB</h2>\n<h3>Syntax</h3>\n<p>To query documents based on the OR condition, you need to use <b>$or</b> keyword. Following is the basic syntax of <b>OR</b> \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n</pre>\n<h3>Example</h3>\n<p>Following example will show all the tutorials written by 'tutorials point' or whose title is 'MongoDB Overview'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({$or:[{\"by\":\"tutorials point\"},{\"title\": \"MongoDB Overview\"}]}).pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n&gt;\n</pre>\n<h2>Using AND and OR Together</h2>\n<h3>Example</h3>\n<p>The following example will show the documents that have likes greater than 10 and whose title is either 'MongoDB Overview' or by is 'tutorials point'. Equivalent SQL where clause is <b>'where likes&gt;10 AND (by = 'tutorials point' OR title = 'MongoDB Overview')'</b></p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({\"likes\": {$gt:10}, $or: [{\"by\": \"tutorials point\"},\n   {\"title\": \"MongoDB Overview\"}]}).pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n&gt;\n</pre>\n<h1>MongoDB - Update Document</h1>\n<p>MongoDB's <b>update()</b> and <b>save()</b> methods are used to update document into a collection. The update() method updates the values in the existing document while the save() method replaces the existing document with the document passed in save() method.</p>\n<h2>MongoDB Update() Method</h2>\n<p>The update() method updates the values in the existing document.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>update()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.update(SELECTION_CRITERIA, UPDATED_DATA)\n</pre>\n<h3>Example</h3>\n<p>Consider the mycol collection has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will set the new title 'New MongoDB Tutorial' of the documents whose title is 'MongoDB Overview'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.update({'title':'MongoDB Overview'},{$set:{'title':'New MongoDB Tutorial'}})\n&gt;db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"New MongoDB Tutorial\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n&gt;\n</pre>\n<p>By default, MongoDB will update only a single document. To update multiple documents, you need to set a parameter 'multi' to true.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.update({'title':'MongoDB Overview'},\n   {$set:{'title':'New MongoDB Tutorial'}},{multi:true})\n</pre>\n<h2>MongoDB Save() Method</h2>\n<p>The <b>save()</b> method replaces the existing document with the new document passed in the save() method.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of MongoDB <b>save()</b> method is shown below \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})\n</pre>\n<h3>Example</h3>\n<p>Following example will replace the document with the _id '5983548781331adf45ec5'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.save(\n   {\n      \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"Tutorials Point New Topic\",\n      \"by\":\"Tutorials Point\"\n   }\n)\n&gt;db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"Tutorials Point New Topic\",\n   \"by\":\"Tutorials Point\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n&gt;\n</pre>\n<h1>MongoDB - Delete Document</h1>\n<p>In this chapter, we will learn how to delete a document using MongoDB.</p>\n<h2>The remove() Method</h2>\n<p>MongoDB's <b>remove()</b> method is used to remove a document from the collection. remove() method accepts two parameters. One is deletion criteria and second is justOne flag.</p>\n<ul class=\"list\">\n<li><p><b>deletion criteria</b> \u2212 (Optional) deletion criteria according to documents will be removed.</p></li>\n<li><p><b>justOne</b> \u2212 (Optional) if set to true or 1, then remove only one document.</p></li>\n</ul>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>remove()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)\n</pre>\n<h3>Example</h3>\n<p>Consider the mycol collection has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will remove all the documents whose title is 'MongoDB Overview'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.remove({'title':'MongoDB Overview'})\n&gt;db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n&gt;\n</pre>\n<h2>Remove Only One</h2>\n<p>If there are multiple records and you want to delete only the first record, then set <b>justOne</b> parameter in <b>remove()</b> method.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\n</pre>\n<h2>Remove All Documents</h2>\n<p>If you don't specify deletion criteria, then MongoDB will delete whole documents from the collection. <b>This is equivalent of SQL's truncate command.</b></p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.remove()\n&gt;db.mycol.find()\n&gt;\n</pre>\n<h1>MongoDB - Projection</h1>\n<p>In MongoDB, projection means selecting only the necessary data rather than selecting whole of the data of a document. If a document has 5 fields and you need to show only 3, then select only 3 fields from them.</p>\n<h2>The find() Method</h2>\n<p>MongoDB's <b>find()</b> method, explained in <a href=\"/mongodb/mongodb_query_document.htm\" rel=\"nofollow\" target=\"_blank\">MongoDB Query Document</a> accepts second optional parameter that is list of fields that you want to retrieve. In MongoDB, when you execute <b>find()</b> method, then it displays all fields of a document. To limit this, you need to set a list of fields with value 1 or 0. 1 is used to show the field while 0 is used to hide the fields.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>find()</b> method with projection is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.find({},{KEY:1})\n</pre>\n<h3>Example</h3>\n<p>Consider the collection mycol has the following data \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will display the title of the document while querying the document.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({},{\"title\":1,_id:0})\n{\"title\":\"MongoDB Overview\"}\n{\"title\":\"NoSQL Overview\"}\n{\"title\":\"Tutorials Point Overview\"}\n&gt;\n</pre>\n<p>Please note <b>_id</b> field is always displayed while executing <b>find()</b> method, if you don't want this field, then you need to set it as 0.</p>\n<h1>MongoDB - Limit Records</h1>\n<p>In this chapter, we will learn how to limit records using MongoDB.</p>\n<h2>The Limit() Method</h2>\n<p>To limit the records in MongoDB, you need to use <b>limit()</b> method. The method accepts one number type argument, which is the number of documents that you want to be displayed.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>limit()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.find().limit(NUMBER)\n</pre>\n<h3>Example</h3>\n<p>Consider the collection myycol has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will display only two documents while querying the document.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({},{\"title\":1,_id:0}).limit(2)\n{\"title\":\"MongoDB Overview\"}\n{\"title\":\"NoSQL Overview\"}\n&gt;\n</pre>\n<p>If you don't specify the number argument in <b>limit()</b> method then it will display all documents from the collection.</p>\n<h2>MongoDB Skip() Method</h2>\n<p>Apart from limit() method, there is one more method <b>skip()</b> which also accepts number type argument and is used to skip the number of documents.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>skip()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n</pre>\n<h3>Example</h3>\n<p>Following example will display only the second document.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({},{\"title\":1,_id:0}).limit(1).skip(1)\n{\"title\":\"NoSQL Overview\"}\n&gt;\n</pre>\n<p>Please note, the default value in <b>skip()</b> method is 0.</p>\n<h1>MongoDB - Sort Records</h1>\n<p>In this chapter, we will learn how to sort records in MongoDB.</p>\n<h2>The sort() Method</h2>\n<p>To sort documents in MongoDB, you need to use <b>sort()</b> method. The method accepts a document containing a list of fields along with their sorting order. To specify sorting order 1 and -1 are used. 1 is used for ascending order while -1 is used for descending order.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>sort()</b> method is as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.COLLECTION_NAME.find().sort({KEY:1})\n</pre>\n<h3>Example</h3>\n<p>Consider the collection myycol has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will display the documents sorted by title in the descending order.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({},{\"title\":1,_id:0}).sort({\"title\":-1})\n{\"title\":\"Tutorials Point Overview\"}\n{\"title\":\"NoSQL Overview\"}\n{\"title\":\"MongoDB Overview\"}\n&gt;\n</pre>\n<p>Please note, if you don't specify the sorting preference, then <b>sort()</b> method will display the documents in ascending order.</p>\n<h1>MongoDB - Indexing</h1>\n<p>Indexes support the efficient resolution of queries. Without indexes, MongoDB must scan every document of a collection to select those documents that match the query statement. This scan is highly inefficient and require MongoDB to process a large volume of data.</p>\n<p>Indexes are special data structures, that store a small portion of the data set in an easy-to-traverse form. The index stores the value of a specific field or set of fields, ordered by the value of the field as specified in the index.</p>\n<h2>The ensureIndex() Method</h2>\n<p>To create an index you need to use ensureIndex() method of MongoDB.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>ensureIndex()</b> method is as follows().</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.COLLECTION_NAME.ensureIndex({KEY:1})\n</pre>\n<p>Here key is the name of the field on which you want to create index and 1 is for ascending order. To create index in descending order you need to use -1.</p>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.ensureIndex({\"title\":1})\n&gt;\n</pre>\n<p>In <b>ensureIndex()</b> method you can pass multiple fields, to create index on multiple fields.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.ensureIndex({\"title\":1,\"description\":-1})\n&gt;\n</pre>\n<p><b>ensureIndex()</b> method also accepts list of options (which are optional). Following is the list \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:10%;text-align:center;\">Parameter</th>\n<th style=\"width:10%;text-align:center;\">Type</th>\n<th style=\"text-align:center;\">Description</th></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">background</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>Builds the index in the background so that building an index does not block other database activities. Specify true to build in the background. The default value is <b>false</b>.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">unique</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>Creates a unique index so that the collection will not accept insertion of documents where the index key or keys match an existing value in the index. Specify true to create a unique index. The default value is <b>false</b>.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">name</td>\n<td style=\"text-align:center;vertical-align:middle;\">string</td>\n<td>The name of the index. If unspecified, MongoDB generates an index name by concatenating the names of the indexed fields and the sort order.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">dropDups</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>Creates a unique index on a field that may have duplicates. MongoDB indexes only the first occurrence of a key and removes all documents from the collection that contain subsequent occurrences of that key. Specify true to create unique index. The default value is <b>false</b>.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">sparse</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>If true, the index only references documents with the specified field. These indexes use less space but behave differently in some situations (particularly sorts). The default value is <b>false</b>.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">expireAfterSeconds</td>\n<td style=\"text-align:center;vertical-align:middle;\">integer</td>\n<td>Specifies a value, in seconds, as a TTL to control how long MongoDB retains documents in this collection.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">v</td>\n<td style=\"text-align:center;vertical-align:middle;\">index version</td>\n<td>The index version number. The default index version depends on the version of MongoDB running when creating the index.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">weights</td>\n<td style=\"text-align:center;vertical-align:middle;\">document</td>\n<td>The weight is a number ranging from 1 to 99,999 and denotes the significance of the field relative to the other indexed fields in terms of the score.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">default_language</td>\n<td style=\"text-align:center;vertical-align:middle;\">string</td>\n<td>For a text index, the language that determines the list of stop words and the rules for the stemmer and tokenizer. The default value is <b>english</b>.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">language_override</td>\n<td style=\"text-align:center;vertical-align:middle;\">string</td>\n<td>For a text index, specify the name of the field in the document that contains, the language to override the default language. The default value is language.</td></tr>\n</table>\n<h1>MongoDB - Aggregation</h1>\n<p>Aggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result. In SQL count(*) and with group by is an equivalent of mongodb aggregation.</p>\n<h2>The aggregate() Method</h2>\n<p>For the aggregation in MongoDB, you should use <b>aggregate()</b> method.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>aggregate()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n</pre>\n<h3>Example</h3>\n<p>In the collection you have the following data \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   _id: ObjectId(7df78ad8902c)\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by_user: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100\n},\n{\n   _id: ObjectId(7df78ad8902d)\n   title: 'NoSQL Overview', \n   description: 'No sql database is very fast',\n   by_user: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 10\n},\n{\n   _id: ObjectId(7df78ad8902e)\n   title: 'Neo4j Overview', \n   description: 'Neo4j is no sql database',\n   by_user: 'Neo4j',\n   url: 'http://www.neo4j.com',\n   tags: ['neo4j', 'database', 'NoSQL'],\n   likes: 750\n},\n</pre>\n<p>Now from the above collection, if you want to display a list stating how many tutorials are written by each user, then you will use the following <b>aggregate()</b> method \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt; db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : 1}}}])\n{\n   \"result\" : [\n      {\n         \"_id\" : \"tutorials point\",\n         \"num_tutorial\" : 2\n      },\n      {\n         \"_id\" : \"Neo4j\",\n         \"num_tutorial\" : 1\n      }\n   ],\n   \"ok\" : 1\n}\n&gt;\n</pre>\n<p>Sql equivalent query for the above use case will be <b>select by_user, count(*) from mycol group by by_user</b>.</p>\n<p>In the above example, we have grouped documents by field <b>by_user</b> and on each occurrence of by_user previous value of sum is incremented. Following is a list of available aggregation expressions.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:10%; text-align:center;\">Expression</th>\n<th style=\"width:50%; text-align:center;\">Description</th>\n<th style=\"text-align:center;\">Example</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$sum</td>\n<td>Sums up the defined value from all documents in the collection.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$avg</td>\n<td>Calculates the average of all given values from all documents in the collection.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$min</td>\n<td>Gets the minimum of the corresponding values from all documents in the collection.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$max</td>\n<td>Gets the maximum of the corresponding values from all documents in the collection.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$push</td>\n<td>Inserts the value to an array in the resulting document.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$addToSet</td>\n<td>Inserts the value to an array in the resulting document but does not create duplicates.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$first</td>\n<td>Gets the first document from the source documents according to the grouping. Typically this makes only sense together with some previously applied \u201c$sort\u201d-stage.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$last</td>\n<td>Gets the last document from the source documents according to the grouping. Typically this makes only sense together with some previously applied \u201c$sort\u201d-stage.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}])</td></tr>\n</table>\n<h2>Pipeline Concept</h2>\n<p>In UNIX command, shell pipeline means the possibility to execute an operation on some input and use the output as the input for the next command and so on. MongoDB also supports same concept in aggregation framework. There is a set of possible stages and each of those is taken as a set of documents as an input and produces a resulting set of documents (or the final resulting JSON document at the end of the pipeline). This can then in turn be used for the next stage and so on.</p>\n<p>Following are the possible stages in aggregation framework \u2212</p>\n<ul class=\"list\">\n<li><p><b>$project</b> \u2212 Used to select some specific fields from a collection.</p></li>\n<li><p><b>$match</b> \u2212 This is a filtering operation and thus this can reduce the amount of documents that are given as input to the next stage.</p></li>\n<li><p><b>$group</b> \u2212 This does the actual aggregation as discussed above.</p></li>\n<li><p><b>$sort</b> \u2212 Sorts the documents.</p></li>\n<li><p><b>$skip</b> \u2212 With this, it is possible to skip forward in the list of documents for a given amount of documents.</p></li>\n<li><p><b>$limit</b> \u2212 This limits the amount of documents to look at, by the given number starting from the current positions.</p></li>\n<li><p><b>$unwind</b> \u2212 This is used to unwind document that are using arrays. When using an array, the data is kind of pre-joined and this operation will be undone with this to have individual documents again. Thus with this stage we will increase the amount of documents for the next stage.</p></li>\n</ul>\n<h1>MongoDB - Replication</h1>\n<p>Replication is the process of synchronizing data across multiple servers. Replication provides redundancy and increases data availability with multiple copies of data on different database servers. Replication protects a database from the loss of a single server. Replication also allows you to recover from hardware failure and service interruptions. With additional copies of the data, you can dedicate one to disaster recovery, reporting, or backup.</p>\n<h2>Why Replication?</h2>\n<ul class=\"list\">\n<li>To keep your data safe</li>\n<li>High (24*7) availability of data</li>\n<li>Disaster recovery</li>\n<li>No downtime for maintenance (like backups, index rebuilds, compaction)</li>\n<li>Read scaling (extra copies to read from)</li>\n<li>Replica set is transparent to the application</li>\n</ul>\n<h2>How Replication Works in MongoDB</h2>\n<p>MongoDB achieves replication by the use of replica set. A replica set is a group of <b>mongod</b> instances that host the same data set. In a replica, one node is primary node that receives all write operations. All other instances, such as secondaries, apply operations from the primary so that they have the same data set. Replica set can have only one primary node.</p>\n<ul class=\"list\">\n<li><p>Replica set is a group of two or more nodes (generally minimum 3 nodes are required).</p></li>\n<li><p>In a replica set, one node is primary node and remaining nodes are secondary.</p></li>\n<li><p>All data replicates from primary to secondary node.</p></li>\n<li><p>At the time of automatic failover or maintenance, election establishes for primary and a new primary node is elected.</p></li>\n<li><p>After the recovery of failed node, it again join the replica set and works as a secondary node.</p></li>\n</ul>\n<p>A typical diagram of MongoDB replication is shown in which client application always interact with the primary node and the primary node then replicates the data to the secondary nodes.</p>\n<img alt=\"MongoDB Replication\" src=\"/mongodb/images/replication.png\"/>\n<h2>Replica Set Features</h2>\n<ul class=\"list\">\n<li>A cluster of N nodes</li>\n<li>Any one node can be primary</li>\n<li>All write operations go to primary</li>\n<li>Automatic failover</li>\n<li>Automatic recovery</li>\n<li>Consensus election of primary</li>\n</ul>\n<h2>Set Up a Replica Set</h2>\n<p>In this tutorial, we will convert standalone MongoDB instance to a replica set. To convert to replica set, following are the steps \u2212</p>\n<ul class=\"list\">\n<li><p>Shutdown already running MongoDB server.</p></li>\n<li>\n<li><p>Start the MongoDB server by specifying -- replSet option. Following is the basic syntax of --replSet \u2212</p></li>\n</li></ul>\n<pre class=\"result notranslate\">\nmongod --port \"PORT\" --dbpath \"YOUR_DB_DATA_PATH\" --replSet \"REPLICA_SET_INSTANCE_NAME\"\n</pre>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\nmongod --port 27017 --dbpath \"D:\\set up\\mongodb\\data\" --replSet rs0\n</pre>\n<ul class=\"list\">\n<li><p>It will start a mongod instance with the name rs0, on port 27017.</p></li>\n<li><p>Now start the command prompt and connect to this mongod instance.</p></li>\n<li><p>In Mongo client, issue the command <b>rs.initiate()</b> to initiate a new replica set.</p></li>\n<li><p>To check the replica set configuration, issue the command <b>rs.conf()</b>. To check the status of replica set issue the command <b>rs.status()</b>.</p></li>\n</ul>\n<h2>Add Members to Replica Set</h2>\n<p>To add members to replica set, start mongod instances on multiple machines. Now start a mongo client and issue a command <b>rs.add()</b>.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>rs.add()</b> command is as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;rs.add(HOST_NAME:PORT)\n</pre>\n<h3>Example</h3>\n<p>Suppose your mongod instance name is <b>mongod1.net</b> and it is running on port <b>27017</b>. To add this instance to replica set, issue the command <b>rs.add()</b> in Mongo client.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;rs.add(\"mongod1.net:27017\")\n&gt;\n</pre>\n<p>You can add mongod instance to replica set only when you are connected to primary node. To check whether you are connected to primary or not, issue the command <b>db.isMaster()</b> in mongo client.</p>\n<h1>MongoDB - Sharding</h1>\n<p>Sharding is the process of storing data records across multiple machines and it is MongoDB's approach to meeting the demands of data growth. As the size of the data increases, a single machine may not be sufficient to store the data nor provide an acceptable read and write throughput. Sharding solves the problem with horizontal scaling. With sharding, you add more machines to support data growth and the demands of read and write operations.</p>\n<h2>Why Sharding?</h2>\n<ul class=\"list\">\n<li>In replication, all writes go to master node</li>\n<li>Latency sensitive queries still go to master</li>\n<li>Single replica set has limitation of 12 nodes</li>\n<li>Memory can't be large enough when active dataset is big</li>\n<li>Local disk is not big enough</li>\n<li>Vertical scaling is too expensive</li>\n</ul>\n<h2>Sharding in MongoDB</h2>\n<p>The following diagram shows the sharding in MongoDB using sharded cluster.</p>\n<img alt=\"MongoDB Sharding\" src=\"/mongodb/images/sharding.png\"/>\n<p>In the following diagram, there are three main components \u2212</p>\n<ul class=\"list\">\n<li><p><b>Shards</b> \u2212 Shards are used to store data. They provide high availability and data consistency. In production environment, each shard is a separate replica set.</p></li>\n<li><p><b>Config Servers</b> \u2212 Config servers store the cluster's metadata. This data contains a mapping of the cluster's data set to the shards. The query router uses this metadata to target operations to specific shards. In production environment, sharded clusters have exactly 3 config servers.</p></li>\n<li><p><b>Query Routers</b> \u2212 Query routers are basically mongo instances, interface with client applications and direct operations to the appropriate shard. The query router processes and targets the operations to shards and then returns results to the clients. A sharded cluster can contain more than one query router to divide the client request load. A client sends requests to one query router. Generally, a sharded cluster have many query routers.</p></li>\n</ul>\n<h1>MongoDB - Create Backup</h1>\n<p>In this chapter, we will see how to create a backup in MongoDB.</p>\n<h2>Dump MongoDB Data</h2>\n<p>To create backup of database in MongoDB, you should use <b>mongodump</b> command. This command will dump the entire data of your server into the dump directory. There are many options available by which you can limit the amount of data or create backup of your remote server.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>mongodump</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;mongodump\n</pre>\n<h3>Example</h3>\n<p>Start your mongod server. Assuming that your mongod server is running on the localhost and port 27017, open a command prompt and go to the bin directory of your mongodb instance and type the command <b>mongodump</b></p>\n<p>Consider the mycol collection has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;mongodump\n</pre>\n<p>The command will connect to the server running at <b>127.0.0.1</b> and port <b>27017</b> and back all data of the server to directory <b>/bin/dump/</b>. Following is the output of the command \u2212</p>\n<img alt=\"DB Stats\" src=\"/mongodb/images/mongodump.png\"/>\n<p>Following is a list of available options that can be used with the <b>mongodump</b> command.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:40%;\">Syntax</th>\n<th style=\"width:30%;\">Description</th>\n<th>Example</th>\n</tr>\n<tr>\n<td>mongodump --host HOST_NAME --port PORT_NUMBER</td>\n<td>This commmand will backup all databases of specified mongod instance.</td>\n<td>mongodump --host tutorialspoint.com --port 27017</td></tr>\n<tr>\n<td>mongodump --dbpath DB_PATH --out BACKUP_DIRECTORY</td>\n<td>This command will backup only specified database at specified path.</td>\n<td>mongodump --dbpath /data/db/ --out /data/backup/</td></tr>\n<tr>\n<td>mongodump --collection COLLECTION --db DB_NAME</td>\n<td>This command will backup only specified collection of specified database.</td>\n<td>mongodump --collection mycol --db test</td></tr>\n</table>\n<h2>Restore data</h2>\n<p>To restore backup data MongoDB's <b>mongorestore</b> command is used. This command restores all of the data from the backup directory.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>mongorestore</b> command is \u2212</p>\n<pre class=\"result notranslate\">\n&gt;mongorestore\n</pre>\n<p>Following is the output of the command \u2212</p>\n<img alt=\"DB Stats\" src=\"/mongodb/images/mongorestore.png\"/>\n<h1>MongoDB - Deployment</h1>\n<p>When you are preparing a MongoDB deployment, you should try to understand how your application is going to hold up in production. It\u2019s a good idea to develop a consistent, repeatable approach to managing your deployment environment so that you can minimize any surprises once you\u2019re in production.</p>\n<p>The best approach incorporates prototyping your set up, conducting load testing, monitoring key metrics, and using that information to scale your set up. The key part of the approach is to proactively monitor your entire system - this will help you understand how your production system will hold up before deploying, and determine where you will need to add capacity. Having insight into potential spikes in your memory usage, for example, could help put out a write-lock fire before it starts.</p>\n<p>To monitor your deployment, MongoDB provides some of the following commands \u2212</p>\n<h2>mongostat</h2>\n<p>This command checks the status of all running mongod instances and return counters of database operations. These counters include inserts, queries, updates, deletes, and cursors. Command also shows when you\u2019re hitting page faults, and showcase your lock percentage. This means that you're running low on memory, hitting write capacity or have some performance issue.</p>\n<p>To run the command, start your mongod instance. In another command prompt, go to <b>bin</b> directory of your mongodb installation and type <b>mongostat</b>.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongostat\n</pre>\n<p>Following is the output of the command \u2212</p>\n<img alt=\"mongostat\" src=\"/mongodb/images/mongostat.png\"/>\n<h2>mongotop</h2>\n<p>This command tracks and reports the read and write activity of MongoDB instance on a collection basis. By default, <b>mongotop</b> returns information in each second, which you can change it accordingly. You should check that this read and write activity matches your application intention, and you\u2019re not firing too many writes to the database at a time, reading too frequently from a disk, or are exceeding your working set size.</p>\n<p>To run the command, start your mongod instance. In another command prompt, go to <b>bin</b> directory of your mongodb installation and type <b>mongotop</b>.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongotop\n</pre>\n<p>Following is the output of the command \u2212</p>\n<img alt=\"mongotop\" src=\"/mongodb/images/mongotop.png\"/>\n<p>To change <b>mongotop</b> command to return information less frequently, specify a specific number after the mongotop command.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongotop 30\n</pre>\n<p>The above example will return values every 30 seconds.</p>\n<p>Apart from the MongoDB tools, 10gen provides a free, hosted monitoring service, MongoDB Management Service (MMS), that provides a dashboard and gives you a view of the metrics from your entire cluster.</p>\n<h1>MongoDB - Java</h1>\n<p>In this chapter, we will learn how to set up MongoDB JDBC driver.</p>\n<h2>Installation</h2>\n<p>Before you start using MongoDB in your Java programs, you need to make sure that you have MongoDB JDBC driver and Java set up on the machine. You can check Java tutorial for Java installation on your machine. Now, let us check how to set up MongoDB JDBC driver.</p>\n<ul class=\"list\">\n<li><p>You need to download the jar from the path <a href=\"https://github.com/mongodb/mongo-java-driver/downloads\" rel=\"nofollow\" target=\"_blank\">Download mongo.jar</a>. Make sure to download the latest release of it.</p></li>\n<li><p>You need to include the mongo.jar into your classpath.</p></li>\n</ul>\n<h2>Connect to Database</h2>\n<p>To connect database, you need to specify the database name, if the database doesn't exist then MongoDB creates it automatically.</p>\n<p>Following is the code snippet to connect to the database \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class ConnectToDB { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n   \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n      System.out.println(\"Credentials ::\"+ credential);     \n   } \n}\n</pre>\n<p>Now, let's compile and run the above program to create our database myDb as shown below.</p>\n<pre class=\"result notranslate\">\n$javac ConnectToDB.java \n$java ConnectToDB\n</pre>\n<p>On executing, the above program gives you the following output.</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCredentials ::MongoCredential{\n   mechanism = null, \n   userName = 'sampleUser', \n   source = 'myDb', \n   password = &lt;hidden&gt;, \n   mechanismProperties = {}\n}\n</pre>\n<h2>Create a Collection</h2>\n<p>To create a collection, <b>createCollection()</b> method of <b>com.mongodb.client.MongoDatabase</b> class is used.</p>\n<p>Following is the code snippet to create a collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class CreatingCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      //Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      //Creating a collection \n      database.createCollection(\"sampleCollection\"); \n      System.out.println(\"Collection created successfully\"); \n   } \n} \n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection created successfully\n</pre>\n<h2>Getting/Selecting a Collection</h2>\n<p>To get/select a collection from the database, <b>getCollection()</b> method of <b>com.mongodb.client.MongoDatabase</b> class is used.</p>\n<p>Following is the program to get/select a collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \n\nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class selectingCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Creating a collection \n      System.out.println(\"Collection created successfully\"); \n\n      // Retieving a collection\n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"myCollection\"); \n      System.out.println(\"Collection myCollection selected successfully\"); \n   }\n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection created successfully \nCollection myCollection selected successfully\n</pre>\n<h2>Insert a Document</h2>\n<p>To insert a document into MongoDB, <b>insert()</b> method of <b>com.mongodb.client.MongoCollection</b> class is used.</p>\n<p>Following is the code snippet to insert a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \n\nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class InsertingDocument { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection\n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\"); \n      System.out.println(\"Collection sampleCollection selected successfully\");\n\n      Document document = new Document(\"title\", \"MongoDB\") \n      .append(\"id\", 1)\n      .append(\"description\", \"database\") \n      .append(\"likes\", 100) \n      .append(\"url\", \"http://www.tutorialspoint.com/mongodb/\") \n      .append(\"by\", \"tutorials point\");  \n      collection.insertOne(document); \n      System.out.println(\"Document inserted successfully\");     \n   } \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection sampleCollection selected successfully \nDocument inserted successfully\n</pre>\n<h2>Retrieve All Documents</h2>\n<p>To select all documents from the collection, <b>find()</b> method of <b>com.mongodb.client.MongoCollection</b> class is used. This method returns a cursor, so you need to iterate this cursor.</p>\n<p>Following is the program to select all documents \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase;  \n\nimport java.util.Iterator; \nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class RetrievingAllDocuments { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential;\n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Retrieving a collection \n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection sampleCollection selected successfully\"); \n\n      // Getting the iterable object \n      FindIterable&lt;Document&gt; iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n    \n      while (it.hasNext()) {  \n         System.out.println(it.next());  \n      i++; \n      }\n   } \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nDocument{{\n   _id = 5967745223993a32646baab8, \n   title = MongoDB, \n   id = 1, \n   description = database, \n   likes = 100, \n   url = http://www.tutorialspoint.com/mongodb/, by = tutorials point\n}}  \nDocument{{\n   _id = 7452239959673a32646baab8, \n   title = RethinkDB, \n   id = 2, \n   description = database, \n   likes = 200, \n   url = http://www.tutorialspoint.com/rethinkdb/, by = tutorials point\n}}\n</pre>\n<h2>Update Document</h2>\n<p>To update a document from the collection, <b>updateOne()</b> method of <b>com.mongodb.client.MongoCollection</b> class is used.</p>\n<p>Following is the program to select the first document \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.client.model.Filters; \nimport com.mongodb.client.model.Updates; \n\nimport java.util.Iterator; \nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class UpdatingDocuments { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection \n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection myCollection selected successfully\"); \n\n      collection.updateOne(Filters.eq(\"id\", 1), Updates.set(\"likes\", 150));       \n      System.out.println(\"Document update successfully...\");  \n      \n      // Retrieving the documents after updation \n      // Getting the iterable object\n      FindIterable&lt;Document&gt; iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n\n      while (it.hasNext()) {  \n         System.out.println(it.next());  \n         i++; \n      }     \n   }  \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nDocument update successfully... \nDocument {{\n   _id = 5967745223993a32646baab8, \n   title = MongoDB, \n   id = 1, \n   description = database, \n   likes = 150, \n   url = http://www.tutorialspoint.com/mongodb/, by = tutorials point\n}}\n</pre>\n<h2>Delete a Document</h2>\n<p>To delete a document from the collection, you need to use the <b>deleteOne()</b> method of the <b>com.mongodb.client.MongoCollection</b> class.</p>\n<p>Following is the program to delete a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.client.model.Filters;  \n\nimport java.util.Iterator; \nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class DeletingDocuments { \n   \n   public static void main( String args[] ) {  \n   \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 );\n      \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection\n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection sampleCollection selected successfully\"); \n\n      // Deleting the documents \n      collection.deleteOne(Filters.eq(\"id\", 1)); \n      System.out.println(\"Document deleted successfully...\");  \n      \n      // Retrieving the documents after updation \n      // Getting the iterable object \n      FindIterable&lt;Document&gt; iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n\n      while (it.hasNext()) {  \n         System.out.println(\"Inserted Document: \"+i);  \n         System.out.println(it.next());  \n         i++; \n      }       \n   } \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection sampleCollection selected successfully \nDocument deleted successfully...\n</pre>\n<h2>Dropping a Collection</h2>\n<p>To drop a collection from a database, you need to use the <b>drop()</b> method of the <b>com.mongodb.client.MongoCollection</b> class.</p>\n<p>Following is the program to delete a collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase;  \n\nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class DropingCollection { \n   \n   public static void main( String args[] ) {  \n\n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Creating a collection \n      System.out.println(\"Collections created successfully\"); \n\n      // Retieving a collection\n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\");\n\n      // Dropping a Collection \n      collection.drop(); \n      System.out.println(\"Collection dropped successfully\");\n   } \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection sampleCollection selected successfully \nCollection dropped successfully\n</pre>\n<h2>Listing All the Collections</h2>\n<p>To list all the collections in a database, you need to use the <b>listCollectionNames()</b>  method of the <b>com.mongodb.client.MongoDatabase</b> class.</p>\n<p>Following is the program to list all the collections of a database \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class ListOfCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n\n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n      System.out.println(\"Collection created successfully\"); \n      for (String name : database.listCollectionNames()) { \n         System.out.println(name); \n      } \n   }\n} \n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection created successfully \nmyCollection \nmyCollection1 \nmyCollection5\n</pre>\n<p>Remaining MongoDB methods <b>save(), limit(), skip(), sort()</b> etc. work same as explained in the subsequent tutorial.</p>\n<h1>MongoDB - PHP</h1>\n<p>To use MongoDB with PHP, you need to use MongoDB PHP driver. Download the driver from the url <a href=\"https://s3.amazonaws.com/drivers.mongodb.org/php/index.html\" rel=\"nofollow\" target=\"_blank\">Download PHP Driver</a>. Make sure to download the latest release of it. Now unzip the archive and put php_mongo.dll in your PHP extension directory (\"ext\" by default) and add the following line to your php.ini file \u2212</p>\n<pre class=\"result notranslate\">\nextension = php_mongo.dll\n</pre>\n<h2>Make a Connection and Select a Database</h2>\n<p>To make a connection, you need to specify the database name, if the database doesn't exist then MongoDB creates it automatically.</p>\n<p>Following is the code snippet to connect to the database \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n\t\n   echo \"Connection to database successfully\";\n   // select a database\n   $db = $m-&gt;mydb;\n\t\n   echo \"Database mydb selected\";\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\n</pre>\n<h2>Create a Collection</h2>\n<p>Following is the code snippet to create a collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;createCollection(\"mycol\");\n   echo \"Collection created succsessfully\";\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection created succsessfully\n</pre>\n<h2>Insert a Document</h2>\n<p>To insert a document into MongoDB, <b>insert()</b> method is used.</p>\n<p>Following is the code snippet to insert a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;mycol;\n   echo \"Collection selected succsessfully\";\n\t\n   $document = array( \n      \"title\" =&gt; \"MongoDB\", \n      \"description\" =&gt; \"database\", \n      \"likes\" =&gt; 100,\n      \"url\" =&gt; \"http://www.tutorialspoint.com/mongodb/\",\n      \"by\" =&gt; \"tutorials point\"\n   );\n\t\n   $collection-&gt;insert($document);\n   echo \"Document inserted successfully\";\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocument inserted successfully\n</pre>\n<h2>Find All Documents</h2>\n<p>To select all documents from the collection, find() method is used.</p>\n<p>Following is the code snippet to select all documents \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;mycol;\n   echo \"Collection selected succsessfully\";\n\n   $cursor = $collection-&gt;find();\n   // iterate cursor to display title of documents\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully {\n   \"title\": \"MongoDB\"\n}\n</pre>\n<h2>Update a Document</h2>\n<p>To update a document, you need to use the update() method.</p>\n<p>In the following example, we will update the title of inserted document to <b>MongoDB Tutorial</b>. Following is the code snippet to update a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;mycol;\n   echo \"Collection selected succsessfully\";\n\n   // now update the document\n   $collection-&gt;update(array(\"title\"=&gt;\"MongoDB\"), \n      array('$set'=&gt;array(\"title\"=&gt;\"MongoDB Tutorial\")));\n   echo \"Document updated successfully\";\n\t\n   // now display the updated document\n   $cursor = $collection-&gt;find();\n\t\n   // iterate cursor to display title of documents\n   echo \"Updated document\";\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocument updated successfully\nUpdated document {\n   \"title\": \"MongoDB Tutorial\"\n}\n</pre>\n<h2>Delete a Document</h2>\n<p>To delete a document, you need to use remove() method.</p>\n<p>In the following example, we will remove the documents that has the title <b>MongoDB Tutorial</b>. Following is the code snippet to delete a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;mycol;\n   echo \"Collection selected succsessfully\";\n   \n   // now remove the document\n   $collection-&gt;remove(array(\"title\"=&gt;\"MongoDB Tutorial\"),false);\n   echo \"Documents deleted successfully\";\n   \n   // now display the available documents\n   $cursor = $collection-&gt;find();\n\t\n   // iterate cursor to display title of documents\n   echo \"Updated document\";\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocuments deleted successfully\n</pre>\n<p>In the above example, the second parameter is boolean type and used for <b>justOne</b> field of <b>remove()</b> method.</p>\n<p>Remaining MongoDB methods <b>findOne(), save(), limit(), skip(), sort()</b> etc. works same as explained above.</p>\n<h1>MongoDB - Relationships</h1>\n<p>Relationships in MongoDB represent how various documents are logically related to each other. Relationships can be modeled via <b>Embedded</b> and <b>Referenced</b> approaches. Such relationships can be either 1:1, 1:N, N:1 or N:N.</p>\n<p>Let us consider the case of storing addresses for users. So, one user can have multiple addresses making this a 1:N relationship.</p>\n<p>Following is the sample document structure of <b>user</b> document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"name\": \"Tom Hanks\",\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\"\n}\n</pre>\n<p>Following is the sample document structure of <b>address</b> document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"52ffc4a5d85242602e000000\"),\n   \"building\": \"22 A, Indiana Apt\",\n   \"pincode\": 123456,\n   \"city\": \"Los Angeles\",\n   \"state\": \"California\"\n} \n</pre>\n<h2>Modeling Embedded Relationships</h2>\n<p>In the embedded approach, we will embed the address document inside the user document.</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\",\n   \"address\": [\n      {\n         \"building\": \"22 A, Indiana Apt\",\n         \"pincode\": 123456,\n         \"city\": \"Los Angeles\",\n         \"state\": \"California\"\n      },\n      {\n         \"building\": \"170 A, Acropolis Apt\",\n         \"pincode\": 456789,\n         \"city\": \"Chicago\",\n         \"state\": \"Illinois\"\n      }\n   ]\n} \n</pre>\n<p>This approach maintains all the related data in a single document, which makes it easy to retrieve and maintain. The whole document can be retrieved in a single query such as \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address\":1})\n</pre>\n<p>Note that in the above query, <b>db</b> and <b>users</b> are the database and collection respectively.</p>\n<p>The drawback is that if the embedded document keeps on growing too much in size, it can impact the read/write performance.</p>\n<h2>Modeling Referenced Relationships</h2>\n<p>This is the approach of designing normalized relationship. In this approach, both the user and address documents will be maintained separately but the user document will contain a field that will reference the address document's <b>id</b> field.</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\",\n   \"address_ids\": [\n      ObjectId(\"52ffc4a5d85242602e000000\"),\n      ObjectId(\"52ffc4a5d85242602e000001\")\n   ]\n}\n</pre>\n<p>As shown above, the user document contains the array field <b>address_ids</b> which contains ObjectIds of corresponding addresses. Using these ObjectIds, we can query the address documents and get address details from there. With this approach, we will need two queries: first to fetch the <b>address_ids</b> fields from <b>user</b> document and second to fetch these addresses from <b>address</b> collection.</p>\n<pre class=\"result notranslate\">\n&gt;var result = db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address_ids\":1})\n&gt;var addresses = db.address.find({\"_id\":{\"$in\":result[\"address_ids\"]}})\n</pre>\n<h1>MongoDB - Database References</h1>\n<p>As seen in the last chapter of MongoDB relationships, to implement a normalized database structure in MongoDB, we use the concept of <b>Referenced Relationships</b> also referred to as <b>Manual References</b> in which we manually store the referenced document's id inside other document. However, in cases where a document contains references from different collections, we can use <b>MongoDB DBRefs</b>.</p>\n<h2>DBRefs vs Manual References</h2>\n<p>As an example scenario, where we would use DBRefs instead of manual references, consider a database where we are storing different types of addresses (home, office, mailing, etc.) in different collections (address_home, address_office, address_mailing, etc). Now, when a <b>user</b> collection's document references an address, it also needs to specify which collection to look into based on the address type. In such scenarios where a document references documents from many collections, we should use DBRefs.</p>\n<h2>Using DBRefs</h2>\n<p>There are three fields in DBRefs \u2212</p>\n<ul class=\"list\">\n<li><p><b>$ref</b> \u2212 This field specifies the collection of the referenced document</p></li>\n<li><p><b>$id</b> \u2212 This field specifies the _id field of the referenced document</p></li>\n<li><p><b>$db</b> \u2212 This is an optional field and contains the name of the database in which the referenced document lies</p></li>\n</ul>\n<p>Consider a sample user document having DBRef field <b>address</b> as shown in the code snippet \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"53402597d852426020000002\"),\n   \"address\": {\n   \"$ref\": \"address_home\",\n   \"$id\": ObjectId(\"534009e4d852427820000002\"),\n   \"$db\": \"tutorialspoint\"},\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\"\n}\n</pre>\n<p>The <b>address</b> DBRef field here specifies that the referenced address document lies in <b>address_home</b> collection under <b>tutorialspoint</b> database and has an id of 534009e4d852427820000002.</p>\n<p>The following code dynamically looks in the collection specified by <b>$ref</b> parameter (<b>address_home</b> in our case) for a document with id as specified by <b>$id</b> parameter in DBRef.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;var user = db.users.findOne({\"name\":\"Tom Benzamin\"})\n&gt;var dbRef = user.address\n&gt;db[dbRef.$ref].findOne({\"_id\":(dbRef.$id)})\n</pre>\n<p>The above code returns the following address document present in <b>address_home</b> collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\" : ObjectId(\"534009e4d852427820000002\"),\n   \"building\" : \"22 A, Indiana Apt\",\n   \"pincode\" : 123456,\n   \"city\" : \"Los Angeles\",\n   \"state\" : \"California\"\n}\n</pre>\n<h1>MongoDB - Covered Queries</h1>\n<p>In this chapter, we will learn about covered queries.</p>\n<h2>What is a Covered Query?</h2>\n<p>As per the official MongoDB documentation, a covered query is a query in which \u2212</p>\n<ul class=\"list\">\n<li>All the fields in the query are part of an index.</li>\n<li>All the fields returned in the query are in the same index.</li>\n</ul>\n<p>Since all the fields present in the query are part of an index, MongoDB matches the query conditions and returns the result using the same index without actually looking inside the documents. Since indexes are present in RAM, fetching data from indexes is much faster as compared to fetching data by scanning documents.</p>\n<h2>Using Covered Queries</h2>\n<p>To test covered queries, consider the following document in the <b>users</b> collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\": ObjectId(\"53402597d852426020000002\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"gender\": \"M\",\n   \"name\": \"Tom Benzamin\",\n   \"user_name\": \"tombenzamin\"\n}\n</pre>\n<p>We will first create a compound index for the <b>users</b> collection on the fields <b>gender</b> and <b>user_name</b> using the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.ensureIndex({gender:1,user_name:1})\n</pre>\n<p>Now, this index will cover the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1,_id:0})\n</pre>\n<p>That is to say that for the above query, MongoDB would not go looking into database documents. Instead it would fetch the required data from indexed data which is very fast.</p>\n<p>Since our index does not include <b>_id</b> field, we have explicitly excluded it from result set of our query, as MongoDB by default returns _id field in every query. So the following query would not have been covered inside the index created above \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1})\n</pre>\n<p>Lastly, remember that an index cannot cover a query if \u2212</p>\n<ul class=\"list\">\n<li>Any of the indexed fields is an array</li>\n<li>Any of the indexed fields is a subdocument</li>\n</ul>\n<h1>MongoDB - Analyzing Queries</h1>\n<p>Analyzing queries is a very important aspect of measuring how effective the database and indexing design is. We will learn about the frequently used <b>$explain</b> and <b>$hint</b> queries.</p>\n<h2>Using $explain</h2>\n<p>The <b>$explain</b> operator provides information on the query, indexes used in a query and other statistics. It is very useful when analyzing how well your indexes are optimized.</p>\n<p>In the last chapter, we had already created an index for the <b>users</b> collection on fields <b>gender</b> and <b>user_name</b> using the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.ensureIndex({gender:1,user_name:1})\n</pre>\n<p>We will now use <b>$explain</b> on the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1,_id:0}).explain()\n</pre>\n<p>The above explain() query returns the following analyzed result \u2212</p>\n<pre class=\"result notranslate\">\n{\n   \"cursor\" : \"BtreeCursor gender_1_user_name_1\",\n   \"isMultiKey\" : false,\n   \"n\" : 1,\n   \"nscannedObjects\" : 0,\n   \"nscanned\" : 1,\n   \"nscannedObjectsAllPlans\" : 0,\n   \"nscannedAllPlans\" : 1,\n   \"scanAndOrder\" : false,\n   \"indexOnly\" : true,\n   \"nYields\" : 0,\n   \"nChunkSkips\" : 0,\n   \"millis\" : 0,\n   \"indexBounds\" : {\n      \"gender\" : [\n         [\n            \"M\",\n            \"M\"\n         ]\n      ],\n      \"user_name\" : [\n         [\n            {\n               \"$minElement\" : 1\n            },\n            {\n               \"$maxElement\" : 1\n            }\n         ]\n      ]\n   }\n}\n</pre>\n<p>We will now look at the fields in this result set \u2212</p>\n<ul class=\"list\">\n<li><p>The true value of <b>indexOnly</b> indicates that this query has used indexing.</p></li>\n<li><p>The <b>cursor</b> field specifies the type of cursor used. BTreeCursor type indicates that an index was used and also gives the name of the index used. BasicCursor indicates that a full scan was made without using any indexes.</p></li>\n<li><p><b>n</b> indicates the number of documents matching returned.</p></li>\n<li><p><b>nscannedObjects</b> indicates the total number of documents scanned.</p></li>\n<li><p><b>nscanned</b> indicates the total number of documents or index entries scanned.</p></li>\n</ul>\n<h2>Using $hint</h2>\n<p>The <b>$hint</b> operator forces the query optimizer to use the specified index to run a query. This is particularly useful when you want to test performance of a query with different indexes. For example, the following query specifies the index on fields <b>gender</b> and <b>user_name</b> to be used for this query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1,_id:0}).hint({gender:1,user_name:1})\n</pre>\n<p>To analyze the above query using $explain \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1,_id:0}).hint({gender:1,user_name:1}).explain()\n</pre>\n<h1>MongoDB - Atomic Operations</h1>\n<p>MongoDB does not support <b>multi-document atomic transactions</b>. However, it does provide atomic operations on a single document. So if a document has hundred fields the update statement will either update all the fields or none, hence maintaining atomicity at the document-level.</p>\n<h2>Model Data for Atomic Operations</h2>\n<p>The recommended approach to maintain atomicity would be to keep all the related information, which is frequently updated together in a single document using <b>embedded documents</b>. This would make sure that all the updates for a single document are atomic.</p>\n<p>Consider the following products document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":1,\n   \"product_name\": \"Samsung S3\",\n   \"category\": \"mobiles\",\n   \"product_total\": 5,\n   \"product_available\": 3,\n   \"product_bought_by\": [\n      {\n         \"customer\": \"john\",\n         \"date\": \"7-Jan-2014\"\n      },\n      {\n         \"customer\": \"mark\",\n         \"date\": \"8-Jan-2014\"\n      }\n   ]\n}\n</pre>\n<p>In this document, we have embedded the information of the customer who buys the product in the <b>product_bought_by</b> field. Now, whenever a new customer buys the product, we will first check if the product is still available using <b>product_available</b> field. If available, we will reduce the value of product_available field as well as insert the new customer's embedded document in the product_bought_by field. We will use <b>findAndModify</b> command for this functionality because it searches and updates the document in the same go.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.products.findAndModify({ \n   query:{_id:2,product_available:{$gt:0}}, \n   update:{ \n      $inc:{product_available:-1}, \n      $push:{product_bought_by:{customer:\"rob\",date:\"9-Jan-2014\"}} \n   }    \n})\n</pre>\n<p>Our approach of embedded document and using findAndModify query makes sure that the product purchase information is updated only if it the product is available. And the whole of this transaction being in the same query, is atomic.</p>\n<p>In contrast to this, consider the scenario where we may have kept the product availability and the information on who has bought the product, separately. In this case, we will first check if the product is available using the first query. Then in the second query we will update the purchase information. However, it is possible that between the executions of these two queries, some other user has purchased the product and it is no more available. Without knowing this, our second query will update the purchase information based on the result of our first query. This will make the database inconsistent because we have sold a product which is not available.</p>\n<h1>MongoDB - Advanced Indexing</h1>\n<p>Consider the following document of the <b>users</b> collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"address\": {\n      \"city\": \"Los Angeles\",\n      \"state\": \"California\",\n      \"pincode\": \"123\"\n   },\n   \"tags\": [\n      \"music\",\n      \"cricket\",\n      \"blogs\"\n   ],\n   \"name\": \"Tom Benzamin\"\n}\n</pre>\n<p>The above document contains an <b>address sub-document</b> and a <b>tags array</b>.</p>\n<h2>Indexing Array Fields</h2>\n<p>Suppose we want to search user documents based on the user\u2019s tags. For this, we will create an index on tags array in the collection.</p>\n<p>Creating an index on array in turn creates separate index entries for each of its fields. So in our case when we create an index on tags array, separate indexes will be created for its values music, cricket and blogs.</p>\n<p>To create an index on tags array, use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.ensureIndex({\"tags\":1})\n</pre>\n<p>After creating the index, we can search on the tags field of the collection like this \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({tags:\"cricket\"})\n</pre>\n<p>To verify that proper indexing is used, use the following <b>explain</b> command \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({tags:\"cricket\"}).explain()\n</pre>\n<p>The above command resulted in \"cursor\" : \"BtreeCursor tags_1\" which confirms that proper indexing is used.</p>\n<h2>Indexing Sub-Document Fields</h2>\n<p>Suppose that we want to search documents based on city, state and pincode fields. Since all these fields are part of address sub-document field, we will create an index on all the fields of the sub-document.</p>\n<p>For creating an index on all the three fields of the sub-document, use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.ensureIndex({\"address.city\":1,\"address.state\":1,\"address.pincode\":1})\n</pre>\n<p>Once the index is created, we can search for any of the sub-document fields utilizing this index as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({\"address.city\":\"Los Angeles\"})   \n</pre>\n<p>Remember that the query expression has to follow the order of the index specified. So the index created above would support the following queries \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({\"address.city\":\"Los Angeles\",\"address.state\":\"California\"}) \n</pre>\n<p>It will also support the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({\"address.city\":\"LosAngeles\",\"address.state\":\"California\",\n   \"address.pincode\":\"123\"})\n</pre>\n<h1>MongoDB - Indexing Limitations</h1>\n<p>In this chapter, we will learn about Indexing Limitations and its other components.</p>\n<h2>Extra Overhead</h2>\n<p>Every index occupies some space as well as causes an overhead on each insert, update and delete. So if you rarely use your collection for read operations, it makes sense not to use indexes.</p>\n<h2>RAM Usage</h2>\n<p>Since indexes are stored in RAM, you should make sure that the total size of the index does not exceed the RAM limit. If the total size increases the RAM size, it will start deleting some indexes, causing performance loss.</p>\n<h2>Query Limitations</h2>\n<p>Indexing can't be used in queries which use \u2212</p>\n<ul class=\"list\">\n<li>Regular expressions or negation operators like $nin, $not, etc.</li>\n<li>Arithmetic operators like $mod, etc.</li>\n<li>$where clause</li>\n</ul>\n<p>Hence, it is always advisable to check the index usage for your queries.</p>\n<h2>Index Key Limits</h2>\n<p>Starting from version 2.6, MongoDB will not create an index if the value of existing index field exceeds the index key limit.</p>\n<h2>Inserting Documents Exceeding Index Key Limit</h2>\n<p>MongoDB will not insert any document into an indexed collection if the indexed field value of this document exceeds the index key limit. Same is the case with mongorestore and mongoimport utilities.</p>\n<h2>Maximum Ranges</h2>\n<ul class=\"list\">\n<li>A collection cannot have more than 64 indexes.</li>\n<li>The length of the index name cannot be longer than 125 characters.</li>\n<li>A compound index can have maximum 31 fields indexed.</li>\n</ul>\n<h1>MongoDB - ObjectId</h1>\n<p>We have been using MongoDB Object Id in all the previous chapters. In this chapter, we will understand the structure of ObjectId.</p>\n<p>An <b>ObjectId</b> is a 12-byte BSON type having the following structure \u2212</p>\n<ul class=\"list\">\n<li>The first 4 bytes representing the seconds since the unix epoch</li>\n<li>The next 3 bytes are the machine identifier</li>\n<li>The next 2 bytes consists of <b>process id</b></li>\n<li>The last 3 bytes are a random counter value</li>\n</ul>\n<p>MongoDB uses ObjectIds as the default value of <b>_id</b> field of each document, which is generated while the creation of any document. The complex combination of ObjectId makes all the _id fields unique.</p>\n<h2>Creating New ObjectId</h2>\n<p>To generate a new ObjectId use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;newObjectId = ObjectId()\n</pre>\n<p>The above statement returned the following uniquely generated id \u2212</p>\n<pre class=\"prettyprint notranslate\">\nObjectId(\"5349b4ddd2781d08c09890f3\")\n</pre>\n<p>Instead of MongoDB generating the ObjectId, you can also provide a 12-byte id \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;myObjectId = ObjectId(\"5349b4ddd2781d08c09890f4\")\n</pre>\n<h2>Creating Timestamp of a Document</h2>\n<p>Since the _id ObjectId by default stores the 4-byte timestamp, in most cases you do not need to store the creation time of any document. You can fetch the creation time of a document using getTimestamp method \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;ObjectId(\"5349b4ddd2781d08c09890f4\").getTimestamp()\n</pre>\n<p>This will return the creation time of this document in ISO date format \u2212</p>\n<pre class=\"prettyprint notranslate\">\nISODate(\"2014-04-12T21:49:17Z\")\n</pre>\n<h2>Converting ObjectId to String</h2>\n<p>In some cases, you may need the value of ObjectId in a string format. To convert the ObjectId in string, use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;newObjectId.str\n</pre>\n<p>The above code will return the string format of the Guid \u2212</p>\n<pre class=\"result notranslate\">\n5349b4ddd2781d08c09890f3\n</pre>\n<h1>MongoDB - Map Reduce</h1>\n<p>As per the MongoDB documentation, <b>Map-reduce</b> is a data processing paradigm for condensing large volumes of data into useful aggregated results. MongoDB uses <b>mapReduce</b> command for map-reduce operations. MapReduce is generally used for processing large data sets.</p>\n<h2>MapReduce Command</h2>\n<p>Following is the syntax of the basic mapReduce command \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.collection.mapReduce(\n   function() {emit(key,value);},  //map function\n   function(key,values) {return reduceFunction}, {   //reduce function\n      out: collection,\n      query: document,\n      sort: document,\n      limit: number\n   }\n)\n</pre>\n<p>The map-reduce function first queries the collection, then maps the result documents to emit key-value pairs, which is then reduced based on the keys that have multiple values.</p>\n<p>In the above syntax \u2212</p>\n<ul class=\"list\">\n<li><p><b>map</b> is a javascript function that maps a value with a key and emits a key-value pair</p></li>\n<li><p><b>reduce</b> is a javascript function that reduces or groups all the documents having the same key</p></li>\n<li><p><b>out</b> specifies the location of the map-reduce query result</p></li>\n<li><p><b>query</b> specifies the optional selection criteria for selecting documents</p></li>\n<li><p><b>sort</b> specifies the optional sort criteria</p></li>\n<li><p><b>limit</b> specifies the optional maximum number of documents to be returned</p></li>\n</ul>\n<h2>Using MapReduce</h2>\n<p>Consider the following document structure storing user posts. The document stores user_name of the user and the status of post.</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"post_text\": \"tutorialspoint is an awesome website for tutorials\",\n   \"user_name\": \"mark\",\n   \"status\":\"active\"\n}\n</pre>\n<p>Now, we will use a mapReduce function on our <b>posts</b> collection to select all the active posts, group them on the basis of user_name and then count the number of posts by each user using the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.mapReduce( \n   function() { emit(this.user_id,1); }, \n\t\n   function(key, values) {return Array.sum(values)}, {  \n      query:{status:\"active\"},  \n      out:\"post_total\" \n   }\n)\n</pre>\n<p>The above mapReduce query outputs the following result \u2212</p>\n<pre class=\"result notranslate\">\n{\n   \"result\" : \"post_total\",\n   \"timeMillis\" : 9,\n   \"counts\" : {\n      \"input\" : 4,\n      \"emit\" : 4,\n      \"reduce\" : 2,\n      \"output\" : 2\n   },\n   \"ok\" : 1,\n}\n</pre>\n<p>The result shows that a total of 4 documents matched the query (status:\"active\"), the map function emitted 4 documents with key-value pairs and finally the reduce function grouped mapped documents having the same keys into 2.</p>\n<p>To see the result of this mapReduce query, use the find operator \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.mapReduce( \n   function() { emit(this.user_id,1); }, \n   function(key, values) {return Array.sum(values)}, {  \n      query:{status:\"active\"},  \n      out:\"post_total\" \n   }\n\t\n).find()\n</pre>\n<p>The above query gives the following result which indicates that both users <b>tom</b> and <b>mark</b> have two posts in active states \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : \"tom\", \"value\" : 2 }\n{ \"_id\" : \"mark\", \"value\" : 2 }\n</pre>\n<p>In a similar manner, MapReduce queries can be used to construct large complex aggregation queries. The use of custom Javascript functions make use of MapReduce which is very flexible and powerful.</p>\n<h1>MongoDB - Text Search</h1>\n<p>Starting from version 2.4, MongoDB started supporting text indexes to search inside string content. The <b>Text Search</b> uses stemming techniques to look for specified words in the string fields by dropping stemming stop words like <b>a, an, the,</b> etc. At present, MongoDB supports around 15 languages.</p>\n<h2>Enabling Text Search</h2>\n<p>Initially, Text Search was an experimental feature but starting from version 2.6, the configuration is enabled by default. But if you are using the previous version of MongoDB, you have to enable text search with the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.adminCommand({setParameter:true,textSearchEnabled:true})\n</pre>\n<h2>Creating Text Index</h2>\n<p>Consider the following document under <b>posts</b> collection containing the post text and its tags \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"post_text\": \"enjoy the mongodb articles on tutorialspoint\",\n   \"tags\": [\n      \"mongodb\",\n      \"tutorialspoint\"\n   ]\n}\n</pre>\n<p>We will create a text index on post_text field so that we can search inside our posts' text \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.ensureIndex({post_text:\"text\"})\n</pre>\n<h2>Using Text Index</h2>\n<p>Now that we have created the text index on post_text field, we will search for all the posts having the word <b>tutorialspoint</b> in their text.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({$text:{$search:\"tutorialspoint\"}})\n</pre>\n<p>The above command returned the following result documents having the word <b>tutorialspoint</b> in their post text \u2212</p>\n<pre class=\"result notranslate\">\n{ \n   \"_id\" : ObjectId(\"53493d14d852429c10000002\"), \n   \"post_text\" : \"enjoy the mongodb articles on tutorialspoint\", \n   \"tags\" : [ \"mongodb\", \"tutorialspoint\" ]\n}\n{\n   \"_id\" : ObjectId(\"53493d1fd852429c10000003\"), \n   \"post_text\" : \"writing tutorials on mongodb\",\n   \"tags\" : [ \"mongodb\", \"tutorial\" ] \n}\n</pre>\n<p>If you are using old versions of MongoDB, you have to use the following command \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.runCommand(\"text\",{search:\" tutorialspoint \"})\n</pre>\n<p>Using Text Search highly improves the search efficiency as compared to normal search.</p>\n<h2>Deleting Text Index</h2>\n<p>To delete an existing text index, first find the name of index using the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.getIndexes()\n</pre>\n<p>After getting the name of your index from above query, run the following command. Here, <b>post_text_text</b> is the name of the index.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.dropIndex(\"post_text_text\")\n</pre>\n<h1>MongoDB - Regular Expression</h1>\n<p>Regular Expressions are frequently used in all languages to search for a pattern or word in any string. MongoDB also provides functionality of regular expression for string pattern matching using the <b>$regex</b> operator. MongoDB uses PCRE (Perl Compatible Regular Expression) as regular expression language.</p>\n<p>Unlike text search, we do not need to do any configuration or command to use regular expressions.</p>\n<p>Consider the following document structure under <b>posts</b> collection containing the post text and its tags \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"post_text\": \"enjoy the mongodb articles on tutorialspoint\",\n   \"tags\": [\n      \"mongodb\",\n      \"tutorialspoint\"\n   ]\n}\n</pre>\n<h2>Using regex Expression</h2>\n<p>The following regex query searches for all the posts containing string <b>tutorialspoint</b> in it \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({post_text:{$regex:\"tutorialspoint\"}})\n</pre>\n<p>The same query can also be written as \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({post_text:/tutorialspoint/})\n</pre>\n<h2>Using regex Expression with Case Insensitive</h2>\n<p>To make the search case insensitive, we use the <b>$options</b> parameter with value <b>$i</b>. The following command will look for strings having the word <b>tutorialspoint</b>, irrespective of smaller or capital case \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({post_text:{$regex:\"tutorialspoint\",$options:\"$i\"}})\n</pre>\n<p>One of the results returned from this query is the following document which contains the word <b>tutorialspoint</b> in different cases \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\" : ObjectId(\"53493d37d852429c10000004\"),\n   \"post_text\" : \"hey! this is my post on TutorialsPoint\", \n   \"tags\" : [ \"tutorialspoint\" ]\n} \n </pre>\n<h2>Using regex for Array Elements</h2>\n<p>We can also use the concept of regex on array field. This is particularly very important when we implement the functionality of tags. So, if you want to search for all the posts having tags beginning from the word tutorial (either tutorial or tutorials or tutorialpoint or tutorialphp), you can use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({tags:{$regex:\"tutorial\"}})\n</pre>\n<h2>Optimizing Regular Expression Queries</h2>\n<ul class=\"list\">\n<li><p>If the document fields are <b>indexed</b>, the query will use make use of indexed values to match the regular expression. This makes the search very fast as compared to the regular expression scanning the whole collection.</p></li>\n<li><p>If the regular expression is a <b>prefix expression</b>, all the matches are meant to start with a certain string characters. For e.g., if the regex expression is <b>^tut</b>, then the query has to search for only those strings that begin with <b>tut</b>.</p></li>\n</ul>\n<h1>Working with RockMongo</h1>\n<p>RockMongo is a MongoDB administration tool using which you can manage your server, databases, collections, documents, indexes, and a lot more. It provides a very user-friendly way for reading, writing, and creating documents. It is similar to PHPMyAdmin tool for PHP and MySQL.</p>\n<h2>Downloading RockMongo</h2>\n<p>You can download the latest version of RockMongo from here: <a href=\"http://rockmongo.com/downloads\" rel=\"nofollow\" target=\"_blank\">http://rockmongo.com/downloads</a></p>\n<h2>Installing RockMongo</h2>\n<p>Once downloaded, you can unzip the package in your server root folder and rename the extracted folder to <b>rockmongo</b>. Open any web browser and access the <b>index.php</b> page from the folder rockmongo. Enter admin/admin as username/password respectively.</p>\n<h2>Working with RockMongo</h2>\n<p>We will now be looking at some basic operations that you can perform with RockMongo.</p>\n<h2>Creating New Database</h2>\n<p>To create a new database, click <b>Databases</b> tab. Click <b>Create New Database</b>. On the next screen, provide the name of the new database and click on <b>Create</b>. You will see a new database getting added in the left panel.</p>\n<h2>Creating New Collection</h2>\n<p>To create a new collection inside a database, click on that database from the left panel. Click on the <b>New Collection</b> link on top. Provide the required name of the collection. Do not worry about the other fields of Is Capped, Size and Max. Click on <b>Create</b>. A new collection will be created and you will be able to see it in the left panel.</p>\n<h2>Creating New Document</h2>\n<p>To create a new document, click on the collection under which you want to add documents. When you click on a collection, you will be able to see all the documents within that collection listed there. To create a new document, click on the <b>Insert</b> link at the top. You can enter the document's data either in JSON or array format and click on <b>Save</b>.</p>\n<h2>Export/Import Data</h2>\n<p>To import/export data of any collection, click on that collection and then click on <b>Export/Import</b> link on the top panel. Follow the next instructions to export your data in a zip format and then import the same zip file to import back data.</p>\n<h1>MongoDB - GridFS</h1>\n<p><b>GridFS</b> is the MongoDB specification for storing and retrieving large files such as images, audio files, video files, etc. It is kind of a file system to store files but its data is stored within MongoDB collections. GridFS has the capability to store files even greater than its document size limit of 16MB.</p>\n<p>GridFS divides a file into chunks and stores each chunk of data in a separate document, each of maximum size 255k.</p>\n<p>GridFS by default uses two collections <b>fs.files</b> and <b>fs.chunks</b> to store the file's metadata and the chunks. Each chunk is identified by its unique _id ObjectId field. The fs.files serves as a parent document. The <b>files_id</b> field in the fs.chunks document links the chunk to its parent.</p>\n<p>Following is a sample document of fs.files collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"filename\": \"test.txt\",\n   \"chunkSize\": NumberInt(261120),\n   \"uploadDate\": ISODate(\"2014-04-13T11:32:33.557Z\"),\n   \"md5\": \"7b762939321e146569b07f72c62cca4f\",\n   \"length\": NumberInt(646)\n}\n</pre>\n<p>The document specifies the file name, chunk size, uploaded date, and length.</p>\n<p>Following is a sample document of fs.chunks document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"files_id\": ObjectId(\"534a75d19f54bfec8a2fe44b\"),\n   \"n\": NumberInt(0),\n   \"data\": \"Mongo Binary Data\"\n}\n</pre>\n<h2>Adding Files to GridFS</h2>\n<p>Now, we will store an mp3 file using GridFS using the <b>put</b> command. For this, we will use the <b>mongofiles.exe</b> utility present in the bin folder of the MongoDB installation folder.</p>\n<p>Open your command prompt, navigate to the mongofiles.exe in the bin folder of MongoDB installation folder and type the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;mongofiles.exe -d gridfs put song.mp3\n</pre>\n<p>Here, <b>gridfs</b> is the name of the database in which the file will be stored. If the database is not present, MongoDB will automatically create a new document on the fly. Song.mp3 is the name of the file uploaded. To see the file's document in database, you can use find query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.fs.files.find()\n</pre>\n<p>The above command returned the following document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   _id: ObjectId('534a811bf8b4aa4d33fdf94d'), \n   filename: \"song.mp3\", \n   chunkSize: 261120, \n   uploadDate: new Date(1397391643474), md5: \"e4f53379c909f7bed2e9d631e15c1c41\",\n   length: 10401959 \n}\n</pre>\n<p>We can also see all the chunks present in fs.chunks collection related to the stored file with the following code, using the document id returned in the previous query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.fs.chunks.find({files_id:ObjectId('534a811bf8b4aa4d33fdf94d')})\n</pre>\n<p>In my case, the query returned 40 documents meaning that the whole mp3 document was divided in 40 chunks of data.</p>\n<h1>MongoDB - Capped Collections</h1>\n<p><b>Capped collections</b> are fixed-size circular collections that follow the insertion order to support high performance for create, read, and delete operations. By circular, it means that when the fixed size allocated to the collection is exhausted, it will start deleting the oldest document in the collection without providing any explicit commands.</p>\n<p>Capped collections restrict updates to the documents if the update results in increased document size. Since capped collections store documents in the order of the disk storage, it ensures that the document size does not increase the size allocated on the disk. Capped collections are best for storing log information, cache data, or any other high volume data.</p>\n<h2>Creating Capped Collection</h2>\n<p>To create a capped collection, we use the normal createCollection command but with <b>capped</b> option as <b>true</b> and specifying the maximum size of collection in bytes.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.createCollection(\"cappedLogCollection\",{capped:true,size:10000})\n</pre>\n<p>In addition to collection size, we can also limit the number of documents in the collection using the <b>max</b> parameter \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.createCollection(\"cappedLogCollection\",{capped:true,size:10000,max:1000})\n</pre>\n<p>If you want to check whether a collection is capped or not, use the following <b>isCapped</b> command \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.cappedLogCollection.isCapped()\n</pre>\n<p>If there is an existing collection which you are planning to convert to capped, you can do it with the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.runCommand({\"convertToCapped\":\"posts\",size:10000})\n</pre>\n<p>This code would convert our existing collection <b>posts</b> to a capped collection.</p>\n<h2>Querying Capped Collection</h2>\n<p>By default, a find query on a capped collection will display results in insertion order. But if you want the documents to be retrieved in reverse order, use the <b>sort</b> command as shown in the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.cappedLogCollection.find().sort({$natural:-1})\n</pre>\n<p>There are few other important points regarding capped collections worth knowing \u2212</p>\n<ul class=\"list\">\n<li><p>We cannot delete documents from a capped collection.</p></li>\n<li><p>There are no default indexes present in a capped collection, not even on _id field.</p></li>\n<li><p>While inserting a new document, MongoDB does not have to actually look for a place to accommodate new document on the disk. It can blindly insert the new document at the tail of the collection. This makes insert operations in capped collections very fast.</p></li>\n<li><p>Similarly, while reading documents MongoDB returns the documents in the same order as present on disk. This makes the read operation very fast.</p></li>\n</ul>\n<h1>MongoDB - Auto-Increment Sequence</h1>\n<p>MongoDB does not have out-of-the-box auto-increment functionality, like SQL databases. By default, it uses the 12-byte ObjectId for the <b>_id</b> field as the primary key to uniquely identify the documents. However, there may be scenarios where we may want the _id field to have some auto-incremented value other than the ObjectId.</p>\n<p>Since this is not a default feature in MongoDB, we will programmatically achieve this functionality by using a <b>counters</b> collection as suggested by the MongoDB documentation.</p>\n<h2>Using Counter Collection</h2>\n<p>Consider the following <b>products</b> document. We want the _id field to be an <b>auto-incremented integer sequence</b> starting from 1,2,3,4 upto n.</p>\n<pre class=\"prettyprint notranslate\">\n{\n  \"_id\":1,\n  \"product_name\": \"Apple iPhone\",\n  \"category\": \"mobiles\"\n}\n</pre>\n<p>For this, create a <b>counters</b> collection, which will keep track of the last sequence value for all the sequence fields.</p>\n<pre class=\"result notranslate\">\n&gt;db.createCollection(\"counters\")\n</pre>\n<p>Now, we will insert the following document in the counters collection with <b>productid</b> as its key \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n  \"_id\":\"productid\",\n  \"sequence_value\": 0\n}\n</pre>\n<p>The field <b>sequence_value</b> keeps track of the last value of the sequence.</p>\n<p>Use the following code to insert this sequence document in the counters collection \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.counters.insert({_id:\"productid\",sequence_value:0})\n</pre>\n<h2>Creating Javascript Function</h2>\n<p>Now, we will create a function <b>getNextSequenceValue</b> which will take the sequence name as its input, increment the sequence number by 1 and return the updated sequence number. In our case, the sequence name is <b>productid</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;function getNextSequenceValue(sequenceName){\n\n   var sequenceDocument = db.counters.findAndModify({\n      query:{_id: sequenceName },\n      update: {$inc:{sequence_value:1}},\n      new:true\n   });\n\t\n   return sequenceDocument.sequence_value;\n}\n</pre>\n<h2>Using the Javascript Function</h2>\n<p>We will now use the function getNextSequenceValue while creating a new document and assigning the returned sequence value as document's _id field.</p>\n<p>Insert two sample documents using the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.products.insert({\n   \"_id\":getNextSequenceValue(\"productid\"),\n   \"product_name\":\"Apple iPhone\",\n   \"category\":\"mobiles\"\n})\n\n&gt;db.products.insert({\n   \"_id\":getNextSequenceValue(\"productid\"),\n   \"product_name\":\"Samsung S3\",\n   \"category\":\"mobiles\"\n})\n</pre>\n<p>As you can see, we have used the getNextSequenceValue function to set value for the _id field.</p>\n<p>To verify the functionality, let us fetch the documents using find command \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.products.find()\n</pre>\n<p>The above query returned the following documents having the auto-incremented _id field \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : 1, \"product_name\" : \"Apple iPhone\", \"category\" : \"mobiles\"}\n\n{ \"_id\" : 2, \"product_name\" : \"Samsung S3\", \"category\" : \"mobiles\" }\n</pre>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/mongodb/mongodb_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"print-btn center\">\n<a href=\"/cgi-bin/printpage.cgi\" target=\"_blank\"><i class=\"icon icon-print big-font\"></i> Print</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/mongodb/mongodb_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<hr/>\n<!-- PRINTING ENDS HERE -->\n<div class=\"bottomgooglead\">\n<div class=\"bottomadtag\">Advertisements</div>\n<script><!--\nvar width = 580;\nvar height = 400;\nvar format = \"580x400_as\";\nif( window.innerWidth < 468 ){\n   width = 300;\n   height = 250;\n   format = \"300x250_as\";\n}\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = width;\ngoogle_ad_height = height;\ngoogle_ad_format = format;\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n</img></div>\n</div>\n<div class=\"row\">\n<div class=\"col-md-3\" id=\"rightbar\">\n<div class=\"simple-ad\">\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'https://www.tutorialspoint.com/mongodb/mongodb_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/facebookIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'https://www.tutorialspoint.com/mongodb/mongodb_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/twitterIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'https://www.tutorialspoint.com/mongodb/mongodb_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/linkedinIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=https://www.tutorialspoint.com/mongodb/mongodb_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/googlePlusIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=https://www.tutorialspoint.com/mongodb/mongodb_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/StumbleUponIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=https://www.tutorialspoint.com/mongodb/mongodb_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/reddit.jpg\"/>\n</a>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 250;\ngoogle_ad_format = \"300x250_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 600;\ngoogle_ad_format = \"300x600_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"ca-pub-2537027957187252\";\n/* Right Side Ad */\ngoogle_ad_slot = \"right_side_ad\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 250;\n//-->\n</script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"footer-copyright\">\n<div class=\"container\">\n<div class=\"row\">\n<div class=\"col-md-1\">\n<a class=\"logo\" href=\"index.htm\"> <img alt=\"Tutorials Point\" class=\"img-responsive\" src=\"/scripts/img/logo-footer.png\"/> </a>\n</div>\n<div class=\"col-md-4 col-sm-12 col-xs-12\">\n<nav id=\"sub-menu\">\n<ul>\n<li><a href=\"/about/about_privacy.htm\">Privacy Policy</a></li>\n<li><a href=\"/about/about_cookies.htm\">Cookies Policy</a></li>\n<li><a href=\"/about/contact_us.htm\">Contact</a></li>\n</ul>\n</nav>\n</div>\n<div class=\"col-md-3 col-sm-12 col-xs-12\">\n<p>\u00a9 Copyright 2019. All Rights Reserved.</p>\n</div>\n<div class=\"col-md-4 col-sm-12 col-xs-12\">\n<div class=\"news-group\">\n<input autocomplete=\"off\" class=\"form-control-foot search\" id=\"textemail\" name=\"textemail\" onblur=\"if (this.value == '') {this.value = 'Enter email for newsletter...';}\" onfocus=\"if (this.value == 'Enter email for newsletter...') {this.value = '';}\" placeholder=\"Enter email for newsletter\" type=\"text\"/>\n<span class=\"input-group-btn\"> <button class=\"btn btn-default btn-footer\" id=\"btnemail\" onclick=\"javascript:void(0);\" type=\"submit\">go</button> </span>\n<div id=\"newsresponse\"></div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"privacy-banner\">\n<div>\n<p>\n      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.\n      <a href=\"javascript:void(0)\" id=\"banner-accept\">Accept</a>\n<a href=\"/about/about_cookies.htm\" id=\"banner-learn\" target=\"_blank\">Learn more</a>\n</p>\n</div>\n</div>\n<script>\n// Banner Trigger if Not Closed\nif (!localStorage.bannerClosed) {\n  document.getElementById('privacy-banner').style.display = \"inherit\";\n} else {\n  document.getElementById('privacy-banner').style.display = \"none\";\n}\ndocument.getElementById('banner-accept').addEventListener('click', function() {\n  document.getElementById('privacy-banner').style.display = \"none\";\n  localStorage.bannerClosed = 'true';\n});\nif (navigator.userAgent.match(/Opera|OPR\\//)) {\n  document.getElementById('privacy-banner').style.display = \"inherit\";\n}\n</script>\n<!-- Libs -->\n<script src=\"/theme/js/custom-min.js?v=7\"></script>\n<script src=\"https://www.google-analytics.com/urchin.js\">\n</script>\n<script>\n_uacct = \"UA-232293-6\";\nurchinTracker();\n$('.pg-icon').click(function(){\n   $('.wrapLoader').show();\n});\n</script>\n\n\n\n", "title": "MongoDB - Quick Guide", "content_html": "<div class=\"col-md-7 middle-col\">\n<h1>MongoDB - Quick Guide</h1>\n<hr/>\n<div style=\"padding-bottom:5px;padding-left:10px;text-align: center;\">Advertisements</div>\n<div style=\"text-align: center;\">\n<script type=\"text/javascript\"><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\" type=\"text/javascript\">\n</script>\n</div>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/mongodb/mongodb_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/mongodb/mongodb_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<div class=\"clearer\"></div>\n<hr/>\n<h1>MongoDB - Overview</h1>\n<p>MongoDB is a cross-platform, document oriented database that provides, high performance, high availability, and easy scalability. MongoDB works on concept of collection and document.</p>\n<h2>Database</h2>\n<p>Database is a physical container for collections. Each database gets its own set of files on the file system. A single MongoDB server typically has multiple databases.</p>\n<h2>Collection</h2>\n<p>Collection is a group of MongoDB documents. It is the equivalent of an RDBMS table. A collection exists within a single database. Collections do not enforce a schema. Documents within a collection can have different fields. Typically, all documents in a collection are of similar or related purpose.</p>\n<h2>Document</h2>\n<p>A document is a set of key-value pairs. Documents have dynamic schema. Dynamic schema means that documents in the same collection do not need to have the same set of fields or structure, and common fields in a collection's documents may hold different types of data.</p>\n<p>The following table shows the relationship of RDBMS terminology with MongoDB.</p>\n<table class=\"table table-bordered\" style=\"text-align:center;\">\n<tr>\n<th style=\"text-align:center;width:50%;\">RDBMS</th>\n<th style=\"text-align:center;\">MongoDB</th>\n</tr>\n<tr>\n<td>Database</td>\n<td>Database</td>\n</tr>\n<tr>\n<td>Table</td>\n<td>Collection</td>\n</tr>\n<tr>\n<td>Tuple/Row</td>\n<td>Document</td>\n</tr>\n<tr>\n<td>column</td>\n<td>Field</td>\n</tr>\n<tr>\n<td>Table Join</td>\n<td>Embedded Documents</td>\n</tr>\n<tr>\n<td>Primary Key</td>\n<td>Primary Key (Default key _id provided by mongodb itself)</td>\n</tr>\n<tr>\n<th colspan=\"2\" style=\"text-align:center;\">Database Server and Client</th>\n</tr>\n<tr>\n<td>Mysqld/Oracle</td>\n<td>mongod</td>\n</tr>\n<tr>\n<td>mysql/sqlplus</td>\n<td>mongo</td>\n</tr>\n</table>\n<h2>Sample Document</h2>\n<p>Following example shows the document structure of a blog site, which is simply a comma separated key value pair.</p>\n<pre class=\"prettyprint notranslate\">\n{\n   _id: ObjectId(7df78ad8902c)\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100, \n   comments: [\t\n      {\n         user:'user1',\n         message: 'My first comment',\n         dateCreated: new Date(2011,1,20,2,15),\n         like: 0 \n      },\n      {\n         user:'user2',\n         message: 'My second comments',\n         dateCreated: new Date(2011,1,25,7,45),\n         like: 5\n      }\n   ]\n}\n</pre>\n<p><b>_id</b> is a 12 bytes hexadecimal number which assures the uniqueness of every document. You can provide _id while inserting the document. If you don\u2019t provide then MongoDB provides a unique id for every document. These 12 bytes first 4 bytes for the current timestamp, next 3 bytes for machine id, next 2 bytes for process id of MongoDB server and remaining 3 bytes are simple incremental VALUE.</p>\n<h1>MongoDB - Advantages</h1>\n<p>Any relational database has a typical schema design that shows number of tables and the relationship between these tables. While in MongoDB, there is no concept of relationship.</p>\n<h2>Advantages of MongoDB over RDBMS</h2>\n<ul class=\"list\">\n<li><p><b>Schema less</b> \u2212 MongoDB is a document database in which one collection holds different documents. Number of fields, content and size of the document can differ from one document to another.</p></li>\n<li><p>Structure of a single object is clear.</p></li>\n<li><p>No complex joins.</p></li>\n<li><p>Deep query-ability. MongoDB supports dynamic queries on documents using a document-based query language that's nearly as powerful as SQL.</p></li>\n<li><p>Tuning.</p></li>\n<li><p><b>Ease of scale-out</b> \u2212 MongoDB is easy to scale.</p></li>\n<li><p>Conversion/mapping of application objects to database objects not needed.</p></li>\n<li><p>Uses internal memory for storing the (windowed) working set, enabling faster access of data.</p></li>\n</ul>\n<h2>Why Use MongoDB?</h2>\n<ul class=\"list\">\n<li><p><b>Document Oriented Storage</b> \u2212 Data is stored in the form of JSON style documents.</p></li>\n<li><p>Index on any attribute</p></li>\n<li><p>Replication and high availability</p></li>\n<li><p>Auto-sharding</p></li>\n<li><p>Rich queries</p></li>\n<li><p>Fast in-place updates</p></li>\n<li><p>Professional support by MongoDB</p></li>\n</ul>\n<h2>Where to Use MongoDB?</h2>\n<ul class=\"list\">\n<li>Big Data</li>\n<li>Content Management and Delivery</li>\n<li>Mobile and Social Infrastructure</li>\n<li>User Data Management</li>\n<li>Data Hub</li>\n</ul>\n<h1>MongoDB - Environment</h1>\n<p>Let us now see how to install MongoDB on Windows.</p>\n<h2>Install MongoDB On Windows</h2>\n<p>To install MongoDB on Windows, first download the latest release of MongoDB from <a href=\"https://www.mongodb.org/downloads\" rel=\"nofollow\" target=\"_blank\">https://www.mongodb.org/downloads</a>. Make sure you get correct version of MongoDB depending upon your Windows version. To get your Windows version, open command prompt and execute the following command.</p>\n<pre class=\"result notranslate\">\nC:\\&gt;wmic os get osarchitecture\nOSArchitecture\n64-bit\nC:\\&gt;\n</pre>\n<p>32-bit versions of MongoDB only support databases smaller than 2GB and suitable only for testing and evaluation purposes.</p>\n<p>Now extract your downloaded file to c:\\ drive or any other location. Make sure the name of the extracted folder is mongodb-win32-i386-[version] or mongodb-win32-x86_64-[version]. Here [version] is the version of MongoDB download.</p>\n<p>Next, open the command prompt and run the following command.</p>\n<pre class=\"result notranslate\">\nC:\\&gt;move mongodb-win64-* mongodb\n   1 dir(s) moved.\nC:\\&gt;\n</pre>\n<p>In case you have extracted the MongoDB at different location, then go to that path by using command <b>cd FOLDER/DIR</b> and now run the above given process.</p>\n<p>MongoDB requires a data folder to store its files. The default location for the MongoDB data directory is c:\\data\\db. So you need to create this folder using the Command Prompt. Execute the following command sequence.</p>\n<pre class=\"result notranslate\">\nC:\\&gt;md data\nC:\\md data\\db\n</pre>\n<p>If you have to install the MongoDB at a different location, then you need to specify an alternate path for <b>\\data\\db</b> by setting the path <b>dbpath</b> in <b>mongod.exe</b>. For the same, issue the following commands.</p>\n<p>In the command prompt, navigate to the bin directory present in the MongoDB installation folder. Suppose my installation folder is <b>D:\\set up\\mongodb</b></p>\n<pre class=\"result notranslate\">\nC:\\Users\\XYZ&gt;d:\nD:\\&gt;cd \"set up\"\nD:\\set up&gt;cd mongodb\nD:\\set up\\mongodb&gt;cd bin\nD:\\set up\\mongodb\\bin&gt;mongod.exe --dbpath \"d:\\set up\\mongodb\\data\" \n</pre>\n<p>This will show <b>waiting for connections</b> message on the console output, which indicates that the mongod.exe process is running successfully.</p>\n<p>Now to run the MongoDB, you need to open another command prompt and issue the following command.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongo.exe\nMongoDB shell version: 2.4.6\nconnecting to: test\n&gt;db.test.save( { a: 1 } )\n&gt;db.test.find()\n{ \"_id\" : ObjectId(5879b0f65a56a454), \"a\" : 1 }\n&gt;\n</pre>\n<p>This will show that MongoDB is installed and run successfully. Next time when you run MongoDB, you need to issue only commands.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongod.exe --dbpath \"d:\\set up\\mongodb\\data\" \nD:\\set up\\mongodb\\bin&gt;mongo.exe\n</pre>\n<h2>Install MongoDB on Ubuntu</h2>\n<p>Run the following command to import the MongoDB public GPG key \u2212</p>\n<pre class=\"result notranslate\">\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10\n</pre>\n<p>Create a /etc/apt/sources.list.d/mongodb.list file using the following command.</p>\n<pre class=\"result notranslate\">\necho 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' \n   | sudo tee /etc/apt/sources.list.d/mongodb.list\n</pre>\n<p>Now issue the following command to update the repository \u2212</p>\n<pre class=\"result notranslate\">\nsudo apt-get update\n</pre>\n<p>Next install the MongoDB by using the following command \u2212</p>\n<pre class=\"result notranslate\">\napt-get install mongodb-10gen = 2.2.3\n</pre>\n<p>In the above installation, 2.2.3 is currently released MongoDB version. Make sure to install the latest version always. Now MongoDB is installed successfully.</p>\n<h2>Start MongoDB</h2>\n<pre class=\"result notranslate\">\nsudo service mongodb start\n</pre>\n<h2>Stop MongoDB</h2>\n<pre class=\"result notranslate\">\nsudo service mongodb stop\n</pre>\n<h2>Restart MongoDB</h2>\n<pre class=\"result notranslate\">\nsudo service mongodb restart\n</pre>\n<p>To use MongoDB run the following command.</p>\n<pre class=\"result notranslate\">\nmongo\n</pre>\n<p>This will connect you to running MongoDB instance.</p>\n<h2>MongoDB Help</h2>\n<p>To get a list of commands, type <b>db.help()</b> in MongoDB client. This will give you a list of commands as shown in the following screenshot.</p>\n<img alt=\"DB Help\" src=\"/mongodb/images/db_help.png\">\n<h2>MongoDB Statistics</h2>\n<p>To get stats about MongoDB server, type the command <b>db.stats()</b> in MongoDB client. This will show the database name, number of collection and documents in the database. Output of the command is shown in the following screenshot.</p>\n<img alt=\"DB Stats\" src=\"/mongodb/images/db_stats.png\"/>\n<h1>MongoDB - Data Modelling</h1>\n<p>Data in MongoDB has a flexible schema.documents in the same collection. They do not need to have the same set of fields or structure, and common fields in a collection\u2019s documents may hold different types of data.</p>\n<h2 style=\"font-size:22px;\">Some considerations while designing Schema in MongoDB</h2>\n<ul class=\"list\">\n<li><p>Design your schema according to user requirements.</p></li>\n<li><p>Combine objects into one document if you will use them together. Otherwise separate them (but make sure there should not be need of joins).</p></li>\n<li><p>Duplicate the data (but limited) because disk space is cheap as compare to compute time.</p></li>\n<li><p>Do joins while write, not on read.</p></li>\n<li><p>Optimize your schema for most frequent use cases.</p></li>\n<li><p>Do complex aggregation in the schema.</p></li>\n</ul>\n<h2>Example</h2>\n<p>Suppose a client needs a database design for his blog/website and see the differences between RDBMS and MongoDB schema design. Website has the following requirements.</p>\n<ul class=\"list\">\n<li>Every post has the unique title, description and url.</li>\n<li>Every post can have one or more tags.</li>\n<li>Every post has the name of its publisher and total number of likes.</li>\n<li>Every post has comments given by users along with their name, message, data-time and likes.</li>\n<li>On each post, there can be zero or more comments.</li>\n</ul>\n<p>In RDBMS schema, design for above requirements will have minimum three tables.</p>\n<img alt=\"RDBMS Schema Design\" src=\"/mongodb/images/rdbms.png\"/>\n<p>While in MongoDB schema, design will have one collection post and the following structure \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   _id: POST_ID\n   title: TITLE_OF_POST, \n   description: POST_DESCRIPTION,\n   by: POST_BY,\n   url: URL_OF_POST,\n   tags: [TAG1, TAG2, TAG3],\n   likes: TOTAL_LIKES, \n   comments: [\t\n      {\n         user:'COMMENT_BY',\n         message: TEXT,\n         dateCreated: DATE_TIME,\n         like: LIKES \n      },\n      {\n         user:'COMMENT_BY',\n         message: TEXT,\n         dateCreated: DATE_TIME,\n         like: LIKES\n      }\n   ]\n}\n</pre>\n<p>So while showing the data, in RDBMS you need to join three tables and in MongoDB, data will be shown from one collection only.</p>\n<h1>MongoDB - Create Database</h1>\n<p>In this chapter, we will see how to create a database in MongoDB.</p>\n<h2>The use Command</h2>\n<p>MongoDB <b>use DATABASE_NAME</b> is used to create database. The command will create a new database if it doesn't exist, otherwise it will return the existing database.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>use DATABASE</b> statement is as follows \u2212</p>\n<pre class=\"result notranslate\">\nuse DATABASE_NAME\n</pre>\n<h3>Example</h3>\n<p>If you want to use a database with name <b>&lt;mydb&gt;</b>, then <b>use DATABASE</b> statement would be as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;use mydb\nswitched to db mydb\n</pre>\n<p>To check your currently selected database, use the command <b>db</b></p>\n<pre class=\"result notranslate\">\n&gt;db\nmydb\n</pre>\n<p>If you want to check your databases list, use the command <b>show dbs</b>.</p>\n<pre class=\"result notranslate\">\n&gt;show dbs\nlocal     0.78125GB\ntest      0.23012GB\n</pre>\n<p>Your created database (mydb) is not present in list. To display database, you need to insert at least one document into it.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.movie.insert({\"name\":\"tutorials point\"})\n&gt;show dbs\nlocal      0.78125GB\nmydb       0.23012GB\ntest       0.23012GB\n</pre>\n<p>In MongoDB default database is test. If you didn't create any database, then collections will be stored in test database.</p>\n<h1>MongoDB - Drop Database</h1>\n<p>In this chapter, we will see how to drop a database using MongoDB command.</p>\n<h2>The dropDatabase() Method</h2>\n<p>MongoDB <b>db.dropDatabase()</b> command is used to drop a existing database.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>dropDatabase()</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\ndb.dropDatabase()\n</pre>\n<p>This will delete the selected database. If you have not selected any database, then it will delete default 'test' database.</p>\n<h3>Example</h3>\n<p>First, check the list of available databases by using the command, <b>show dbs</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;show dbs\nlocal      0.78125GB\nmydb       0.23012GB\ntest       0.23012GB\n&gt;\n</pre>\n<p>If you want to delete new database <b>&lt;mydb&gt;</b>, then <b>dropDatabase()</b> command would be as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;use mydb\nswitched to db mydb\n&gt;db.dropDatabase()\n&gt;{ \"dropped\" : \"mydb\", \"ok\" : 1 }\n&gt;\n</pre>\n<p>Now check list of databases.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;show dbs\nlocal      0.78125GB\ntest       0.23012GB\n&gt;\n</pre>\n<h1>MongoDB - Create Collection</h1>\n<p>In this chapter, we will see how to create a collection using MongoDB.</p>\n<h2>The createCollection() Method</h2>\n<p>MongoDB <b>db.createCollection(name, options)</b> is used to create collection.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>createCollection()</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\ndb.createCollection(name, options)\n</pre>\n<p>In the command, <b>name</b> is name of collection to be created. <b>Options</b> is a document and is used to specify configuration of collection.</p>\n<table class=\"table table-bordered\" style=\"text-align:center;\">\n<tr>\n<th style=\"width:25%;text-align:center;\">Parameter</th>\n<th style=\"width:25%;text-align:center;\">Type</th>\n<th style=\"text-align:center;\">Description</th>\n</tr>\n<tr>\n<td>Name</td>\n<td>String</td>\n<td>Name of the collection to be created</td>\n</tr>\n<tr>\n<td>Options</td>\n<td>Document</td>\n<td>(Optional) Specify options about memory size and indexing</td>\n</tr>\n</table>\n<p>Options parameter is optional, so you need to specify only the name of the collection. Following is the list of options you can use \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:15%;text-align:center;\">Field</th>\n<th style=\"width:15%;text-align:center;\">Type</th>\n<th style=\"text-align:center;\">Description</th></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">capped</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>(Optional) If true, enables a capped collection. Capped collection is a fixed size collection that automatically overwrites its oldest entries when it reaches its maximum size. <b>If you specify true, you need to specify size parameter also.</b></td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">autoIndexId</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>(Optional) If true, automatically create index on _id field.s Default value is false.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">size</td>\n<td style=\"text-align:center;vertical-align:middle;\">number</td>\n<td>(Optional) Specifies a maximum size in bytes for a capped collection. <b>If capped is true, then you need to specify this field also.</b></td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">max</td>\n<td style=\"text-align:center;vertical-align:middle;\">number</td>\n<td>(Optional) Specifies the maximum number of documents allowed in the capped collection.</td>\n</tr>\n</table>\n<p>While inserting the document, MongoDB first checks size field of capped collection, then it checks max field.</p>\n<h3>Examples</h3>\n<p>Basic syntax of <b>createCollection()</b> method without options is as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;use test\nswitched to db test\n&gt;db.createCollection(\"mycollection\")\n{ \"ok\" : 1 }\n&gt;\n</pre>\n<p>You can check the created collection by using the command <b>show collections</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;show collections\nmycollection\nsystem.indexes\n</pre>\n<p>The following example shows the syntax of <b>createCollection()</b> method with few important options \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.createCollection(\"mycol\", { capped : true, autoIndexId : true, size : \n   6142800, max : 10000 } )\n{ \"ok\" : 1 }\n&gt;\n</pre>\n<p>In MongoDB, you don't need to create collection. MongoDB creates collection automatically, when you insert some document.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.tutorialspoint.insert({\"name\" : \"tutorialspoint\"})\n&gt;show collections\nmycol\nmycollection\nsystem.indexes\ntutorialspoint\n&gt;\n</pre>\n<h1>MongoDB - Drop Collection</h1>\n<p>In this chapter, we will see how to drop a collection using MongoDB.</p>\n<h2>The drop() Method</h2>\n<p>MongoDB's <b>db.collection.drop()</b> is used to drop a collection from the database.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>drop()</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\ndb.COLLECTION_NAME.drop()\n</pre>\n<h3>Example</h3>\n<p>First, check the available collections into your database <b>mydb</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;use mydb\nswitched to db mydb\n&gt;show collections\nmycol\nmycollection\nsystem.indexes\ntutorialspoint\n&gt;\n</pre>\n<p>Now drop the collection with the name <b>mycollection</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycollection.drop()\ntrue\n&gt;\n</pre>\n<p>Again check the list of collections into database.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;show collections\nmycol\nsystem.indexes\ntutorialspoint\n&gt;\n</pre>\n<p>drop() method will return true, if the selected collection is dropped successfully, otherwise it will return false.</p>\n<h1>MongoDB - Datatypes</h1>\n<p>MongoDB supports many datatypes. Some of them are \u2212</p>\n<ul class=\"list\">\n<li><p><b>String</b> \u2212 This is the most commonly used datatype to store the data. String in MongoDB must be UTF-8 valid.</p></li>\n<li><p><b>Integer</b> \u2212 This type is used to store a numerical value. Integer can be 32 bit or 64 bit depending upon your server.</p></li>\n<li><p><b>Boolean</b> \u2212 This type is used to store a boolean (true/ false) value.</p></li>\n<li><p><b>Double</b> \u2212 This type is used to store floating point values.</p></li>\n<li><p><b>Min/ Max keys</b> \u2212 This type is used to compare a value against the lowest and highest BSON elements.</p></li>\n<li><p><b>Arrays</b> \u2212 This type is used to store arrays or list or multiple values into one key.</p></li>\n<li><p><b>Timestamp</b> \u2212 ctimestamp. This can be handy for recording when a document has been modified or added.</p></li>\n<li><p><b>Object</b> \u2212 This datatype is used for embedded documents.</p></li>\n<li><p><b>Null</b> \u2212 This type is used to store a Null value.</p></li>\n<li><p><b>Symbol</b> \u2212 This datatype is used identically to a string; however, it's generally reserved for languages that use a specific symbol type.</p></li>\n<li><p><b>Date </b> \u2212 This datatype is used to store the current date or time in UNIX time format. You can specify your own date time by creating object of Date and passing day, month, year into it.</p></li>\n<li><p><b>Object ID</b> \u2212 This datatype is used to store the document\u2019s ID.</p></li>\n<li><p><b>Binary data</b> \u2212 This datatype is used to store binary data.</p></li>\n<li><p><b>Code</b> \u2212 This datatype is used to store JavaScript code into the document.</p></li>\n<li><p><b>Regular expression</b> \u2212 This datatype is used to store regular expression.</p></li>\n</ul>\n<h1>MongoDB - Insert Document</h1>\n<p>In this chapter, we will learn how to insert document in MongoDB collection.</p>\n<h2>The insert() Method</h2>\n<p>To insert data into MongoDB collection, you need to use MongoDB's <b>insert()</b> or <b>save()</b> method.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>insert()</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.insert(document)\n</pre>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.insert({\n   _id: ObjectId(7df78ad8902c),\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100\n})\n</pre>\n<p>Here <b>mycol</b> is our collection name, as created in the previous chapter. If the collection doesn't exist in the database, then MongoDB will create this collection and then insert a document into it.</p>\n<p>In the inserted document, if we don't specify the _id parameter, then MongoDB assigns a unique ObjectId for this document.</p>\n<p>_id is 12 bytes hexadecimal number unique for every document in a collection. 12 bytes are divided as follows \u2212</p>\n<pre class=\"result notranslate\">\n_id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, \n   3 bytes incrementer)\n</pre>\n<p>To insert multiple documents in a single query, you can pass an array of documents in insert() command.</p>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\n&gt;db.post.insert([\n   {\n      title: 'MongoDB Overview', \n      description: 'MongoDB is no sql database',\n      by: 'tutorials point',\n      url: 'http://www.tutorialspoint.com',\n      tags: ['mongodb', 'database', 'NoSQL'],\n      likes: 100\n   },\n\t\n   {\n      title: 'NoSQL Database', \n      description: \"NoSQL database doesn't have tables\",\n      by: 'tutorials point',\n      url: 'http://www.tutorialspoint.com',\n      tags: ['mongodb', 'database', 'NoSQL'],\n      likes: 20, \n      comments: [\t\n         {\n            user:'user1',\n            message: 'My first comment',\n            dateCreated: new Date(2013,11,10,2,35),\n            like: 0 \n         }\n      ]\n   }\n])\n</pre>\n<p>To insert the document you can use <b>db.post.save(document)</b> also. If you don't specify <b>_id</b> in the document then <b>save()</b> method will work same as <b>insert()</b> method. If you specify _id then it will replace whole data of document containing _id as specified in save() method.</p>\n<h1>MongoDB - Query Document</h1>\n<p>In this chapter, we will learn how to query document from MongoDB collection.</p>\n<h2>The find() Method</h2>\n<p>To query data from MongoDB collection, you need to use MongoDB's <b>find()</b> method.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>find()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.find()\n</pre>\n<p><b>find()</b> method will display all the documents in a non-structured way.</p>\n<h2>The pretty() Method</h2>\n<p>To display the results in a formatted way, you can use <b>pretty()</b> method.</p>\n<h3>Syntax</h3>\n<pre class=\"result notranslate\">\n&gt;db.mycol.find().pretty()\n</pre>\n<h2>Example</h2>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find().pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n&gt;\n</pre>\n<p>Apart from find() method, there is <b>findOne()</b> method, that returns only one document.</p>\n<h2>RDBMS Where Clause Equivalents in MongoDB</h2>\n<p>To query the document on the basis of some condition, you can use following operations.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Operation</th>\n<th style=\"text-align:center;\">Syntax</th>\n<th style=\"text-align:center;\">Example</th>\n<th style=\"width:35%; text-align:center;\">RDBMS Equivalent</th>\n</tr>\n<tr>\n<td>Equality</td>\n<td>{&lt;key&gt;:&lt;value&gt;}</td>\n<td>db.mycol.find({\"by\":\"tutorials point\"}).pretty()</td>\n<td>where by = 'tutorials point'</td>\n</tr>\n<tr>\n<td>Less Than</td>\n<td>{&lt;key&gt;:{$lt:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$lt:50}}).pretty()</td>\n<td>where likes &lt; 50</td>\n</tr>\n<tr>\n<td style=\"width:35%;\">Less Than Equals</td>\n<td>{&lt;key&gt;:{$lte:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$lte:50}}).pretty()</td>\n<td>where likes &lt;= 50</td>\n</tr>\n<tr>\n<td>Greater Than</td>\n<td>{&lt;key&gt;:{$gt:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$gt:50}}).pretty()</td>\n<td>where likes &gt; 50</td>\n</tr>\n<tr>\n<td>Greater Than Equals</td>\n<td>{&lt;key&gt;:{$gte:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$gte:50}}).pretty()</td>\n<td>where likes &gt;= 50</td>\n</tr>\n<tr>\n<td>Not Equals</td>\n<td>{&lt;key&gt;:{$ne:&lt;value&gt;}}</td>\n<td>db.mycol.find({\"likes\":{$ne:50}}).pretty()</td>\n<td>where likes != 50</td>\n</tr>\n</table>\n<h2>AND in MongoDB</h2>\n<h3>Syntax</h3>\n<p>In the <b>find()</b> method, if you pass multiple keys by separating them by ',' then MongoDB treats it as <b>AND</b> condition. Following is the basic syntax of <b>AND</b> \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.mycol.find(\n   {\n      $and: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n</pre>\n<h3>Example</h3>\n<p>Following example will show all the tutorials written by 'tutorials point' and whose title is 'MongoDB Overview'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({$and:[{\"by\":\"tutorials point\"},{\"title\": \"MongoDB Overview\"}]}).pretty() {\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n</pre>\n<p>For the above given example, equivalent where clause will be <b>' where by = 'tutorials point' AND title = 'MongoDB Overview' '</b>. You can pass any number of key, value pairs in find clause.</p>\n<h2>OR in MongoDB</h2>\n<h3>Syntax</h3>\n<p>To query documents based on the OR condition, you need to use <b>$or</b> keyword. Following is the basic syntax of <b>OR</b> \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n</pre>\n<h3>Example</h3>\n<p>Following example will show all the tutorials written by 'tutorials point' or whose title is 'MongoDB Overview'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({$or:[{\"by\":\"tutorials point\"},{\"title\": \"MongoDB Overview\"}]}).pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n&gt;\n</pre>\n<h2>Using AND and OR Together</h2>\n<h3>Example</h3>\n<p>The following example will show the documents that have likes greater than 10 and whose title is either 'MongoDB Overview' or by is 'tutorials point'. Equivalent SQL where clause is <b>'where likes&gt;10 AND (by = 'tutorials point' OR title = 'MongoDB Overview')'</b></p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({\"likes\": {$gt:10}, $or: [{\"by\": \"tutorials point\"},\n   {\"title\": \"MongoDB Overview\"}]}).pretty()\n{\n   \"_id\": ObjectId(7df78ad8902c),\n   \"title\": \"MongoDB Overview\", \n   \"description\": \"MongoDB is no sql database\",\n   \"by\": \"tutorials point\",\n   \"url\": \"http://www.tutorialspoint.com\",\n   \"tags\": [\"mongodb\", \"database\", \"NoSQL\"],\n   \"likes\": \"100\"\n}\n&gt;\n</pre>\n<h1>MongoDB - Update Document</h1>\n<p>MongoDB's <b>update()</b> and <b>save()</b> methods are used to update document into a collection. The update() method updates the values in the existing document while the save() method replaces the existing document with the document passed in save() method.</p>\n<h2>MongoDB Update() Method</h2>\n<p>The update() method updates the values in the existing document.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>update()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.update(SELECTION_CRITERIA, UPDATED_DATA)\n</pre>\n<h3>Example</h3>\n<p>Consider the mycol collection has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will set the new title 'New MongoDB Tutorial' of the documents whose title is 'MongoDB Overview'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.update({'title':'MongoDB Overview'},{$set:{'title':'New MongoDB Tutorial'}})\n&gt;db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"New MongoDB Tutorial\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n&gt;\n</pre>\n<p>By default, MongoDB will update only a single document. To update multiple documents, you need to set a parameter 'multi' to true.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.update({'title':'MongoDB Overview'},\n   {$set:{'title':'New MongoDB Tutorial'}},{multi:true})\n</pre>\n<h2>MongoDB Save() Method</h2>\n<p>The <b>save()</b> method replaces the existing document with the new document passed in the save() method.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of MongoDB <b>save()</b> method is shown below \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})\n</pre>\n<h3>Example</h3>\n<p>Following example will replace the document with the _id '5983548781331adf45ec5'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.save(\n   {\n      \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"Tutorials Point New Topic\",\n      \"by\":\"Tutorials Point\"\n   }\n)\n&gt;db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"Tutorials Point New Topic\",\n   \"by\":\"Tutorials Point\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n&gt;\n</pre>\n<h1>MongoDB - Delete Document</h1>\n<p>In this chapter, we will learn how to delete a document using MongoDB.</p>\n<h2>The remove() Method</h2>\n<p>MongoDB's <b>remove()</b> method is used to remove a document from the collection. remove() method accepts two parameters. One is deletion criteria and second is justOne flag.</p>\n<ul class=\"list\">\n<li><p><b>deletion criteria</b> \u2212 (Optional) deletion criteria according to documents will be removed.</p></li>\n<li><p><b>justOne</b> \u2212 (Optional) if set to true or 1, then remove only one document.</p></li>\n</ul>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>remove()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)\n</pre>\n<h3>Example</h3>\n<p>Consider the mycol collection has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will remove all the documents whose title is 'MongoDB Overview'.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.remove({'title':'MongoDB Overview'})\n&gt;db.mycol.find()\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n&gt;\n</pre>\n<h2>Remove Only One</h2>\n<p>If there are multiple records and you want to delete only the first record, then set <b>justOne</b> parameter in <b>remove()</b> method.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\n</pre>\n<h2>Remove All Documents</h2>\n<p>If you don't specify deletion criteria, then MongoDB will delete whole documents from the collection. <b>This is equivalent of SQL's truncate command.</b></p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.remove()\n&gt;db.mycol.find()\n&gt;\n</pre>\n<h1>MongoDB - Projection</h1>\n<p>In MongoDB, projection means selecting only the necessary data rather than selecting whole of the data of a document. If a document has 5 fields and you need to show only 3, then select only 3 fields from them.</p>\n<h2>The find() Method</h2>\n<p>MongoDB's <b>find()</b> method, explained in <a href=\"/mongodb/mongodb_query_document.htm\" rel=\"nofollow\" target=\"_blank\">MongoDB Query Document</a> accepts second optional parameter that is list of fields that you want to retrieve. In MongoDB, when you execute <b>find()</b> method, then it displays all fields of a document. To limit this, you need to set a list of fields with value 1 or 0. 1 is used to show the field while 0 is used to hide the fields.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>find()</b> method with projection is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.find({},{KEY:1})\n</pre>\n<h3>Example</h3>\n<p>Consider the collection mycol has the following data \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will display the title of the document while querying the document.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({},{\"title\":1,_id:0})\n{\"title\":\"MongoDB Overview\"}\n{\"title\":\"NoSQL Overview\"}\n{\"title\":\"Tutorials Point Overview\"}\n&gt;\n</pre>\n<p>Please note <b>_id</b> field is always displayed while executing <b>find()</b> method, if you don't want this field, then you need to set it as 0.</p>\n<h1>MongoDB - Limit Records</h1>\n<p>In this chapter, we will learn how to limit records using MongoDB.</p>\n<h2>The Limit() Method</h2>\n<p>To limit the records in MongoDB, you need to use <b>limit()</b> method. The method accepts one number type argument, which is the number of documents that you want to be displayed.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>limit()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.find().limit(NUMBER)\n</pre>\n<h3>Example</h3>\n<p>Consider the collection myycol has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will display only two documents while querying the document.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({},{\"title\":1,_id:0}).limit(2)\n{\"title\":\"MongoDB Overview\"}\n{\"title\":\"NoSQL Overview\"}\n&gt;\n</pre>\n<p>If you don't specify the number argument in <b>limit()</b> method then it will display all documents from the collection.</p>\n<h2>MongoDB Skip() Method</h2>\n<p>Apart from limit() method, there is one more method <b>skip()</b> which also accepts number type argument and is used to skip the number of documents.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>skip()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n</pre>\n<h3>Example</h3>\n<p>Following example will display only the second document.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({},{\"title\":1,_id:0}).limit(1).skip(1)\n{\"title\":\"NoSQL Overview\"}\n&gt;\n</pre>\n<p>Please note, the default value in <b>skip()</b> method is 0.</p>\n<h1>MongoDB - Sort Records</h1>\n<p>In this chapter, we will learn how to sort records in MongoDB.</p>\n<h2>The sort() Method</h2>\n<p>To sort documents in MongoDB, you need to use <b>sort()</b> method. The method accepts a document containing a list of fields along with their sorting order. To specify sorting order 1 and -1 are used. 1 is used for ascending order while -1 is used for descending order.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>sort()</b> method is as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.COLLECTION_NAME.find().sort({KEY:1})\n</pre>\n<h3>Example</h3>\n<p>Consider the collection myycol has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : ObjectId(5983548781331adf45ec5), \"title\":\"MongoDB Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec6), \"title\":\"NoSQL Overview\"}\n{ \"_id\" : ObjectId(5983548781331adf45ec7), \"title\":\"Tutorials Point Overview\"}\n</pre>\n<p>Following example will display the documents sorted by title in the descending order.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.find({},{\"title\":1,_id:0}).sort({\"title\":-1})\n{\"title\":\"Tutorials Point Overview\"}\n{\"title\":\"NoSQL Overview\"}\n{\"title\":\"MongoDB Overview\"}\n&gt;\n</pre>\n<p>Please note, if you don't specify the sorting preference, then <b>sort()</b> method will display the documents in ascending order.</p>\n<h1>MongoDB - Indexing</h1>\n<p>Indexes support the efficient resolution of queries. Without indexes, MongoDB must scan every document of a collection to select those documents that match the query statement. This scan is highly inefficient and require MongoDB to process a large volume of data.</p>\n<p>Indexes are special data structures, that store a small portion of the data set in an easy-to-traverse form. The index stores the value of a specific field or set of fields, ordered by the value of the field as specified in the index.</p>\n<h2>The ensureIndex() Method</h2>\n<p>To create an index you need to use ensureIndex() method of MongoDB.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>ensureIndex()</b> method is as follows().</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.COLLECTION_NAME.ensureIndex({KEY:1})\n</pre>\n<p>Here key is the name of the field on which you want to create index and 1 is for ascending order. To create index in descending order you need to use -1.</p>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.ensureIndex({\"title\":1})\n&gt;\n</pre>\n<p>In <b>ensureIndex()</b> method you can pass multiple fields, to create index on multiple fields.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.mycol.ensureIndex({\"title\":1,\"description\":-1})\n&gt;\n</pre>\n<p><b>ensureIndex()</b> method also accepts list of options (which are optional). Following is the list \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:10%;text-align:center;\">Parameter</th>\n<th style=\"width:10%;text-align:center;\">Type</th>\n<th style=\"text-align:center;\">Description</th></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">background</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>Builds the index in the background so that building an index does not block other database activities. Specify true to build in the background. The default value is <b>false</b>.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">unique</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>Creates a unique index so that the collection will not accept insertion of documents where the index key or keys match an existing value in the index. Specify true to create a unique index. The default value is <b>false</b>.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">name</td>\n<td style=\"text-align:center;vertical-align:middle;\">string</td>\n<td>The name of the index. If unspecified, MongoDB generates an index name by concatenating the names of the indexed fields and the sort order.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">dropDups</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>Creates a unique index on a field that may have duplicates. MongoDB indexes only the first occurrence of a key and removes all documents from the collection that contain subsequent occurrences of that key. Specify true to create unique index. The default value is <b>false</b>.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">sparse</td>\n<td style=\"text-align:center;vertical-align:middle;\">Boolean</td>\n<td>If true, the index only references documents with the specified field. These indexes use less space but behave differently in some situations (particularly sorts). The default value is <b>false</b>.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">expireAfterSeconds</td>\n<td style=\"text-align:center;vertical-align:middle;\">integer</td>\n<td>Specifies a value, in seconds, as a TTL to control how long MongoDB retains documents in this collection.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">v</td>\n<td style=\"text-align:center;vertical-align:middle;\">index version</td>\n<td>The index version number. The default index version depends on the version of MongoDB running when creating the index.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">weights</td>\n<td style=\"text-align:center;vertical-align:middle;\">document</td>\n<td>The weight is a number ranging from 1 to 99,999 and denotes the significance of the field relative to the other indexed fields in terms of the score.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">default_language</td>\n<td style=\"text-align:center;vertical-align:middle;\">string</td>\n<td>For a text index, the language that determines the list of stop words and the rules for the stemmer and tokenizer. The default value is <b>english</b>.</td></tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">language_override</td>\n<td style=\"text-align:center;vertical-align:middle;\">string</td>\n<td>For a text index, specify the name of the field in the document that contains, the language to override the default language. The default value is language.</td></tr>\n</table>\n<h1>MongoDB - Aggregation</h1>\n<p>Aggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result. In SQL count(*) and with group by is an equivalent of mongodb aggregation.</p>\n<h2>The aggregate() Method</h2>\n<p>For the aggregation in MongoDB, you should use <b>aggregate()</b> method.</p>\n<h3>Syntax</h3>\n<p>Basic syntax of <b>aggregate()</b> method is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n</pre>\n<h3>Example</h3>\n<p>In the collection you have the following data \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   _id: ObjectId(7df78ad8902c)\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by_user: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100\n},\n{\n   _id: ObjectId(7df78ad8902d)\n   title: 'NoSQL Overview', \n   description: 'No sql database is very fast',\n   by_user: 'tutorials point',\n   url: 'http://www.tutorialspoint.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 10\n},\n{\n   _id: ObjectId(7df78ad8902e)\n   title: 'Neo4j Overview', \n   description: 'Neo4j is no sql database',\n   by_user: 'Neo4j',\n   url: 'http://www.neo4j.com',\n   tags: ['neo4j', 'database', 'NoSQL'],\n   likes: 750\n},\n</pre>\n<p>Now from the above collection, if you want to display a list stating how many tutorials are written by each user, then you will use the following <b>aggregate()</b> method \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt; db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : 1}}}])\n{\n   \"result\" : [\n      {\n         \"_id\" : \"tutorials point\",\n         \"num_tutorial\" : 2\n      },\n      {\n         \"_id\" : \"Neo4j\",\n         \"num_tutorial\" : 1\n      }\n   ],\n   \"ok\" : 1\n}\n&gt;\n</pre>\n<p>Sql equivalent query for the above use case will be <b>select by_user, count(*) from mycol group by by_user</b>.</p>\n<p>In the above example, we have grouped documents by field <b>by_user</b> and on each occurrence of by_user previous value of sum is incremented. Following is a list of available aggregation expressions.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:10%; text-align:center;\">Expression</th>\n<th style=\"width:50%; text-align:center;\">Description</th>\n<th style=\"text-align:center;\">Example</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$sum</td>\n<td>Sums up the defined value from all documents in the collection.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$avg</td>\n<td>Calculates the average of all given values from all documents in the collection.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$min</td>\n<td>Gets the minimum of the corresponding values from all documents in the collection.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$max</td>\n<td>Gets the maximum of the corresponding values from all documents in the collection.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$push</td>\n<td>Inserts the value to an array in the resulting document.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$addToSet</td>\n<td>Inserts the value to an array in the resulting document but does not create duplicates.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$first</td>\n<td>Gets the first document from the source documents according to the grouping. Typically this makes only sense together with some previously applied \u201c$sort\u201d-stage.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}])</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">$last</td>\n<td>Gets the last document from the source documents according to the grouping. Typically this makes only sense together with some previously applied \u201c$sort\u201d-stage.</td>\n<td>db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}])</td></tr>\n</table>\n<h2>Pipeline Concept</h2>\n<p>In UNIX command, shell pipeline means the possibility to execute an operation on some input and use the output as the input for the next command and so on. MongoDB also supports same concept in aggregation framework. There is a set of possible stages and each of those is taken as a set of documents as an input and produces a resulting set of documents (or the final resulting JSON document at the end of the pipeline). This can then in turn be used for the next stage and so on.</p>\n<p>Following are the possible stages in aggregation framework \u2212</p>\n<ul class=\"list\">\n<li><p><b>$project</b> \u2212 Used to select some specific fields from a collection.</p></li>\n<li><p><b>$match</b> \u2212 This is a filtering operation and thus this can reduce the amount of documents that are given as input to the next stage.</p></li>\n<li><p><b>$group</b> \u2212 This does the actual aggregation as discussed above.</p></li>\n<li><p><b>$sort</b> \u2212 Sorts the documents.</p></li>\n<li><p><b>$skip</b> \u2212 With this, it is possible to skip forward in the list of documents for a given amount of documents.</p></li>\n<li><p><b>$limit</b> \u2212 This limits the amount of documents to look at, by the given number starting from the current positions.</p></li>\n<li><p><b>$unwind</b> \u2212 This is used to unwind document that are using arrays. When using an array, the data is kind of pre-joined and this operation will be undone with this to have individual documents again. Thus with this stage we will increase the amount of documents for the next stage.</p></li>\n</ul>\n<h1>MongoDB - Replication</h1>\n<p>Replication is the process of synchronizing data across multiple servers. Replication provides redundancy and increases data availability with multiple copies of data on different database servers. Replication protects a database from the loss of a single server. Replication also allows you to recover from hardware failure and service interruptions. With additional copies of the data, you can dedicate one to disaster recovery, reporting, or backup.</p>\n<h2>Why Replication?</h2>\n<ul class=\"list\">\n<li>To keep your data safe</li>\n<li>High (24*7) availability of data</li>\n<li>Disaster recovery</li>\n<li>No downtime for maintenance (like backups, index rebuilds, compaction)</li>\n<li>Read scaling (extra copies to read from)</li>\n<li>Replica set is transparent to the application</li>\n</ul>\n<h2>How Replication Works in MongoDB</h2>\n<p>MongoDB achieves replication by the use of replica set. A replica set is a group of <b>mongod</b> instances that host the same data set. In a replica, one node is primary node that receives all write operations. All other instances, such as secondaries, apply operations from the primary so that they have the same data set. Replica set can have only one primary node.</p>\n<ul class=\"list\">\n<li><p>Replica set is a group of two or more nodes (generally minimum 3 nodes are required).</p></li>\n<li><p>In a replica set, one node is primary node and remaining nodes are secondary.</p></li>\n<li><p>All data replicates from primary to secondary node.</p></li>\n<li><p>At the time of automatic failover or maintenance, election establishes for primary and a new primary node is elected.</p></li>\n<li><p>After the recovery of failed node, it again join the replica set and works as a secondary node.</p></li>\n</ul>\n<p>A typical diagram of MongoDB replication is shown in which client application always interact with the primary node and the primary node then replicates the data to the secondary nodes.</p>\n<img alt=\"MongoDB Replication\" src=\"/mongodb/images/replication.png\"/>\n<h2>Replica Set Features</h2>\n<ul class=\"list\">\n<li>A cluster of N nodes</li>\n<li>Any one node can be primary</li>\n<li>All write operations go to primary</li>\n<li>Automatic failover</li>\n<li>Automatic recovery</li>\n<li>Consensus election of primary</li>\n</ul>\n<h2>Set Up a Replica Set</h2>\n<p>In this tutorial, we will convert standalone MongoDB instance to a replica set. To convert to replica set, following are the steps \u2212</p>\n<ul class=\"list\">\n<li><p>Shutdown already running MongoDB server.</p></li>\n<li>\n<li><p>Start the MongoDB server by specifying -- replSet option. Following is the basic syntax of --replSet \u2212</p></li>\n</li></ul>\n<pre class=\"result notranslate\">\nmongod --port \"PORT\" --dbpath \"YOUR_DB_DATA_PATH\" --replSet \"REPLICA_SET_INSTANCE_NAME\"\n</pre>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\nmongod --port 27017 --dbpath \"D:\\set up\\mongodb\\data\" --replSet rs0\n</pre>\n<ul class=\"list\">\n<li><p>It will start a mongod instance with the name rs0, on port 27017.</p></li>\n<li><p>Now start the command prompt and connect to this mongod instance.</p></li>\n<li><p>In Mongo client, issue the command <b>rs.initiate()</b> to initiate a new replica set.</p></li>\n<li><p>To check the replica set configuration, issue the command <b>rs.conf()</b>. To check the status of replica set issue the command <b>rs.status()</b>.</p></li>\n</ul>\n<h2>Add Members to Replica Set</h2>\n<p>To add members to replica set, start mongod instances on multiple machines. Now start a mongo client and issue a command <b>rs.add()</b>.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>rs.add()</b> command is as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;rs.add(HOST_NAME:PORT)\n</pre>\n<h3>Example</h3>\n<p>Suppose your mongod instance name is <b>mongod1.net</b> and it is running on port <b>27017</b>. To add this instance to replica set, issue the command <b>rs.add()</b> in Mongo client.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;rs.add(\"mongod1.net:27017\")\n&gt;\n</pre>\n<p>You can add mongod instance to replica set only when you are connected to primary node. To check whether you are connected to primary or not, issue the command <b>db.isMaster()</b> in mongo client.</p>\n<h1>MongoDB - Sharding</h1>\n<p>Sharding is the process of storing data records across multiple machines and it is MongoDB's approach to meeting the demands of data growth. As the size of the data increases, a single machine may not be sufficient to store the data nor provide an acceptable read and write throughput. Sharding solves the problem with horizontal scaling. With sharding, you add more machines to support data growth and the demands of read and write operations.</p>\n<h2>Why Sharding?</h2>\n<ul class=\"list\">\n<li>In replication, all writes go to master node</li>\n<li>Latency sensitive queries still go to master</li>\n<li>Single replica set has limitation of 12 nodes</li>\n<li>Memory can't be large enough when active dataset is big</li>\n<li>Local disk is not big enough</li>\n<li>Vertical scaling is too expensive</li>\n</ul>\n<h2>Sharding in MongoDB</h2>\n<p>The following diagram shows the sharding in MongoDB using sharded cluster.</p>\n<img alt=\"MongoDB Sharding\" src=\"/mongodb/images/sharding.png\"/>\n<p>In the following diagram, there are three main components \u2212</p>\n<ul class=\"list\">\n<li><p><b>Shards</b> \u2212 Shards are used to store data. They provide high availability and data consistency. In production environment, each shard is a separate replica set.</p></li>\n<li><p><b>Config Servers</b> \u2212 Config servers store the cluster's metadata. This data contains a mapping of the cluster's data set to the shards. The query router uses this metadata to target operations to specific shards. In production environment, sharded clusters have exactly 3 config servers.</p></li>\n<li><p><b>Query Routers</b> \u2212 Query routers are basically mongo instances, interface with client applications and direct operations to the appropriate shard. The query router processes and targets the operations to shards and then returns results to the clients. A sharded cluster can contain more than one query router to divide the client request load. A client sends requests to one query router. Generally, a sharded cluster have many query routers.</p></li>\n</ul>\n<h1>MongoDB - Create Backup</h1>\n<p>In this chapter, we will see how to create a backup in MongoDB.</p>\n<h2>Dump MongoDB Data</h2>\n<p>To create backup of database in MongoDB, you should use <b>mongodump</b> command. This command will dump the entire data of your server into the dump directory. There are many options available by which you can limit the amount of data or create backup of your remote server.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>mongodump</b> command is as follows \u2212</p>\n<pre class=\"result notranslate\">\n&gt;mongodump\n</pre>\n<h3>Example</h3>\n<p>Start your mongod server. Assuming that your mongod server is running on the localhost and port 27017, open a command prompt and go to the bin directory of your mongodb instance and type the command <b>mongodump</b></p>\n<p>Consider the mycol collection has the following data.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;mongodump\n</pre>\n<p>The command will connect to the server running at <b>127.0.0.1</b> and port <b>27017</b> and back all data of the server to directory <b>/bin/dump/</b>. Following is the output of the command \u2212</p>\n<img alt=\"DB Stats\" src=\"/mongodb/images/mongodump.png\"/>\n<p>Following is a list of available options that can be used with the <b>mongodump</b> command.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:40%;\">Syntax</th>\n<th style=\"width:30%;\">Description</th>\n<th>Example</th>\n</tr>\n<tr>\n<td>mongodump --host HOST_NAME --port PORT_NUMBER</td>\n<td>This commmand will backup all databases of specified mongod instance.</td>\n<td>mongodump --host tutorialspoint.com --port 27017</td></tr>\n<tr>\n<td>mongodump --dbpath DB_PATH --out BACKUP_DIRECTORY</td>\n<td>This command will backup only specified database at specified path.</td>\n<td>mongodump --dbpath /data/db/ --out /data/backup/</td></tr>\n<tr>\n<td>mongodump --collection COLLECTION --db DB_NAME</td>\n<td>This command will backup only specified collection of specified database.</td>\n<td>mongodump --collection mycol --db test</td></tr>\n</table>\n<h2>Restore data</h2>\n<p>To restore backup data MongoDB's <b>mongorestore</b> command is used. This command restores all of the data from the backup directory.</p>\n<h3>Syntax</h3>\n<p>The basic syntax of <b>mongorestore</b> command is \u2212</p>\n<pre class=\"result notranslate\">\n&gt;mongorestore\n</pre>\n<p>Following is the output of the command \u2212</p>\n<img alt=\"DB Stats\" src=\"/mongodb/images/mongorestore.png\"/>\n<h1>MongoDB - Deployment</h1>\n<p>When you are preparing a MongoDB deployment, you should try to understand how your application is going to hold up in production. It\u2019s a good idea to develop a consistent, repeatable approach to managing your deployment environment so that you can minimize any surprises once you\u2019re in production.</p>\n<p>The best approach incorporates prototyping your set up, conducting load testing, monitoring key metrics, and using that information to scale your set up. The key part of the approach is to proactively monitor your entire system - this will help you understand how your production system will hold up before deploying, and determine where you will need to add capacity. Having insight into potential spikes in your memory usage, for example, could help put out a write-lock fire before it starts.</p>\n<p>To monitor your deployment, MongoDB provides some of the following commands \u2212</p>\n<h2>mongostat</h2>\n<p>This command checks the status of all running mongod instances and return counters of database operations. These counters include inserts, queries, updates, deletes, and cursors. Command also shows when you\u2019re hitting page faults, and showcase your lock percentage. This means that you're running low on memory, hitting write capacity or have some performance issue.</p>\n<p>To run the command, start your mongod instance. In another command prompt, go to <b>bin</b> directory of your mongodb installation and type <b>mongostat</b>.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongostat\n</pre>\n<p>Following is the output of the command \u2212</p>\n<img alt=\"mongostat\" src=\"/mongodb/images/mongostat.png\"/>\n<h2>mongotop</h2>\n<p>This command tracks and reports the read and write activity of MongoDB instance on a collection basis. By default, <b>mongotop</b> returns information in each second, which you can change it accordingly. You should check that this read and write activity matches your application intention, and you\u2019re not firing too many writes to the database at a time, reading too frequently from a disk, or are exceeding your working set size.</p>\n<p>To run the command, start your mongod instance. In another command prompt, go to <b>bin</b> directory of your mongodb installation and type <b>mongotop</b>.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongotop\n</pre>\n<p>Following is the output of the command \u2212</p>\n<img alt=\"mongotop\" src=\"/mongodb/images/mongotop.png\"/>\n<p>To change <b>mongotop</b> command to return information less frequently, specify a specific number after the mongotop command.</p>\n<pre class=\"result notranslate\">\nD:\\set up\\mongodb\\bin&gt;mongotop 30\n</pre>\n<p>The above example will return values every 30 seconds.</p>\n<p>Apart from the MongoDB tools, 10gen provides a free, hosted monitoring service, MongoDB Management Service (MMS), that provides a dashboard and gives you a view of the metrics from your entire cluster.</p>\n<h1>MongoDB - Java</h1>\n<p>In this chapter, we will learn how to set up MongoDB JDBC driver.</p>\n<h2>Installation</h2>\n<p>Before you start using MongoDB in your Java programs, you need to make sure that you have MongoDB JDBC driver and Java set up on the machine. You can check Java tutorial for Java installation on your machine. Now, let us check how to set up MongoDB JDBC driver.</p>\n<ul class=\"list\">\n<li><p>You need to download the jar from the path <a href=\"https://github.com/mongodb/mongo-java-driver/downloads\" rel=\"nofollow\" target=\"_blank\">Download mongo.jar</a>. Make sure to download the latest release of it.</p></li>\n<li><p>You need to include the mongo.jar into your classpath.</p></li>\n</ul>\n<h2>Connect to Database</h2>\n<p>To connect database, you need to specify the database name, if the database doesn't exist then MongoDB creates it automatically.</p>\n<p>Following is the code snippet to connect to the database \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class ConnectToDB { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n   \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n      System.out.println(\"Credentials ::\"+ credential);     \n   } \n}\n</pre>\n<p>Now, let's compile and run the above program to create our database myDb as shown below.</p>\n<pre class=\"result notranslate\">\n$javac ConnectToDB.java \n$java ConnectToDB\n</pre>\n<p>On executing, the above program gives you the following output.</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCredentials ::MongoCredential{\n   mechanism = null, \n   userName = 'sampleUser', \n   source = 'myDb', \n   password = &lt;hidden&gt;, \n   mechanismProperties = {}\n}\n</pre>\n<h2>Create a Collection</h2>\n<p>To create a collection, <b>createCollection()</b> method of <b>com.mongodb.client.MongoDatabase</b> class is used.</p>\n<p>Following is the code snippet to create a collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class CreatingCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      //Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      //Creating a collection \n      database.createCollection(\"sampleCollection\"); \n      System.out.println(\"Collection created successfully\"); \n   } \n} \n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection created successfully\n</pre>\n<h2>Getting/Selecting a Collection</h2>\n<p>To get/select a collection from the database, <b>getCollection()</b> method of <b>com.mongodb.client.MongoDatabase</b> class is used.</p>\n<p>Following is the program to get/select a collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \n\nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class selectingCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Creating a collection \n      System.out.println(\"Collection created successfully\"); \n\n      // Retieving a collection\n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"myCollection\"); \n      System.out.println(\"Collection myCollection selected successfully\"); \n   }\n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection created successfully \nCollection myCollection selected successfully\n</pre>\n<h2>Insert a Document</h2>\n<p>To insert a document into MongoDB, <b>insert()</b> method of <b>com.mongodb.client.MongoCollection</b> class is used.</p>\n<p>Following is the code snippet to insert a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \n\nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class InsertingDocument { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection\n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\"); \n      System.out.println(\"Collection sampleCollection selected successfully\");\n\n      Document document = new Document(\"title\", \"MongoDB\") \n      .append(\"id\", 1)\n      .append(\"description\", \"database\") \n      .append(\"likes\", 100) \n      .append(\"url\", \"http://www.tutorialspoint.com/mongodb/\") \n      .append(\"by\", \"tutorials point\");  \n      collection.insertOne(document); \n      System.out.println(\"Document inserted successfully\");     \n   } \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection sampleCollection selected successfully \nDocument inserted successfully\n</pre>\n<h2>Retrieve All Documents</h2>\n<p>To select all documents from the collection, <b>find()</b> method of <b>com.mongodb.client.MongoCollection</b> class is used. This method returns a cursor, so you need to iterate this cursor.</p>\n<p>Following is the program to select all documents \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase;  \n\nimport java.util.Iterator; \nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class RetrievingAllDocuments { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential;\n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Retrieving a collection \n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection sampleCollection selected successfully\"); \n\n      // Getting the iterable object \n      FindIterable&lt;Document&gt; iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n    \n      while (it.hasNext()) {  \n         System.out.println(it.next());  \n      i++; \n      }\n   } \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nDocument{{\n   _id = 5967745223993a32646baab8, \n   title = MongoDB, \n   id = 1, \n   description = database, \n   likes = 100, \n   url = http://www.tutorialspoint.com/mongodb/, by = tutorials point\n}}  \nDocument{{\n   _id = 7452239959673a32646baab8, \n   title = RethinkDB, \n   id = 2, \n   description = database, \n   likes = 200, \n   url = http://www.tutorialspoint.com/rethinkdb/, by = tutorials point\n}}\n</pre>\n<h2>Update Document</h2>\n<p>To update a document from the collection, <b>updateOne()</b> method of <b>com.mongodb.client.MongoCollection</b> class is used.</p>\n<p>Following is the program to select the first document \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.client.model.Filters; \nimport com.mongodb.client.model.Updates; \n\nimport java.util.Iterator; \nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class UpdatingDocuments { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n     \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection \n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection myCollection selected successfully\"); \n\n      collection.updateOne(Filters.eq(\"id\", 1), Updates.set(\"likes\", 150));       \n      System.out.println(\"Document update successfully...\");  \n      \n      // Retrieving the documents after updation \n      // Getting the iterable object\n      FindIterable&lt;Document&gt; iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n\n      while (it.hasNext()) {  \n         System.out.println(it.next());  \n         i++; \n      }     \n   }  \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nDocument update successfully... \nDocument {{\n   _id = 5967745223993a32646baab8, \n   title = MongoDB, \n   id = 1, \n   description = database, \n   likes = 150, \n   url = http://www.tutorialspoint.com/mongodb/, by = tutorials point\n}}\n</pre>\n<h2>Delete a Document</h2>\n<p>To delete a document from the collection, you need to use the <b>deleteOne()</b> method of the <b>com.mongodb.client.MongoCollection</b> class.</p>\n<p>Following is the program to delete a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.FindIterable; \nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.client.model.Filters;  \n\nimport java.util.Iterator; \nimport org.bson.Document; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class DeletingDocuments { \n   \n   public static void main( String args[] ) {  \n   \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 );\n      \n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n\n      // Retrieving a collection\n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\");\n      System.out.println(\"Collection sampleCollection selected successfully\"); \n\n      // Deleting the documents \n      collection.deleteOne(Filters.eq(\"id\", 1)); \n      System.out.println(\"Document deleted successfully...\");  \n      \n      // Retrieving the documents after updation \n      // Getting the iterable object \n      FindIterable&lt;Document&gt; iterDoc = collection.find(); \n      int i = 1; \n\n      // Getting the iterator \n      Iterator it = iterDoc.iterator(); \n\n      while (it.hasNext()) {  \n         System.out.println(\"Inserted Document: \"+i);  \n         System.out.println(it.next());  \n         i++; \n      }       \n   } \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection sampleCollection selected successfully \nDocument deleted successfully...\n</pre>\n<h2>Dropping a Collection</h2>\n<p>To drop a collection from a database, you need to use the <b>drop()</b> method of the <b>com.mongodb.client.MongoCollection</b> class.</p>\n<p>Following is the program to delete a collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoCollection; \nimport com.mongodb.client.MongoDatabase;  \n\nimport org.bson.Document;  \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class DropingCollection { \n   \n   public static void main( String args[] ) {  \n\n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\");  \n      \n      // Creating a collection \n      System.out.println(\"Collections created successfully\"); \n\n      // Retieving a collection\n      MongoCollection&lt;Document&gt; collection = database.getCollection(\"sampleCollection\");\n\n      // Dropping a Collection \n      collection.drop(); \n      System.out.println(\"Collection dropped successfully\");\n   } \n}\n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection sampleCollection selected successfully \nCollection dropped successfully\n</pre>\n<h2>Listing All the Collections</h2>\n<p>To list all the collections in a database, you need to use the <b>listCollectionNames()</b>  method of the <b>com.mongodb.client.MongoDatabase</b> class.</p>\n<p>Following is the program to list all the collections of a database \u2212</p>\n<pre class=\"prettyprint notranslate\">\nimport com.mongodb.client.MongoDatabase; \nimport com.mongodb.MongoClient; \nimport com.mongodb.MongoCredential;  \n\npublic class ListOfCollection { \n   \n   public static void main( String args[] ) {  \n      \n      // Creating a Mongo client \n      MongoClient mongo = new MongoClient( \"localhost\" , 27017 ); \n\n      // Creating Credentials \n      MongoCredential credential; \n      credential = MongoCredential.createCredential(\"sampleUser\", \"myDb\", \n         \"password\".toCharArray()); \n\n      System.out.println(\"Connected to the database successfully\");  \n      \n      // Accessing the database \n      MongoDatabase database = mongo.getDatabase(\"myDb\"); \n      System.out.println(\"Collection created successfully\"); \n      for (String name : database.listCollectionNames()) { \n         System.out.println(name); \n      } \n   }\n} \n</pre>\n<p>On compiling, the above program gives you the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnected to the database successfully \nCollection created successfully \nmyCollection \nmyCollection1 \nmyCollection5\n</pre>\n<p>Remaining MongoDB methods <b>save(), limit(), skip(), sort()</b> etc. work same as explained in the subsequent tutorial.</p>\n<h1>MongoDB - PHP</h1>\n<p>To use MongoDB with PHP, you need to use MongoDB PHP driver. Download the driver from the url <a href=\"https://s3.amazonaws.com/drivers.mongodb.org/php/index.html\" rel=\"nofollow\" target=\"_blank\">Download PHP Driver</a>. Make sure to download the latest release of it. Now unzip the archive and put php_mongo.dll in your PHP extension directory (\"ext\" by default) and add the following line to your php.ini file \u2212</p>\n<pre class=\"result notranslate\">\nextension = php_mongo.dll\n</pre>\n<h2>Make a Connection and Select a Database</h2>\n<p>To make a connection, you need to specify the database name, if the database doesn't exist then MongoDB creates it automatically.</p>\n<p>Following is the code snippet to connect to the database \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n\t\n   echo \"Connection to database successfully\";\n   // select a database\n   $db = $m-&gt;mydb;\n\t\n   echo \"Database mydb selected\";\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\n</pre>\n<h2>Create a Collection</h2>\n<p>Following is the code snippet to create a collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;createCollection(\"mycol\");\n   echo \"Collection created succsessfully\";\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection created succsessfully\n</pre>\n<h2>Insert a Document</h2>\n<p>To insert a document into MongoDB, <b>insert()</b> method is used.</p>\n<p>Following is the code snippet to insert a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;mycol;\n   echo \"Collection selected succsessfully\";\n\t\n   $document = array( \n      \"title\" =&gt; \"MongoDB\", \n      \"description\" =&gt; \"database\", \n      \"likes\" =&gt; 100,\n      \"url\" =&gt; \"http://www.tutorialspoint.com/mongodb/\",\n      \"by\" =&gt; \"tutorials point\"\n   );\n\t\n   $collection-&gt;insert($document);\n   echo \"Document inserted successfully\";\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocument inserted successfully\n</pre>\n<h2>Find All Documents</h2>\n<p>To select all documents from the collection, find() method is used.</p>\n<p>Following is the code snippet to select all documents \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;mycol;\n   echo \"Collection selected succsessfully\";\n\n   $cursor = $collection-&gt;find();\n   // iterate cursor to display title of documents\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully {\n   \"title\": \"MongoDB\"\n}\n</pre>\n<h2>Update a Document</h2>\n<p>To update a document, you need to use the update() method.</p>\n<p>In the following example, we will update the title of inserted document to <b>MongoDB Tutorial</b>. Following is the code snippet to update a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;mycol;\n   echo \"Collection selected succsessfully\";\n\n   // now update the document\n   $collection-&gt;update(array(\"title\"=&gt;\"MongoDB\"), \n      array('$set'=&gt;array(\"title\"=&gt;\"MongoDB Tutorial\")));\n   echo \"Document updated successfully\";\n\t\n   // now display the updated document\n   $cursor = $collection-&gt;find();\n\t\n   // iterate cursor to display title of documents\n   echo \"Updated document\";\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocument updated successfully\nUpdated document {\n   \"title\": \"MongoDB Tutorial\"\n}\n</pre>\n<h2>Delete a Document</h2>\n<p>To delete a document, you need to use remove() method.</p>\n<p>In the following example, we will remove the documents that has the title <b>MongoDB Tutorial</b>. Following is the code snippet to delete a document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&lt;?php\n   // connect to mongodb\n   $m = new MongoClient();\n   echo \"Connection to database successfully\";\n\t\n   // select a database\n   $db = $m-&gt;mydb;\n   echo \"Database mydb selected\";\n   $collection = $db-&gt;mycol;\n   echo \"Collection selected succsessfully\";\n   \n   // now remove the document\n   $collection-&gt;remove(array(\"title\"=&gt;\"MongoDB Tutorial\"),false);\n   echo \"Documents deleted successfully\";\n   \n   // now display the available documents\n   $cursor = $collection-&gt;find();\n\t\n   // iterate cursor to display title of documents\n   echo \"Updated document\";\n\t\n   foreach ($cursor as $document) {\n      echo $document[\"title\"] . \"\\n\";\n   }\n?&gt;\n</pre>\n<p>When the program is executed, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nConnection to database successfully\nDatabase mydb selected\nCollection selected succsessfully\nDocuments deleted successfully\n</pre>\n<p>In the above example, the second parameter is boolean type and used for <b>justOne</b> field of <b>remove()</b> method.</p>\n<p>Remaining MongoDB methods <b>findOne(), save(), limit(), skip(), sort()</b> etc. works same as explained above.</p>\n<h1>MongoDB - Relationships</h1>\n<p>Relationships in MongoDB represent how various documents are logically related to each other. Relationships can be modeled via <b>Embedded</b> and <b>Referenced</b> approaches. Such relationships can be either 1:1, 1:N, N:1 or N:N.</p>\n<p>Let us consider the case of storing addresses for users. So, one user can have multiple addresses making this a 1:N relationship.</p>\n<p>Following is the sample document structure of <b>user</b> document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"name\": \"Tom Hanks\",\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\"\n}\n</pre>\n<p>Following is the sample document structure of <b>address</b> document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"52ffc4a5d85242602e000000\"),\n   \"building\": \"22 A, Indiana Apt\",\n   \"pincode\": 123456,\n   \"city\": \"Los Angeles\",\n   \"state\": \"California\"\n} \n</pre>\n<h2>Modeling Embedded Relationships</h2>\n<p>In the embedded approach, we will embed the address document inside the user document.</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\",\n   \"address\": [\n      {\n         \"building\": \"22 A, Indiana Apt\",\n         \"pincode\": 123456,\n         \"city\": \"Los Angeles\",\n         \"state\": \"California\"\n      },\n      {\n         \"building\": \"170 A, Acropolis Apt\",\n         \"pincode\": 456789,\n         \"city\": \"Chicago\",\n         \"state\": \"Illinois\"\n      }\n   ]\n} \n</pre>\n<p>This approach maintains all the related data in a single document, which makes it easy to retrieve and maintain. The whole document can be retrieved in a single query such as \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address\":1})\n</pre>\n<p>Note that in the above query, <b>db</b> and <b>users</b> are the database and collection respectively.</p>\n<p>The drawback is that if the embedded document keeps on growing too much in size, it can impact the read/write performance.</p>\n<h2>Modeling Referenced Relationships</h2>\n<p>This is the approach of designing normalized relationship. In this approach, both the user and address documents will be maintained separately but the user document will contain a field that will reference the address document's <b>id</b> field.</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"52ffc33cd85242f436000001\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\",\n   \"address_ids\": [\n      ObjectId(\"52ffc4a5d85242602e000000\"),\n      ObjectId(\"52ffc4a5d85242602e000001\")\n   ]\n}\n</pre>\n<p>As shown above, the user document contains the array field <b>address_ids</b> which contains ObjectIds of corresponding addresses. Using these ObjectIds, we can query the address documents and get address details from there. With this approach, we will need two queries: first to fetch the <b>address_ids</b> fields from <b>user</b> document and second to fetch these addresses from <b>address</b> collection.</p>\n<pre class=\"result notranslate\">\n&gt;var result = db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address_ids\":1})\n&gt;var addresses = db.address.find({\"_id\":{\"$in\":result[\"address_ids\"]}})\n</pre>\n<h1>MongoDB - Database References</h1>\n<p>As seen in the last chapter of MongoDB relationships, to implement a normalized database structure in MongoDB, we use the concept of <b>Referenced Relationships</b> also referred to as <b>Manual References</b> in which we manually store the referenced document's id inside other document. However, in cases where a document contains references from different collections, we can use <b>MongoDB DBRefs</b>.</p>\n<h2>DBRefs vs Manual References</h2>\n<p>As an example scenario, where we would use DBRefs instead of manual references, consider a database where we are storing different types of addresses (home, office, mailing, etc.) in different collections (address_home, address_office, address_mailing, etc). Now, when a <b>user</b> collection's document references an address, it also needs to specify which collection to look into based on the address type. In such scenarios where a document references documents from many collections, we should use DBRefs.</p>\n<h2>Using DBRefs</h2>\n<p>There are three fields in DBRefs \u2212</p>\n<ul class=\"list\">\n<li><p><b>$ref</b> \u2212 This field specifies the collection of the referenced document</p></li>\n<li><p><b>$id</b> \u2212 This field specifies the _id field of the referenced document</p></li>\n<li><p><b>$db</b> \u2212 This is an optional field and contains the name of the database in which the referenced document lies</p></li>\n</ul>\n<p>Consider a sample user document having DBRef field <b>address</b> as shown in the code snippet \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":ObjectId(\"53402597d852426020000002\"),\n   \"address\": {\n   \"$ref\": \"address_home\",\n   \"$id\": ObjectId(\"534009e4d852427820000002\"),\n   \"$db\": \"tutorialspoint\"},\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"name\": \"Tom Benzamin\"\n}\n</pre>\n<p>The <b>address</b> DBRef field here specifies that the referenced address document lies in <b>address_home</b> collection under <b>tutorialspoint</b> database and has an id of 534009e4d852427820000002.</p>\n<p>The following code dynamically looks in the collection specified by <b>$ref</b> parameter (<b>address_home</b> in our case) for a document with id as specified by <b>$id</b> parameter in DBRef.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;var user = db.users.findOne({\"name\":\"Tom Benzamin\"})\n&gt;var dbRef = user.address\n&gt;db[dbRef.$ref].findOne({\"_id\":(dbRef.$id)})\n</pre>\n<p>The above code returns the following address document present in <b>address_home</b> collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\" : ObjectId(\"534009e4d852427820000002\"),\n   \"building\" : \"22 A, Indiana Apt\",\n   \"pincode\" : 123456,\n   \"city\" : \"Los Angeles\",\n   \"state\" : \"California\"\n}\n</pre>\n<h1>MongoDB - Covered Queries</h1>\n<p>In this chapter, we will learn about covered queries.</p>\n<h2>What is a Covered Query?</h2>\n<p>As per the official MongoDB documentation, a covered query is a query in which \u2212</p>\n<ul class=\"list\">\n<li>All the fields in the query are part of an index.</li>\n<li>All the fields returned in the query are in the same index.</li>\n</ul>\n<p>Since all the fields present in the query are part of an index, MongoDB matches the query conditions and returns the result using the same index without actually looking inside the documents. Since indexes are present in RAM, fetching data from indexes is much faster as compared to fetching data by scanning documents.</p>\n<h2>Using Covered Queries</h2>\n<p>To test covered queries, consider the following document in the <b>users</b> collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\": ObjectId(\"53402597d852426020000002\"),\n   \"contact\": \"987654321\",\n   \"dob\": \"01-01-1991\",\n   \"gender\": \"M\",\n   \"name\": \"Tom Benzamin\",\n   \"user_name\": \"tombenzamin\"\n}\n</pre>\n<p>We will first create a compound index for the <b>users</b> collection on the fields <b>gender</b> and <b>user_name</b> using the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.ensureIndex({gender:1,user_name:1})\n</pre>\n<p>Now, this index will cover the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1,_id:0})\n</pre>\n<p>That is to say that for the above query, MongoDB would not go looking into database documents. Instead it would fetch the required data from indexed data which is very fast.</p>\n<p>Since our index does not include <b>_id</b> field, we have explicitly excluded it from result set of our query, as MongoDB by default returns _id field in every query. So the following query would not have been covered inside the index created above \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1})\n</pre>\n<p>Lastly, remember that an index cannot cover a query if \u2212</p>\n<ul class=\"list\">\n<li>Any of the indexed fields is an array</li>\n<li>Any of the indexed fields is a subdocument</li>\n</ul>\n<h1>MongoDB - Analyzing Queries</h1>\n<p>Analyzing queries is a very important aspect of measuring how effective the database and indexing design is. We will learn about the frequently used <b>$explain</b> and <b>$hint</b> queries.</p>\n<h2>Using $explain</h2>\n<p>The <b>$explain</b> operator provides information on the query, indexes used in a query and other statistics. It is very useful when analyzing how well your indexes are optimized.</p>\n<p>In the last chapter, we had already created an index for the <b>users</b> collection on fields <b>gender</b> and <b>user_name</b> using the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.ensureIndex({gender:1,user_name:1})\n</pre>\n<p>We will now use <b>$explain</b> on the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1,_id:0}).explain()\n</pre>\n<p>The above explain() query returns the following analyzed result \u2212</p>\n<pre class=\"result notranslate\">\n{\n   \"cursor\" : \"BtreeCursor gender_1_user_name_1\",\n   \"isMultiKey\" : false,\n   \"n\" : 1,\n   \"nscannedObjects\" : 0,\n   \"nscanned\" : 1,\n   \"nscannedObjectsAllPlans\" : 0,\n   \"nscannedAllPlans\" : 1,\n   \"scanAndOrder\" : false,\n   \"indexOnly\" : true,\n   \"nYields\" : 0,\n   \"nChunkSkips\" : 0,\n   \"millis\" : 0,\n   \"indexBounds\" : {\n      \"gender\" : [\n         [\n            \"M\",\n            \"M\"\n         ]\n      ],\n      \"user_name\" : [\n         [\n            {\n               \"$minElement\" : 1\n            },\n            {\n               \"$maxElement\" : 1\n            }\n         ]\n      ]\n   }\n}\n</pre>\n<p>We will now look at the fields in this result set \u2212</p>\n<ul class=\"list\">\n<li><p>The true value of <b>indexOnly</b> indicates that this query has used indexing.</p></li>\n<li><p>The <b>cursor</b> field specifies the type of cursor used. BTreeCursor type indicates that an index was used and also gives the name of the index used. BasicCursor indicates that a full scan was made without using any indexes.</p></li>\n<li><p><b>n</b> indicates the number of documents matching returned.</p></li>\n<li><p><b>nscannedObjects</b> indicates the total number of documents scanned.</p></li>\n<li><p><b>nscanned</b> indicates the total number of documents or index entries scanned.</p></li>\n</ul>\n<h2>Using $hint</h2>\n<p>The <b>$hint</b> operator forces the query optimizer to use the specified index to run a query. This is particularly useful when you want to test performance of a query with different indexes. For example, the following query specifies the index on fields <b>gender</b> and <b>user_name</b> to be used for this query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1,_id:0}).hint({gender:1,user_name:1})\n</pre>\n<p>To analyze the above query using $explain \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({gender:\"M\"},{user_name:1,_id:0}).hint({gender:1,user_name:1}).explain()\n</pre>\n<h1>MongoDB - Atomic Operations</h1>\n<p>MongoDB does not support <b>multi-document atomic transactions</b>. However, it does provide atomic operations on a single document. So if a document has hundred fields the update statement will either update all the fields or none, hence maintaining atomicity at the document-level.</p>\n<h2>Model Data for Atomic Operations</h2>\n<p>The recommended approach to maintain atomicity would be to keep all the related information, which is frequently updated together in a single document using <b>embedded documents</b>. This would make sure that all the updates for a single document are atomic.</p>\n<p>Consider the following products document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\":1,\n   \"product_name\": \"Samsung S3\",\n   \"category\": \"mobiles\",\n   \"product_total\": 5,\n   \"product_available\": 3,\n   \"product_bought_by\": [\n      {\n         \"customer\": \"john\",\n         \"date\": \"7-Jan-2014\"\n      },\n      {\n         \"customer\": \"mark\",\n         \"date\": \"8-Jan-2014\"\n      }\n   ]\n}\n</pre>\n<p>In this document, we have embedded the information of the customer who buys the product in the <b>product_bought_by</b> field. Now, whenever a new customer buys the product, we will first check if the product is still available using <b>product_available</b> field. If available, we will reduce the value of product_available field as well as insert the new customer's embedded document in the product_bought_by field. We will use <b>findAndModify</b> command for this functionality because it searches and updates the document in the same go.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.products.findAndModify({ \n   query:{_id:2,product_available:{$gt:0}}, \n   update:{ \n      $inc:{product_available:-1}, \n      $push:{product_bought_by:{customer:\"rob\",date:\"9-Jan-2014\"}} \n   }    \n})\n</pre>\n<p>Our approach of embedded document and using findAndModify query makes sure that the product purchase information is updated only if it the product is available. And the whole of this transaction being in the same query, is atomic.</p>\n<p>In contrast to this, consider the scenario where we may have kept the product availability and the information on who has bought the product, separately. In this case, we will first check if the product is available using the first query. Then in the second query we will update the purchase information. However, it is possible that between the executions of these two queries, some other user has purchased the product and it is no more available. Without knowing this, our second query will update the purchase information based on the result of our first query. This will make the database inconsistent because we have sold a product which is not available.</p>\n<h1>MongoDB - Advanced Indexing</h1>\n<p>Consider the following document of the <b>users</b> collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"address\": {\n      \"city\": \"Los Angeles\",\n      \"state\": \"California\",\n      \"pincode\": \"123\"\n   },\n   \"tags\": [\n      \"music\",\n      \"cricket\",\n      \"blogs\"\n   ],\n   \"name\": \"Tom Benzamin\"\n}\n</pre>\n<p>The above document contains an <b>address sub-document</b> and a <b>tags array</b>.</p>\n<h2>Indexing Array Fields</h2>\n<p>Suppose we want to search user documents based on the user\u2019s tags. For this, we will create an index on tags array in the collection.</p>\n<p>Creating an index on array in turn creates separate index entries for each of its fields. So in our case when we create an index on tags array, separate indexes will be created for its values music, cricket and blogs.</p>\n<p>To create an index on tags array, use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.ensureIndex({\"tags\":1})\n</pre>\n<p>After creating the index, we can search on the tags field of the collection like this \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({tags:\"cricket\"})\n</pre>\n<p>To verify that proper indexing is used, use the following <b>explain</b> command \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({tags:\"cricket\"}).explain()\n</pre>\n<p>The above command resulted in \"cursor\" : \"BtreeCursor tags_1\" which confirms that proper indexing is used.</p>\n<h2>Indexing Sub-Document Fields</h2>\n<p>Suppose that we want to search documents based on city, state and pincode fields. Since all these fields are part of address sub-document field, we will create an index on all the fields of the sub-document.</p>\n<p>For creating an index on all the three fields of the sub-document, use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.ensureIndex({\"address.city\":1,\"address.state\":1,\"address.pincode\":1})\n</pre>\n<p>Once the index is created, we can search for any of the sub-document fields utilizing this index as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({\"address.city\":\"Los Angeles\"})   \n</pre>\n<p>Remember that the query expression has to follow the order of the index specified. So the index created above would support the following queries \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({\"address.city\":\"Los Angeles\",\"address.state\":\"California\"}) \n</pre>\n<p>It will also support the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.users.find({\"address.city\":\"LosAngeles\",\"address.state\":\"California\",\n   \"address.pincode\":\"123\"})\n</pre>\n<h1>MongoDB - Indexing Limitations</h1>\n<p>In this chapter, we will learn about Indexing Limitations and its other components.</p>\n<h2>Extra Overhead</h2>\n<p>Every index occupies some space as well as causes an overhead on each insert, update and delete. So if you rarely use your collection for read operations, it makes sense not to use indexes.</p>\n<h2>RAM Usage</h2>\n<p>Since indexes are stored in RAM, you should make sure that the total size of the index does not exceed the RAM limit. If the total size increases the RAM size, it will start deleting some indexes, causing performance loss.</p>\n<h2>Query Limitations</h2>\n<p>Indexing can't be used in queries which use \u2212</p>\n<ul class=\"list\">\n<li>Regular expressions or negation operators like $nin, $not, etc.</li>\n<li>Arithmetic operators like $mod, etc.</li>\n<li>$where clause</li>\n</ul>\n<p>Hence, it is always advisable to check the index usage for your queries.</p>\n<h2>Index Key Limits</h2>\n<p>Starting from version 2.6, MongoDB will not create an index if the value of existing index field exceeds the index key limit.</p>\n<h2>Inserting Documents Exceeding Index Key Limit</h2>\n<p>MongoDB will not insert any document into an indexed collection if the indexed field value of this document exceeds the index key limit. Same is the case with mongorestore and mongoimport utilities.</p>\n<h2>Maximum Ranges</h2>\n<ul class=\"list\">\n<li>A collection cannot have more than 64 indexes.</li>\n<li>The length of the index name cannot be longer than 125 characters.</li>\n<li>A compound index can have maximum 31 fields indexed.</li>\n</ul>\n<h1>MongoDB - ObjectId</h1>\n<p>We have been using MongoDB Object Id in all the previous chapters. In this chapter, we will understand the structure of ObjectId.</p>\n<p>An <b>ObjectId</b> is a 12-byte BSON type having the following structure \u2212</p>\n<ul class=\"list\">\n<li>The first 4 bytes representing the seconds since the unix epoch</li>\n<li>The next 3 bytes are the machine identifier</li>\n<li>The next 2 bytes consists of <b>process id</b></li>\n<li>The last 3 bytes are a random counter value</li>\n</ul>\n<p>MongoDB uses ObjectIds as the default value of <b>_id</b> field of each document, which is generated while the creation of any document. The complex combination of ObjectId makes all the _id fields unique.</p>\n<h2>Creating New ObjectId</h2>\n<p>To generate a new ObjectId use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;newObjectId = ObjectId()\n</pre>\n<p>The above statement returned the following uniquely generated id \u2212</p>\n<pre class=\"prettyprint notranslate\">\nObjectId(\"5349b4ddd2781d08c09890f3\")\n</pre>\n<p>Instead of MongoDB generating the ObjectId, you can also provide a 12-byte id \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;myObjectId = ObjectId(\"5349b4ddd2781d08c09890f4\")\n</pre>\n<h2>Creating Timestamp of a Document</h2>\n<p>Since the _id ObjectId by default stores the 4-byte timestamp, in most cases you do not need to store the creation time of any document. You can fetch the creation time of a document using getTimestamp method \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;ObjectId(\"5349b4ddd2781d08c09890f4\").getTimestamp()\n</pre>\n<p>This will return the creation time of this document in ISO date format \u2212</p>\n<pre class=\"prettyprint notranslate\">\nISODate(\"2014-04-12T21:49:17Z\")\n</pre>\n<h2>Converting ObjectId to String</h2>\n<p>In some cases, you may need the value of ObjectId in a string format. To convert the ObjectId in string, use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;newObjectId.str\n</pre>\n<p>The above code will return the string format of the Guid \u2212</p>\n<pre class=\"result notranslate\">\n5349b4ddd2781d08c09890f3\n</pre>\n<h1>MongoDB - Map Reduce</h1>\n<p>As per the MongoDB documentation, <b>Map-reduce</b> is a data processing paradigm for condensing large volumes of data into useful aggregated results. MongoDB uses <b>mapReduce</b> command for map-reduce operations. MapReduce is generally used for processing large data sets.</p>\n<h2>MapReduce Command</h2>\n<p>Following is the syntax of the basic mapReduce command \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.collection.mapReduce(\n   function() {emit(key,value);},  //map function\n   function(key,values) {return reduceFunction}, {   //reduce function\n      out: collection,\n      query: document,\n      sort: document,\n      limit: number\n   }\n)\n</pre>\n<p>The map-reduce function first queries the collection, then maps the result documents to emit key-value pairs, which is then reduced based on the keys that have multiple values.</p>\n<p>In the above syntax \u2212</p>\n<ul class=\"list\">\n<li><p><b>map</b> is a javascript function that maps a value with a key and emits a key-value pair</p></li>\n<li><p><b>reduce</b> is a javascript function that reduces or groups all the documents having the same key</p></li>\n<li><p><b>out</b> specifies the location of the map-reduce query result</p></li>\n<li><p><b>query</b> specifies the optional selection criteria for selecting documents</p></li>\n<li><p><b>sort</b> specifies the optional sort criteria</p></li>\n<li><p><b>limit</b> specifies the optional maximum number of documents to be returned</p></li>\n</ul>\n<h2>Using MapReduce</h2>\n<p>Consider the following document structure storing user posts. The document stores user_name of the user and the status of post.</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"post_text\": \"tutorialspoint is an awesome website for tutorials\",\n   \"user_name\": \"mark\",\n   \"status\":\"active\"\n}\n</pre>\n<p>Now, we will use a mapReduce function on our <b>posts</b> collection to select all the active posts, group them on the basis of user_name and then count the number of posts by each user using the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.mapReduce( \n   function() { emit(this.user_id,1); }, \n\t\n   function(key, values) {return Array.sum(values)}, {  \n      query:{status:\"active\"},  \n      out:\"post_total\" \n   }\n)\n</pre>\n<p>The above mapReduce query outputs the following result \u2212</p>\n<pre class=\"result notranslate\">\n{\n   \"result\" : \"post_total\",\n   \"timeMillis\" : 9,\n   \"counts\" : {\n      \"input\" : 4,\n      \"emit\" : 4,\n      \"reduce\" : 2,\n      \"output\" : 2\n   },\n   \"ok\" : 1,\n}\n</pre>\n<p>The result shows that a total of 4 documents matched the query (status:\"active\"), the map function emitted 4 documents with key-value pairs and finally the reduce function grouped mapped documents having the same keys into 2.</p>\n<p>To see the result of this mapReduce query, use the find operator \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.mapReduce( \n   function() { emit(this.user_id,1); }, \n   function(key, values) {return Array.sum(values)}, {  \n      query:{status:\"active\"},  \n      out:\"post_total\" \n   }\n\t\n).find()\n</pre>\n<p>The above query gives the following result which indicates that both users <b>tom</b> and <b>mark</b> have two posts in active states \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : \"tom\", \"value\" : 2 }\n{ \"_id\" : \"mark\", \"value\" : 2 }\n</pre>\n<p>In a similar manner, MapReduce queries can be used to construct large complex aggregation queries. The use of custom Javascript functions make use of MapReduce which is very flexible and powerful.</p>\n<h1>MongoDB - Text Search</h1>\n<p>Starting from version 2.4, MongoDB started supporting text indexes to search inside string content. The <b>Text Search</b> uses stemming techniques to look for specified words in the string fields by dropping stemming stop words like <b>a, an, the,</b> etc. At present, MongoDB supports around 15 languages.</p>\n<h2>Enabling Text Search</h2>\n<p>Initially, Text Search was an experimental feature but starting from version 2.6, the configuration is enabled by default. But if you are using the previous version of MongoDB, you have to enable text search with the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.adminCommand({setParameter:true,textSearchEnabled:true})\n</pre>\n<h2>Creating Text Index</h2>\n<p>Consider the following document under <b>posts</b> collection containing the post text and its tags \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"post_text\": \"enjoy the mongodb articles on tutorialspoint\",\n   \"tags\": [\n      \"mongodb\",\n      \"tutorialspoint\"\n   ]\n}\n</pre>\n<p>We will create a text index on post_text field so that we can search inside our posts' text \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.ensureIndex({post_text:\"text\"})\n</pre>\n<h2>Using Text Index</h2>\n<p>Now that we have created the text index on post_text field, we will search for all the posts having the word <b>tutorialspoint</b> in their text.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({$text:{$search:\"tutorialspoint\"}})\n</pre>\n<p>The above command returned the following result documents having the word <b>tutorialspoint</b> in their post text \u2212</p>\n<pre class=\"result notranslate\">\n{ \n   \"_id\" : ObjectId(\"53493d14d852429c10000002\"), \n   \"post_text\" : \"enjoy the mongodb articles on tutorialspoint\", \n   \"tags\" : [ \"mongodb\", \"tutorialspoint\" ]\n}\n{\n   \"_id\" : ObjectId(\"53493d1fd852429c10000003\"), \n   \"post_text\" : \"writing tutorials on mongodb\",\n   \"tags\" : [ \"mongodb\", \"tutorial\" ] \n}\n</pre>\n<p>If you are using old versions of MongoDB, you have to use the following command \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.runCommand(\"text\",{search:\" tutorialspoint \"})\n</pre>\n<p>Using Text Search highly improves the search efficiency as compared to normal search.</p>\n<h2>Deleting Text Index</h2>\n<p>To delete an existing text index, first find the name of index using the following query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.getIndexes()\n</pre>\n<p>After getting the name of your index from above query, run the following command. Here, <b>post_text_text</b> is the name of the index.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.dropIndex(\"post_text_text\")\n</pre>\n<h1>MongoDB - Regular Expression</h1>\n<p>Regular Expressions are frequently used in all languages to search for a pattern or word in any string. MongoDB also provides functionality of regular expression for string pattern matching using the <b>$regex</b> operator. MongoDB uses PCRE (Perl Compatible Regular Expression) as regular expression language.</p>\n<p>Unlike text search, we do not need to do any configuration or command to use regular expressions.</p>\n<p>Consider the following document structure under <b>posts</b> collection containing the post text and its tags \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"post_text\": \"enjoy the mongodb articles on tutorialspoint\",\n   \"tags\": [\n      \"mongodb\",\n      \"tutorialspoint\"\n   ]\n}\n</pre>\n<h2>Using regex Expression</h2>\n<p>The following regex query searches for all the posts containing string <b>tutorialspoint</b> in it \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({post_text:{$regex:\"tutorialspoint\"}})\n</pre>\n<p>The same query can also be written as \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({post_text:/tutorialspoint/})\n</pre>\n<h2>Using regex Expression with Case Insensitive</h2>\n<p>To make the search case insensitive, we use the <b>$options</b> parameter with value <b>$i</b>. The following command will look for strings having the word <b>tutorialspoint</b>, irrespective of smaller or capital case \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({post_text:{$regex:\"tutorialspoint\",$options:\"$i\"}})\n</pre>\n<p>One of the results returned from this query is the following document which contains the word <b>tutorialspoint</b> in different cases \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"_id\" : ObjectId(\"53493d37d852429c10000004\"),\n   \"post_text\" : \"hey! this is my post on TutorialsPoint\", \n   \"tags\" : [ \"tutorialspoint\" ]\n} \n </pre>\n<h2>Using regex for Array Elements</h2>\n<p>We can also use the concept of regex on array field. This is particularly very important when we implement the functionality of tags. So, if you want to search for all the posts having tags beginning from the word tutorial (either tutorial or tutorials or tutorialpoint or tutorialphp), you can use the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.posts.find({tags:{$regex:\"tutorial\"}})\n</pre>\n<h2>Optimizing Regular Expression Queries</h2>\n<ul class=\"list\">\n<li><p>If the document fields are <b>indexed</b>, the query will use make use of indexed values to match the regular expression. This makes the search very fast as compared to the regular expression scanning the whole collection.</p></li>\n<li><p>If the regular expression is a <b>prefix expression</b>, all the matches are meant to start with a certain string characters. For e.g., if the regex expression is <b>^tut</b>, then the query has to search for only those strings that begin with <b>tut</b>.</p></li>\n</ul>\n<h1>Working with RockMongo</h1>\n<p>RockMongo is a MongoDB administration tool using which you can manage your server, databases, collections, documents, indexes, and a lot more. It provides a very user-friendly way for reading, writing, and creating documents. It is similar to PHPMyAdmin tool for PHP and MySQL.</p>\n<h2>Downloading RockMongo</h2>\n<p>You can download the latest version of RockMongo from here: <a href=\"http://rockmongo.com/downloads\" rel=\"nofollow\" target=\"_blank\">http://rockmongo.com/downloads</a></p>\n<h2>Installing RockMongo</h2>\n<p>Once downloaded, you can unzip the package in your server root folder and rename the extracted folder to <b>rockmongo</b>. Open any web browser and access the <b>index.php</b> page from the folder rockmongo. Enter admin/admin as username/password respectively.</p>\n<h2>Working with RockMongo</h2>\n<p>We will now be looking at some basic operations that you can perform with RockMongo.</p>\n<h2>Creating New Database</h2>\n<p>To create a new database, click <b>Databases</b> tab. Click <b>Create New Database</b>. On the next screen, provide the name of the new database and click on <b>Create</b>. You will see a new database getting added in the left panel.</p>\n<h2>Creating New Collection</h2>\n<p>To create a new collection inside a database, click on that database from the left panel. Click on the <b>New Collection</b> link on top. Provide the required name of the collection. Do not worry about the other fields of Is Capped, Size and Max. Click on <b>Create</b>. A new collection will be created and you will be able to see it in the left panel.</p>\n<h2>Creating New Document</h2>\n<p>To create a new document, click on the collection under which you want to add documents. When you click on a collection, you will be able to see all the documents within that collection listed there. To create a new document, click on the <b>Insert</b> link at the top. You can enter the document's data either in JSON or array format and click on <b>Save</b>.</p>\n<h2>Export/Import Data</h2>\n<p>To import/export data of any collection, click on that collection and then click on <b>Export/Import</b> link on the top panel. Follow the next instructions to export your data in a zip format and then import the same zip file to import back data.</p>\n<h1>MongoDB - GridFS</h1>\n<p><b>GridFS</b> is the MongoDB specification for storing and retrieving large files such as images, audio files, video files, etc. It is kind of a file system to store files but its data is stored within MongoDB collections. GridFS has the capability to store files even greater than its document size limit of 16MB.</p>\n<p>GridFS divides a file into chunks and stores each chunk of data in a separate document, each of maximum size 255k.</p>\n<p>GridFS by default uses two collections <b>fs.files</b> and <b>fs.chunks</b> to store the file's metadata and the chunks. Each chunk is identified by its unique _id ObjectId field. The fs.files serves as a parent document. The <b>files_id</b> field in the fs.chunks document links the chunk to its parent.</p>\n<p>Following is a sample document of fs.files collection \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"filename\": \"test.txt\",\n   \"chunkSize\": NumberInt(261120),\n   \"uploadDate\": ISODate(\"2014-04-13T11:32:33.557Z\"),\n   \"md5\": \"7b762939321e146569b07f72c62cca4f\",\n   \"length\": NumberInt(646)\n}\n</pre>\n<p>The document specifies the file name, chunk size, uploaded date, and length.</p>\n<p>Following is a sample document of fs.chunks document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   \"files_id\": ObjectId(\"534a75d19f54bfec8a2fe44b\"),\n   \"n\": NumberInt(0),\n   \"data\": \"Mongo Binary Data\"\n}\n</pre>\n<h2>Adding Files to GridFS</h2>\n<p>Now, we will store an mp3 file using GridFS using the <b>put</b> command. For this, we will use the <b>mongofiles.exe</b> utility present in the bin folder of the MongoDB installation folder.</p>\n<p>Open your command prompt, navigate to the mongofiles.exe in the bin folder of MongoDB installation folder and type the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;mongofiles.exe -d gridfs put song.mp3\n</pre>\n<p>Here, <b>gridfs</b> is the name of the database in which the file will be stored. If the database is not present, MongoDB will automatically create a new document on the fly. Song.mp3 is the name of the file uploaded. To see the file's document in database, you can use find query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.fs.files.find()\n</pre>\n<p>The above command returned the following document \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n   _id: ObjectId('534a811bf8b4aa4d33fdf94d'), \n   filename: \"song.mp3\", \n   chunkSize: 261120, \n   uploadDate: new Date(1397391643474), md5: \"e4f53379c909f7bed2e9d631e15c1c41\",\n   length: 10401959 \n}\n</pre>\n<p>We can also see all the chunks present in fs.chunks collection related to the stored file with the following code, using the document id returned in the previous query \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.fs.chunks.find({files_id:ObjectId('534a811bf8b4aa4d33fdf94d')})\n</pre>\n<p>In my case, the query returned 40 documents meaning that the whole mp3 document was divided in 40 chunks of data.</p>\n<h1>MongoDB - Capped Collections</h1>\n<p><b>Capped collections</b> are fixed-size circular collections that follow the insertion order to support high performance for create, read, and delete operations. By circular, it means that when the fixed size allocated to the collection is exhausted, it will start deleting the oldest document in the collection without providing any explicit commands.</p>\n<p>Capped collections restrict updates to the documents if the update results in increased document size. Since capped collections store documents in the order of the disk storage, it ensures that the document size does not increase the size allocated on the disk. Capped collections are best for storing log information, cache data, or any other high volume data.</p>\n<h2>Creating Capped Collection</h2>\n<p>To create a capped collection, we use the normal createCollection command but with <b>capped</b> option as <b>true</b> and specifying the maximum size of collection in bytes.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.createCollection(\"cappedLogCollection\",{capped:true,size:10000})\n</pre>\n<p>In addition to collection size, we can also limit the number of documents in the collection using the <b>max</b> parameter \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.createCollection(\"cappedLogCollection\",{capped:true,size:10000,max:1000})\n</pre>\n<p>If you want to check whether a collection is capped or not, use the following <b>isCapped</b> command \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.cappedLogCollection.isCapped()\n</pre>\n<p>If there is an existing collection which you are planning to convert to capped, you can do it with the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.runCommand({\"convertToCapped\":\"posts\",size:10000})\n</pre>\n<p>This code would convert our existing collection <b>posts</b> to a capped collection.</p>\n<h2>Querying Capped Collection</h2>\n<p>By default, a find query on a capped collection will display results in insertion order. But if you want the documents to be retrieved in reverse order, use the <b>sort</b> command as shown in the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.cappedLogCollection.find().sort({$natural:-1})\n</pre>\n<p>There are few other important points regarding capped collections worth knowing \u2212</p>\n<ul class=\"list\">\n<li><p>We cannot delete documents from a capped collection.</p></li>\n<li><p>There are no default indexes present in a capped collection, not even on _id field.</p></li>\n<li><p>While inserting a new document, MongoDB does not have to actually look for a place to accommodate new document on the disk. It can blindly insert the new document at the tail of the collection. This makes insert operations in capped collections very fast.</p></li>\n<li><p>Similarly, while reading documents MongoDB returns the documents in the same order as present on disk. This makes the read operation very fast.</p></li>\n</ul>\n<h1>MongoDB - Auto-Increment Sequence</h1>\n<p>MongoDB does not have out-of-the-box auto-increment functionality, like SQL databases. By default, it uses the 12-byte ObjectId for the <b>_id</b> field as the primary key to uniquely identify the documents. However, there may be scenarios where we may want the _id field to have some auto-incremented value other than the ObjectId.</p>\n<p>Since this is not a default feature in MongoDB, we will programmatically achieve this functionality by using a <b>counters</b> collection as suggested by the MongoDB documentation.</p>\n<h2>Using Counter Collection</h2>\n<p>Consider the following <b>products</b> document. We want the _id field to be an <b>auto-incremented integer sequence</b> starting from 1,2,3,4 upto n.</p>\n<pre class=\"prettyprint notranslate\">\n{\n  \"_id\":1,\n  \"product_name\": \"Apple iPhone\",\n  \"category\": \"mobiles\"\n}\n</pre>\n<p>For this, create a <b>counters</b> collection, which will keep track of the last sequence value for all the sequence fields.</p>\n<pre class=\"result notranslate\">\n&gt;db.createCollection(\"counters\")\n</pre>\n<p>Now, we will insert the following document in the counters collection with <b>productid</b> as its key \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{\n  \"_id\":\"productid\",\n  \"sequence_value\": 0\n}\n</pre>\n<p>The field <b>sequence_value</b> keeps track of the last value of the sequence.</p>\n<p>Use the following code to insert this sequence document in the counters collection \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.counters.insert({_id:\"productid\",sequence_value:0})\n</pre>\n<h2>Creating Javascript Function</h2>\n<p>Now, we will create a function <b>getNextSequenceValue</b> which will take the sequence name as its input, increment the sequence number by 1 and return the updated sequence number. In our case, the sequence name is <b>productid</b>.</p>\n<pre class=\"prettyprint notranslate\">\n&gt;function getNextSequenceValue(sequenceName){\n\n   var sequenceDocument = db.counters.findAndModify({\n      query:{_id: sequenceName },\n      update: {$inc:{sequence_value:1}},\n      new:true\n   });\n\t\n   return sequenceDocument.sequence_value;\n}\n</pre>\n<h2>Using the Javascript Function</h2>\n<p>We will now use the function getNextSequenceValue while creating a new document and assigning the returned sequence value as document's _id field.</p>\n<p>Insert two sample documents using the following code \u2212</p>\n<pre class=\"prettyprint notranslate\">\n&gt;db.products.insert({\n   \"_id\":getNextSequenceValue(\"productid\"),\n   \"product_name\":\"Apple iPhone\",\n   \"category\":\"mobiles\"\n})\n\n&gt;db.products.insert({\n   \"_id\":getNextSequenceValue(\"productid\"),\n   \"product_name\":\"Samsung S3\",\n   \"category\":\"mobiles\"\n})\n</pre>\n<p>As you can see, we have used the getNextSequenceValue function to set value for the _id field.</p>\n<p>To verify the functionality, let us fetch the documents using find command \u2212</p>\n<pre class=\"result notranslate\">\n&gt;db.products.find()\n</pre>\n<p>The above query returned the following documents having the auto-incremented _id field \u2212</p>\n<pre class=\"prettyprint notranslate\">\n{ \"_id\" : 1, \"product_name\" : \"Apple iPhone\", \"category\" : \"mobiles\"}\n\n{ \"_id\" : 2, \"product_name\" : \"Samsung S3\", \"category\" : \"mobiles\" }\n</pre>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/mongodb/mongodb_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"print-btn center\">\n<a href=\"/cgi-bin/printpage.cgi\" target=\"_blank\"><i class=\"icon icon-print big-font\"></i> Print</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/mongodb/mongodb_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<hr/>\n<!-- PRINTING ENDS HERE -->\n<div class=\"bottomgooglead\">\n<div class=\"bottomadtag\">Advertisements</div>\n<script><!--\nvar width = 580;\nvar height = 400;\nvar format = \"580x400_as\";\nif( window.innerWidth < 468 ){\n   width = 300;\n   height = 250;\n   format = \"300x250_as\";\n}\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = width;\ngoogle_ad_height = height;\ngoogle_ad_format = format;\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n</img></div>"}