{"content": "\n PL/SQL - Quick Guide \n  \n Advertisements \n \n<!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//-->\n\n\n \n  \n \n Previous Page\n \n \nNext Page \u00a0\n \n  \n  \n PL/SQL - Overview \n The PL/SQL programming language was developed by Oracle Corporation in the late 1980s as procedural extension language for SQL and the Oracle relational database. Following are certain notable facts about PL/SQL \u2212 \n \nPL/SQL is a completely portable, high-performance transaction-processing language.\nPL/SQL provides a built-in, interpreted and OS independent programming environment.\nPL/SQL can also directly be called from the command-line SQL*Plus interface.\nDirect call can also be made from external programming language calls to database.\nPL/SQL's general syntax is based on that of ADA and Pascal programming language.\nApart from Oracle, PL/SQL is available in TimesTen in-memory database and IBM DB2.\n \n Features of PL/SQL \n PL/SQL has the following features \u2212 \n \nPL/SQL is tightly integrated with SQL.\nIt offers extensive error checking.\nIt offers numerous data types.\nIt offers a variety of programming structures.\nIt supports structured programming through functions and procedures.\nIt supports object-oriented programming.\nIt supports the development of web applications and server pages.\n \n Advantages of PL/SQL \n PL/SQL has the following advantages \u2212 \n \nSQL is the standard database language and PL/SQL is strongly integrated with SQL. PL/SQL supports both static and dynamic SQL. Static SQL supports DML operations and transaction control from PL/SQL block. In Dynamic SQL, SQL allows embedding DDL statements in PL/SQL blocks.\nPL/SQL allows sending an entire block of statements to the database at one time. This reduces network traffic and provides high performance for the applications.\nPL/SQL gives high productivity to programmers as it can query, transform, and update data in a database.\nPL/SQL saves time on design and debugging by strong features, such as exception handling, encapsulation, data hiding, and object-oriented data types.\nApplications written in PL/SQL are fully portable.\nPL/SQL provides high security level.\nPL/SQL provides access to predefined SQL packages.\nPL/SQL provides support for Object-Oriented Programming.\nPL/SQL provides support for developing Web Applications and Server Pages.\n \n PL/SQL - Environment Setup \n In this chapter, we will discuss the Environment Setup of PL/SQL. PL/SQL is not a standalone programming language; it is a tool within the Oracle programming environment. SQL* Plus is an interactive tool that allows you to type SQL and PL/SQL statements at the command prompt. These commands are then sent to the database for processing. Once the statements are processed, the results are sent back and displayed on screen. \n To run PL/SQL programs, you should have the Oracle RDBMS Server installed in your machine. This will take care of the execution of the SQL commands. The most recent version of Oracle RDBMS is 11g. You can download a trial version of Oracle 11g from the following link \u2212 \n Download Oracle 11g Express Edition \n You will have to download either the 32-bit or the 64-bit version of the installation as per your operating system. Usually there are two files. We have downloaded the 64-bit version. You will also use similar steps on your operating system, does not matter if it is Linux or Solaris. \n \nwin64_11gR2_database_1of2.zip\nwin64_11gR2_database_2of2.zip\n \n After downloading the above two files, you will need to unzip them in a single directory database and under that you will find the following sub-directories \u2212 \n \nStep 1\nLet us now launch the Oracle Database Installer using the setup file. Following is the first screen. You can provide your email ID and check the checkbox as shown in the following screenshot. Click the Next button.\n\nStep 2\nYou will be directed to the following screen; uncheck the checkbox and click the Continue button to proceed.\n\nStep 3\nJust select the first option Create and Configure Database using the radio button and click the Next button to proceed.\n\nStep 4\nWe assume you are installing Oracle for the basic purpose of learning and that you are installing it on your PC or Laptop. Thus, select the Desktop Class option and click the Next button to proceed.\n\nStep 5\nProvide a location, where you will install the Oracle Server. Just modify the Oracle Base and the other locations will set automatically. You will also have to provide a password; this will be used by the system DBA. Once you provide the required information, click the Next button to proceed.\n\nStep 6\nAgain, click the Next button to proceed.\n\nStep 7\nClick the Finish button to proceed; this will start the actual server installation.\n\nStep 8\nThis will take a few moments, until Oracle starts performing the required configuration.\n\nStep 9\nHere, Oracle installation will copy the required configuration files. This should take a moment \u2212\n\nStep 10\nOnce the database files are copied, you will have the following dialogue box. Just click the OK button and come out.\n\nStep 11\nUpon installation, you will have the following final window.\n\nFinal Step\nIt is now time to verify your installation. At the command prompt, use the following command if you are using Windows \u2212\n\nsqlplus \"/ as sysdba\"\n\nYou should have the SQL prompt where you will write your PL/SQL commands and scripts \u2212\n\nText Editor\nRunning large programs from the command prompt may land you in inadvertently losing some of the work. It is always recommended to use the command files. To use the command files \u2212\n\nType your code in a text editor, like Notepad, Notepad+, or EditPlus, etc.\nSave the file with the .sql extension in the home directory.\nLaunch the SQL*Plus command prompt from the directory where you created your PL/SQL file.\nType @file_name at the SQL*Plus command prompt to execute your program.\n\nIf you are not using a file to execute the PL/SQL scripts, then simply copy your PL/SQL code and right-click on the black window that displays the SQL prompt; use the paste option to paste the complete code at the command prompt. Finally, just press Enter to execute the code, if it is not already executed.\nPL/SQL - Basic Syntax\nIn this chapter, we will discuss the Basic Syntax of PL/SQL which is a block-structured language; this means that the PL/SQL programs are divided and written in logical blocks of code. Each block consists of three sub-parts \u2212\n\n\nS.No\nSections & Description\n\n\n1\n\nDeclarations\nThis section starts with the keyword DECLARE. It is an optional section and defines all variables, cursors, subprograms, and other elements to be used in the program.\n\n\n\n2\n\nExecutable Commands\nThis section is enclosed between the keywords BEGIN and END and it is a mandatory section. It consists of the executable PL/SQL statements of the program. It should have at least one executable line of code, which may be just a NULL command to indicate that nothing should be executed.\n\n\n\n3\nException Handling\nThis section starts with the keyword EXCEPTION. This optional section contains exception(s) that handle errors in the program.\n", "title": "PL/SQL - Quick Guide", "content_html": "<div class=\"col-md-7 middle-col\">\n<h1>PL/SQL - Quick Guide</h1>\n<hr/>\n<div style=\"padding-bottom:5px;padding-left:10px;text-align: center;\">Advertisements</div>\n<div style=\"text-align: center;\">\n<script type=\"text/javascript\"><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\" type=\"text/javascript\">\n</script>\n</div>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/plsql/plsql_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/plsql/plsql_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<div class=\"clearer\"></div>\n<hr/>\n<h1>PL/SQL - Overview</h1>\n<p>The PL/SQL programming language was developed by Oracle Corporation in the late 1980s as procedural extension language for SQL and the Oracle relational database. Following are certain notable facts about PL/SQL \u2212</p>\n<ul class=\"list\">\n<li><p>PL/SQL is a completely portable, high-performance transaction-processing language.</p></li>\n<li><p>PL/SQL provides a built-in, interpreted and OS independent programming environment.</p></li>\n<li><p>PL/SQL can also directly be called from the command-line <b>SQL*Plus interface</b>.</p></li>\n<li><p>Direct call can also be made from external programming language calls to database.</p></li>\n<li><p>PL/SQL's general syntax is based on that of ADA and Pascal programming language.</p></li>\n<li><p>Apart from Oracle, PL/SQL is available in <b>TimesTen in-memory database</b> and <b>IBM DB2</b>.</p></li>\n</ul>\n<h2>Features of PL/SQL</h2>\n<p>PL/SQL has the following features \u2212</p>\n<ul class=\"list\">\n<li>PL/SQL is tightly integrated with SQL.</li>\n<li>It offers extensive error checking.</li>\n<li>It offers numerous data types.</li>\n<li>It offers a variety of programming structures.</li>\n<li>It supports structured programming through functions and procedures.</li>\n<li>It supports object-oriented programming.</li>\n<li>It supports the development of web applications and server pages.</li>\n</ul>\n<h2>Advantages of PL/SQL</h2>\n<p>PL/SQL has the following advantages \u2212</p>\n<ul class=\"list\">\n<li><p>SQL is the standard database language and PL/SQL is strongly integrated with SQL. PL/SQL supports both static and dynamic SQL. Static SQL supports DML operations and transaction control from PL/SQL block. In Dynamic SQL, SQL allows embedding DDL statements in PL/SQL blocks.</p></li>\n<li><p>PL/SQL allows sending an entire block of statements to the database at one time. This reduces network traffic and provides high performance for the applications.</p></li>\n<li><p>PL/SQL gives high productivity to programmers as it can query, transform, and update data in a database.</p></li>\n<li><p>PL/SQL saves time on design and debugging by strong features, such as exception handling, encapsulation, data hiding, and object-oriented data types.</p></li>\n<li><p>Applications written in PL/SQL are fully portable.</p></li>\n<li><p>PL/SQL provides high security level.</p></li>\n<li><p>PL/SQL provides access to predefined SQL packages.</p></li>\n<li><p>PL/SQL provides support for Object-Oriented Programming.</p></li>\n<li><p>PL/SQL provides support for developing Web Applications and Server Pages.</p></li>\n</ul>\n<h1>PL/SQL - Environment Setup</h1>\n<p>In this chapter, we will discuss the Environment Setup of PL/SQL. PL/SQL is not a standalone programming language; it is a tool within the Oracle programming environment. <b>SQL* Plus</b> is an interactive tool that allows you to type SQL and PL/SQL statements at the command prompt. These commands are then sent to the database for processing. Once the statements are processed, the results are sent back and displayed on screen.</p>\n<p>To run PL/SQL programs, you should have the Oracle RDBMS Server installed in your machine. This will take care of the execution of the SQL commands. The most recent version of Oracle RDBMS is 11g. You can download a trial version of Oracle 11g from the following link \u2212</p>\n<p><a href=\"https://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html\" rel=\"nofollow\" target=\"_blank\">Download Oracle 11g Express Edition</a></p>\n<p>You will have to download either the 32-bit or the 64-bit version of the installation as per your operating system. Usually there are two files. We have downloaded the 64-bit version. You will also use similar steps on your operating system, does not matter if it is Linux or Solaris.</p>\n<ul class=\"list\">\n<li><p><b>win64_11gR2_database_1of2.zip</b></p></li>\n<li><p><b>win64_11gR2_database_2of2.zip</b></p></li>\n</ul>\n<p>After downloading the above two files, you will need to unzip them in a single directory <b>database</b> and under that you will find the following sub-directories \u2212</p>\n<img alt=\"Oracle Sub Directries\" src=\"/plsql/images/oracle_sub_directories.jpg\">\n<h3>Step 1</h3>\n<p>Let us now launch the Oracle Database Installer using the setup file. Following is the first screen. You can provide your email ID and check the checkbox as shown in the following screenshot. Click the <b>Next</b> button.</p>\n<img alt=\"Oracle Install 1\" src=\"/plsql/images/oracle_install_step1.jpg\"/>\n<h3>Step 2</h3>\n<p>You will be directed to the following screen; uncheck the checkbox and click the <b>Continue</b> button to proceed.</p>\n<img alt=\"Oracle install error\" src=\"/plsql/images/oracle_install_error1.jpg\"/>\n<h3>Step 3</h3>\n<p>Just select the first option <b>Create and Configure Database</b> using the radio button and click the <b>Next</b> button to proceed.</p>\n<img alt=\"Oracle Install 2\" src=\"/plsql/images/oracle_install_step2.jpg\"/>\n<h3>Step 4</h3>\n<p>We assume you are installing Oracle for the basic purpose of learning and that you are installing it on your PC or Laptop. Thus, select the <b>Desktop Class</b> option and click the <b>Next</b> button to proceed.</p>\n<img alt=\"Oracle Install 3\" src=\"/plsql/images/oracle_install_step3.jpg\"/>\n<h3>Step 5</h3>\n<p>Provide a location, where you will install the Oracle Server. Just modify the <b>Oracle Base</b> and the other locations will set automatically. You will also have to provide a password; this will be used by the system DBA. Once you provide the required information, click the <b>Next</b> button to proceed.</p>\n<img alt=\"Oracle Install 4\" src=\"/plsql/images/oracle_install_step4.jpg\"/>\n<h3>Step 6</h3>\n<p>Again, click the <b>Next</b> button to proceed.</p>\n<img alt=\"Oracle Install 5\" src=\"/plsql/images/oracle_install_step5.jpg\"/>\n<h3>Step 7</h3>\n<p>Click the <b>Finish</b> button to proceed; this will start the actual server installation.</p>\n<img alt=\"Oracle Install 6\" src=\"/plsql/images/oracle_install_step6.jpg\"/>\n<h3>Step 8</h3>\n<p>This will take a few moments, until Oracle starts performing the required configuration.</p>\n<img alt=\"Oracle Install 7\" src=\"/plsql/images/oracle_install_step7.jpg\"/>\n<h3>Step 9</h3>\n<p>Here, Oracle installation will copy the required configuration files. This should take a moment \u2212</p>\n<img alt=\"Oracle Configuration\" src=\"/plsql/images/oracle_install_configuration1.jpg\"/>\n<h3>Step 10</h3>\n<p>Once the database files are copied, you will have the following dialogue box. Just click the <b>OK</b> button and come out.</p>\n<img alt=\"Oracle Configuration\" src=\"/plsql/images/oracle_install_configuration2.jpg\"/>\n<h3>Step 11</h3>\n<p>Upon installation, you will have the following final window.</p>\n<img alt=\"Oracle Install 8\" src=\"/plsql/images/oracle_install_step8.jpg\"/>\n<h3>Final Step</h3>\n<p>It is now time to verify your installation. At the command prompt, use the following command if you are using Windows \u2212</p>\n<pre class=\"result notranslate\">\nsqlplus \"/ as sysdba\"\n</pre>\n<p>You should have the SQL prompt where you will write your PL/SQL commands and scripts \u2212</p>\n<img alt=\"PL/SQL Command Prompt\" src=\"/plsql/images/plsql_command_prompt.jpg\"/>\n<h2>Text Editor</h2>\n<p>Running large programs from the command prompt may land you in inadvertently losing some of the work. It is always recommended to use the command files. To use the command files \u2212</p>\n<ul class=\"list\">\n<li><p>Type your code in a text editor, like <b>Notepad, Notepad+,</b> or <b>EditPlus</b>, etc.</p></li>\n<li><p>Save the file with the <b>.sql</b> extension in the home directory.</p></li>\n<li><p>Launch the <b>SQL*Plus command prompt</b> from the directory where you created your PL/SQL file.</p></li>\n<li><p>Type <b>@file_name</b> at the SQL*Plus command prompt to execute your program.</p></li>\n</ul>\n<p>If you are not using a file to execute the PL/SQL scripts, then simply copy your PL/SQL code and right-click on the black window that displays the SQL prompt; use the <b>paste</b> option to paste the complete code at the command prompt. Finally, just press <b>Enter</b> to execute the code, if it is not already executed.</p>\n<h1>PL/SQL - Basic Syntax</h1>\n<p>In this chapter, we will discuss the Basic Syntax of PL/SQL which is a <b>block-structured</b> language; this means that the PL/SQL programs are divided and written in logical blocks of code. Each block consists of three sub-parts \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Sections &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td>\n<p><b>Declarations</b></p>\n<p>This section starts with the keyword <b>DECLARE</b>. It is an optional section and defines all variables, cursors, subprograms, and other elements to be used in the program.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td>\n<p><b>Executable Commands</b></p>\n<p>This section is enclosed between the keywords <b>BEGIN</b> and <b>END</b> and it is a mandatory section. It consists of the executable PL/SQL statements of the program. It should have at least one executable line of code, which may be just a <b>NULL command</b> to indicate that nothing should be executed.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>Exception Handling</b></p>\n<p>This section starts with the keyword <b>EXCEPTION</b>. This optional section contains <b>exception(s)</b> that handle errors in the program.</p></td>\n</tr></table></img></div>", "html": "<!DOCTYPE html>\n\n<!--[if IE 8]><html class=\"ie ie8\"> <![endif]-->\n<!--[if IE 9]><html class=\"ie ie9\"> <![endif]-->\n<!--[if gt IE 9]><!--> <html> <!--<![endif]-->\n<head>\n<!-- Basic -->\n<meta charset=\"utf-8\"/>\n<title>PL/SQL Quick Guide</title>\n<meta content=\"PL/SQL Quick Guide- Learn PL/SQL programming in simple and easy steps starting with PL/SQL syntax, Environment Setup, Operators, Transactions, Date and Time, data types, variables, constants, records, conditional statements, iterative statements, cursors, procedures, functions, exception handling, triggers, packages, collections, external procedures, arrays, strings, dbms output.\" name=\"description\">\n<meta content=\"PL/SQL, syntax, Environment Setup, Operators, Transactions, Date and Time, data types, variables, constants, records, conditional statements, iterative statements, cursors, procedures, functions, exception handling, triggers, packages, collections, external procedures, arrays, strings, dbms output.\" name=\"keywords\"/>\n<base href=\"https://www.tutorialspoint.com/\"/>\n<link href=\"/favicon.ico\" rel=\"shortcut icon\" type=\"image/x-icon\"/>\n<meta content=\"width=device-width,initial-scale=1.0,user-scalable=yes\" name=\"viewport\"/>\n<meta content=\"en_US\" property=\"og:locale\">\n<meta content=\"website\" property=\"og:type\"/>\n<meta content=\"471319149685276\" property=\"fb:app_id\"/>\n<meta content=\"www.tutorialspoint.com\" property=\"og:site_name\"/>\n<meta content=\"yes\" name=\"apple-mobile-web-app-capable\"/>\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"/>\n<meta content=\"tutorialspoint.com\" name=\"author\"/>\n<script src=\"https://www.tutorialspoint.com/theme/js/script-min-v4.js?v=2\" type=\"text/javascript\"></script>\n<link href=\"https://www.tutorialspoint.com/theme/css/style-min.css?v=3.1\" rel=\"stylesheet\"/>\n<script>\r\nfunction openNav() {\t\r\n  document.getElementById(\"mySidenav\").style.width = \"250px\";\r\n  document.getElementById(\"right_obs\").style.display = \"block\";\r\n}\r\nfunction closeNav() {\r\n  document.getElementById(\"mySidenav\").style.width = \"0\";\r\n  document.getElementById(\"right_obs\").style.display = \"none\";\r\n}\r\nfunction close_obs_sidenav(){\r\n  document.getElementById(\"mySidenav\").style.width = \"0\";\r\n  document.getElementById(\"right_obs\").style.display = \"none\";\r\n}\r\n</script>\n<!-- Head Libs -->\n<!--[if IE 8]>\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/theme/css/ie8.css\">\r\n<![endif]-->\n<style>\r\n#privacy-banner {\r\n    position: fixed;\r\n    bottom: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    max-width: 100%;\r\n    padding: 1rem .5rem;\r\n    background: #fff;\r\n    z-index: 1030;\r\n    color: #000;\r\n    font-size: 14px;\r\n    margin: 0;\r\n    display: none;\r\n    border-top: 2px solid rgb(130, 130, 130);\r\n  }\r\n  #privacy-banner p {\r\n    margin: 0;\r\n    color: #000;\r\n    text-align: center;\r\n  }\r\n  #privacy-banner a {\r\n    text-decoration: none;\r\n    margin: 20px auto 0 auto;\r\n    display: block;\r\n    max-width: 150px;\r\n  }\r\n  #privacy-banner a:hover {\r\n    text-decoration: underline;\r\n  }\r\n  #banner-learn {\r\n    color: #000;\r\n  }\r\n  #banner-accept {\r\n    padding: 7px 15px;\r\n    color: #fff;\r\n    border-radius: 5px;\r\n    background:#737373 !important;\r\n  }\r\n  @media (min-width: 768px) {\r\n    #privacy-banner {\r\n      padding: 1.5rem .5rem;\r\n    }\r\n    #privacy-banner a {\r\n      display: inline-block;\r\n      margin: 0 10px;\r\n    }\r\n}\r\nselect{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }\r\n.btnsbmt{ background: #d02023 !important;}\r\nul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}\r\ndiv.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #d02023 url(/images/pattern.png) repeat center center !important;}\r\n.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #d02023 !important;}\r\n.submenu-item{ border-bottom: 2px solid #d02023 !important; border-top: 2px solid #d02023 !important }\r\n.ace_scroller{overflow: auto!important;}\r\na.demo{font-family: \"Open Sans\",Arial,sans-serif; background:#d02023; color:#fff; font-size:13px; padding:3px 10px; border:1px solid #d6d6d6; position:absolute; right:5px; margin:-6px 17px 0px 0px;}\r\na.demo:hover{opacity:.8}\r\n</style>\n<script>\r\n$(document).ready(function() {\r\n  $('input[name=\"q\"]').keydown(function(event){\r\n    if(event.keyCode == 13) {\r\n      event.preventDefault();\r\n      return false;\r\n    }\r\n  });\r\n});\r\n</script>\n</meta></meta></head>\n<body onload=\"prettyPrint()\">\n<div class=\"wrapLoader\">\n<div class=\"imgLoader\">\n<img alt=\"\" height=\"70\" src=\"/images/loading-cg.gif\" width=\"70\"/>\n</div>\n</div>\n<div class=\"display-none\" id=\"right_obs\" onclick=\"close_obs_sidenav()\"></div>\n<header>\n<div class=\"container\">\n<h1 class=\"logo\">\n<a href=\"index.htm\" title=\"tutorialspoint\">\n<img alt=\"tutorialspoint\" src=\"/plsql/images/logo.png\"/>\n</a>\n</h1>\n<ul class=\"tp-inline-block pull-right\" id=\"tp-head-icons\">\n<li>\n<div class=\"tp-second-nav tp-display-none tp-pointer\" onclick=\"openNav()\">\n<i class=\"fa fa-th-large fa-lg\"></i>\n</div>\n</li>\n</ul>\n<button class=\"btn btn-responsive-nav btn-inverse\" data-target=\".nav-main-collapse\" data-toggle=\"collapse\" id=\"pull\" style=\"top: 24px!important\"> <i class=\"icon icon-bars\"></i> </button>\n<nav>\n<ul class=\"nav nav-pills nav-top\">\n<li><a href=\"/about/about_careers.htm\" style=\"background: #fffb09; font-weight: bold;\"><i class=\"icon icon-suitcase\"></i> Jobs</a></li>\n<li> <a href=\"/programming_examples/\" target=\"_blank\"><i class=\"fa fa-cubes\"></i> \u00a0Examples</a> </li>\n<li> <a href=\"https://www.tutorialspoint.com/whiteboard.htm\"><img alt=\"Whiteboard\" src=\"theme/css/icons/image-editor.png\" title=\"Whiteboard\"/> \u00a0Whiteboard</a> </li>\n<li> <a href=\"https://www.tutorialspoint.com/netmeeting.php\"><i class=\"fa-camera\"></i> \u00a0Net Meeting</a> </li>\n<li> <a href=\"/online_dev_tools.htm\"> <i class=\"dev-tools-menu\" style=\"opacity:.5\"></i> Tools </a> </li>\n<li> <a href=\"/articles/index.php\"><i class=\"icon icon-file-text-o\"></i> \u00a0Articles</a> </li>\n<li class=\"top-icons\">\n<ul class=\"social-icons\">\n<li class=\"facebook\"><a data-placement=\"bottom\" href=\"https://www.facebook.com/tutorialspointindia\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Facebook\">Facebook</a></li>\n<li class=\"googleplus\"><a data-placement=\"bottom\" href=\"https://plus.google.com/u/0/116678774017490391259/posts\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Google+\">Google+</a></li>\n<li class=\"twitter\"><a data-placement=\"bottom\" href=\"https://www.twitter.com/tutorialspoint\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Twitter\">Twitter</a></li>\n<li class=\"linkedin\"><a data-placement=\"bottom\" href=\"https://www.linkedin.com/company/tutorialspoint\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Linkedin\">Linkedin</a></li>\n<li class=\"youtube\"><a data-placement=\"bottom\" href=\"https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint YouTube\">YouTube</a></li>\n</ul>\n</li>\n</ul>\n</nav>\n</div>\n<div class=\"sidenav\" id=\"mySidenav\">\n<div class=\"navbar nav-main\">\n<div class=\"container\">\n<nav class=\"nav-main mega-menu\">\n<ul class=\"nav nav-pills nav-main\" id=\"mainMenu\">\n<li class=\"dropdown no-sub-menu\"> <a class=\"dropdown\" href=\"index.htm\"><i class=\"icon icon-home\"></i> Home</a> </li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"/questions/index.php\"><i class=\"fa fa-send\"></i> Q/A </a> </li>\n<li class=\"dropdown\"><a class=\"dropdown\" href=\"tutorialslibrary.htm\"><span class=\"tut-lib\"> Library </span></a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"videotutorials/index.htm\"><i class=\"fa-toggle-right\"></i> Videos </a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"tutor_connect/index.php\"><i class=\"fa-user\"> </i> Tutors</a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"codingground.htm\"><i class=\"fa-code\"></i> Coding Ground </a> </li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"https://store.tutorialspoint.com/\"><i class=\"fa-usd\"></i> Store </a> </li>\n<li class=\"dropdown no-sub-menu\">\n<div class=\"searchform-popup\">\n<input autocomplete=\"off\" class=\"header-search-box\" id=\"search-string\" name=\"q\" onblur=\"if (this.value == '') {this.value = 'Search your favorite tutorials...';}\" onfocus=\"if (this.value == 'Search your favorite tutorials...') {this.value = '';}\" placeholder=\"Search your favorite tutorials...\" type=\"text\"/>\n<div class=\"magnifying-glass\"><i class=\"icon-search\"></i> Search </div>\n</div>\n</li>\n</ul>\n</nav>\n</div>\n</div>\n</div>\n</header></body></html>\n\n<div style=\"clear:both;\"></div>\n<div class=\"main\" role=\"main\">\n<div class=\"container\">\n<div class=\"row\">\n<div class=\"col-md-2\">\n<aside class=\"sidebar\">\n<div class=\"mini-logo\">\n<img alt=\"PL/SQL Tutorial\" src=\"/plsql/images/plsql-mini-logo.jpg\">\n</img></div>\n<ul class=\"nav nav-list primary left-menu\">\n<li class=\"heading\">PL/SQL Tutorial</li>\n<li><a href=\"/plsql/index.htm\">PL/SQL - Home</a></li>\n<li><a href=\"/plsql/plsql_overview.htm\">PL/SQL - Overview</a></li>\n<li><a href=\"/plsql/plsql_environment_setup.htm\">PL/SQL - Environment</a></li>\n<li><a href=\"/plsql/plsql_basic_syntax.htm\">PL/SQL - Basic Syntax</a></li>\n<li><a href=\"/plsql/plsql_data_types.htm\">PL/SQL - Data Types</a></li>\n<li><a href=\"/plsql/plsql_variable_types.htm\">PL/SQL - Variables</a></li>\n<li><a href=\"/plsql/plsql_constants.htm\">PL/SQL - Constants and Literals</a></li>\n<li><a href=\"/plsql/plsql_operators.htm\">PL/SQL - Operators</a></li>\n<li><a href=\"/plsql/plsql_conditional_control.htm\">PL/SQL - Conditions</a></li>\n<li><a href=\"/plsql/plsql_loops.htm\">PL/SQL - Loops </a></li>\n<li><a href=\"/plsql/plsql_strings.htm\">PL/SQL - Strings</a></li>\n<li><a href=\"/plsql/plsql_arrays.htm\">PL/SQL - Arrays</a></li>\n<li><a href=\"/plsql/plsql_procedures.htm\">PL/SQL - Procedures</a></li>\n<li><a href=\"/plsql/plsql_functions.htm\">PL/SQL - Functions</a></li>\n<li><a href=\"/plsql/plsql_cursors.htm\">PL/SQL - Cursors</a></li>\n<li><a href=\"/plsql/plsql_records.htm\">PL/SQL - Records</a></li>\n<li><a href=\"/plsql/plsql_exceptions.htm\">PL/SQL - Exceptions</a></li>\n<li><a href=\"/plsql/plsql_triggers.htm\">PL/SQL - Triggers</a></li>\n<li><a href=\"/plsql/plsql_packages.htm\">PL/SQL - Packages</a></li>\n<li><a href=\"/plsql/plsql_collections.htm\">PL/SQL - Collections</a></li>\n<li><a href=\"/plsql/plsql_transactions.htm\">PL/SQL - Transactions</a></li>\n<li><a href=\"/plsql/plsql_date_time.htm\">PL/SQL - Date &amp; Time</a></li>\n<li><a href=\"/plsql/plsql_dbms_output.htm\">PL/SQL - DBMS Output</a></li>\n<li><a href=\"/plsql/plsql_object_oriented.htm\">PL/SQL - Object Oriented</a></li>\n</ul>\n<ul class=\"nav nav-list primary left-menu\">\n<li class=\"heading\">PL/SQL Useful Resources</li>\n<li><a href=\"/plsql/plsql_questions_answers.htm\">PL/SQL - Questions and Answers</a></li>\n<li><a href=\"/plsql/plsql_quick_guide.htm\">PL/SQL - Quick Guide</a></li>\n<li><a href=\"/plsql/plsql_useful_resources.htm\">PL/SQL - Useful Resources</a></li>\n<li><a href=\"/plsql/plsql_discussion.htm\">PL/SQL - Discussion</a></li>\n</ul>\n<ul class=\"nav nav-list primary push-bottom left-menu special\">\n<li class=\"sreading\">Selected Reading</li>\n<li><a href=\"/upsc_ias_exams.htm\" target=\"_top\">UPSC IAS Exams Notes</a></li>\n<li><a href=\"/developers_best_practices/index.htm\" target=\"_top\">Developer's Best Practices</a></li>\n<li><a href=\"/questions_and_answers.htm\" target=\"_top\">Questions and Answers</a></li>\n<li><a href=\"/effective_resume_writing.htm\" target=\"_top\">Effective Resume Writing</a></li>\n<li><a href=\"/hr_interview_questions/index.htm\" target=\"_top\">HR Interview Questions</a></li>\n<li><a href=\"/computer_glossary.htm\" target=\"_top\">Computer Glossary</a></li>\n<li><a href=\"/computer_whoiswho.htm\" target=\"_top\">Who is Who</a></li>\n</ul>\n</aside>\n</div>\n<!-- PRINTING STARTS HERE -->\n<div class=\"row\">\n<div class=\"content\">\n<div class=\"col-md-7 middle-col\">\n<h1>PL/SQL - Quick Guide</h1>\n<hr/>\n<div style=\"padding-bottom:5px;padding-left:10px;text-align: center;\">Advertisements</div>\n<div style=\"text-align: center;\">\n<script type=\"text/javascript\"><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\" type=\"text/javascript\">\n</script>\n</div>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/plsql/plsql_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/plsql/plsql_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<div class=\"clearer\"></div>\n<hr/>\n<h1>PL/SQL - Overview</h1>\n<p>The PL/SQL programming language was developed by Oracle Corporation in the late 1980s as procedural extension language for SQL and the Oracle relational database. Following are certain notable facts about PL/SQL \u2212</p>\n<ul class=\"list\">\n<li><p>PL/SQL is a completely portable, high-performance transaction-processing language.</p></li>\n<li><p>PL/SQL provides a built-in, interpreted and OS independent programming environment.</p></li>\n<li><p>PL/SQL can also directly be called from the command-line <b>SQL*Plus interface</b>.</p></li>\n<li><p>Direct call can also be made from external programming language calls to database.</p></li>\n<li><p>PL/SQL's general syntax is based on that of ADA and Pascal programming language.</p></li>\n<li><p>Apart from Oracle, PL/SQL is available in <b>TimesTen in-memory database</b> and <b>IBM DB2</b>.</p></li>\n</ul>\n<h2>Features of PL/SQL</h2>\n<p>PL/SQL has the following features \u2212</p>\n<ul class=\"list\">\n<li>PL/SQL is tightly integrated with SQL.</li>\n<li>It offers extensive error checking.</li>\n<li>It offers numerous data types.</li>\n<li>It offers a variety of programming structures.</li>\n<li>It supports structured programming through functions and procedures.</li>\n<li>It supports object-oriented programming.</li>\n<li>It supports the development of web applications and server pages.</li>\n</ul>\n<h2>Advantages of PL/SQL</h2>\n<p>PL/SQL has the following advantages \u2212</p>\n<ul class=\"list\">\n<li><p>SQL is the standard database language and PL/SQL is strongly integrated with SQL. PL/SQL supports both static and dynamic SQL. Static SQL supports DML operations and transaction control from PL/SQL block. In Dynamic SQL, SQL allows embedding DDL statements in PL/SQL blocks.</p></li>\n<li><p>PL/SQL allows sending an entire block of statements to the database at one time. This reduces network traffic and provides high performance for the applications.</p></li>\n<li><p>PL/SQL gives high productivity to programmers as it can query, transform, and update data in a database.</p></li>\n<li><p>PL/SQL saves time on design and debugging by strong features, such as exception handling, encapsulation, data hiding, and object-oriented data types.</p></li>\n<li><p>Applications written in PL/SQL are fully portable.</p></li>\n<li><p>PL/SQL provides high security level.</p></li>\n<li><p>PL/SQL provides access to predefined SQL packages.</p></li>\n<li><p>PL/SQL provides support for Object-Oriented Programming.</p></li>\n<li><p>PL/SQL provides support for developing Web Applications and Server Pages.</p></li>\n</ul>\n<h1>PL/SQL - Environment Setup</h1>\n<p>In this chapter, we will discuss the Environment Setup of PL/SQL. PL/SQL is not a standalone programming language; it is a tool within the Oracle programming environment. <b>SQL* Plus</b> is an interactive tool that allows you to type SQL and PL/SQL statements at the command prompt. These commands are then sent to the database for processing. Once the statements are processed, the results are sent back and displayed on screen.</p>\n<p>To run PL/SQL programs, you should have the Oracle RDBMS Server installed in your machine. This will take care of the execution of the SQL commands. The most recent version of Oracle RDBMS is 11g. You can download a trial version of Oracle 11g from the following link \u2212</p>\n<p><a href=\"https://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html\" rel=\"nofollow\" target=\"_blank\">Download Oracle 11g Express Edition</a></p>\n<p>You will have to download either the 32-bit or the 64-bit version of the installation as per your operating system. Usually there are two files. We have downloaded the 64-bit version. You will also use similar steps on your operating system, does not matter if it is Linux or Solaris.</p>\n<ul class=\"list\">\n<li><p><b>win64_11gR2_database_1of2.zip</b></p></li>\n<li><p><b>win64_11gR2_database_2of2.zip</b></p></li>\n</ul>\n<p>After downloading the above two files, you will need to unzip them in a single directory <b>database</b> and under that you will find the following sub-directories \u2212</p>\n<img alt=\"Oracle Sub Directries\" src=\"/plsql/images/oracle_sub_directories.jpg\">\n<h3>Step 1</h3>\n<p>Let us now launch the Oracle Database Installer using the setup file. Following is the first screen. You can provide your email ID and check the checkbox as shown in the following screenshot. Click the <b>Next</b> button.</p>\n<img alt=\"Oracle Install 1\" src=\"/plsql/images/oracle_install_step1.jpg\"/>\n<h3>Step 2</h3>\n<p>You will be directed to the following screen; uncheck the checkbox and click the <b>Continue</b> button to proceed.</p>\n<img alt=\"Oracle install error\" src=\"/plsql/images/oracle_install_error1.jpg\"/>\n<h3>Step 3</h3>\n<p>Just select the first option <b>Create and Configure Database</b> using the radio button and click the <b>Next</b> button to proceed.</p>\n<img alt=\"Oracle Install 2\" src=\"/plsql/images/oracle_install_step2.jpg\"/>\n<h3>Step 4</h3>\n<p>We assume you are installing Oracle for the basic purpose of learning and that you are installing it on your PC or Laptop. Thus, select the <b>Desktop Class</b> option and click the <b>Next</b> button to proceed.</p>\n<img alt=\"Oracle Install 3\" src=\"/plsql/images/oracle_install_step3.jpg\"/>\n<h3>Step 5</h3>\n<p>Provide a location, where you will install the Oracle Server. Just modify the <b>Oracle Base</b> and the other locations will set automatically. You will also have to provide a password; this will be used by the system DBA. Once you provide the required information, click the <b>Next</b> button to proceed.</p>\n<img alt=\"Oracle Install 4\" src=\"/plsql/images/oracle_install_step4.jpg\"/>\n<h3>Step 6</h3>\n<p>Again, click the <b>Next</b> button to proceed.</p>\n<img alt=\"Oracle Install 5\" src=\"/plsql/images/oracle_install_step5.jpg\"/>\n<h3>Step 7</h3>\n<p>Click the <b>Finish</b> button to proceed; this will start the actual server installation.</p>\n<img alt=\"Oracle Install 6\" src=\"/plsql/images/oracle_install_step6.jpg\"/>\n<h3>Step 8</h3>\n<p>This will take a few moments, until Oracle starts performing the required configuration.</p>\n<img alt=\"Oracle Install 7\" src=\"/plsql/images/oracle_install_step7.jpg\"/>\n<h3>Step 9</h3>\n<p>Here, Oracle installation will copy the required configuration files. This should take a moment \u2212</p>\n<img alt=\"Oracle Configuration\" src=\"/plsql/images/oracle_install_configuration1.jpg\"/>\n<h3>Step 10</h3>\n<p>Once the database files are copied, you will have the following dialogue box. Just click the <b>OK</b> button and come out.</p>\n<img alt=\"Oracle Configuration\" src=\"/plsql/images/oracle_install_configuration2.jpg\"/>\n<h3>Step 11</h3>\n<p>Upon installation, you will have the following final window.</p>\n<img alt=\"Oracle Install 8\" src=\"/plsql/images/oracle_install_step8.jpg\"/>\n<h3>Final Step</h3>\n<p>It is now time to verify your installation. At the command prompt, use the following command if you are using Windows \u2212</p>\n<pre class=\"result notranslate\">\nsqlplus \"/ as sysdba\"\n</pre>\n<p>You should have the SQL prompt where you will write your PL/SQL commands and scripts \u2212</p>\n<img alt=\"PL/SQL Command Prompt\" src=\"/plsql/images/plsql_command_prompt.jpg\"/>\n<h2>Text Editor</h2>\n<p>Running large programs from the command prompt may land you in inadvertently losing some of the work. It is always recommended to use the command files. To use the command files \u2212</p>\n<ul class=\"list\">\n<li><p>Type your code in a text editor, like <b>Notepad, Notepad+,</b> or <b>EditPlus</b>, etc.</p></li>\n<li><p>Save the file with the <b>.sql</b> extension in the home directory.</p></li>\n<li><p>Launch the <b>SQL*Plus command prompt</b> from the directory where you created your PL/SQL file.</p></li>\n<li><p>Type <b>@file_name</b> at the SQL*Plus command prompt to execute your program.</p></li>\n</ul>\n<p>If you are not using a file to execute the PL/SQL scripts, then simply copy your PL/SQL code and right-click on the black window that displays the SQL prompt; use the <b>paste</b> option to paste the complete code at the command prompt. Finally, just press <b>Enter</b> to execute the code, if it is not already executed.</p>\n<h1>PL/SQL - Basic Syntax</h1>\n<p>In this chapter, we will discuss the Basic Syntax of PL/SQL which is a <b>block-structured</b> language; this means that the PL/SQL programs are divided and written in logical blocks of code. Each block consists of three sub-parts \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Sections &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td>\n<p><b>Declarations</b></p>\n<p>This section starts with the keyword <b>DECLARE</b>. It is an optional section and defines all variables, cursors, subprograms, and other elements to be used in the program.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td>\n<p><b>Executable Commands</b></p>\n<p>This section is enclosed between the keywords <b>BEGIN</b> and <b>END</b> and it is a mandatory section. It consists of the executable PL/SQL statements of the program. It should have at least one executable line of code, which may be just a <b>NULL command</b> to indicate that nothing should be executed.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>Exception Handling</b></p>\n<p>This section starts with the keyword <b>EXCEPTION</b>. This optional section contains <b>exception(s)</b> that handle errors in the program.</p></td>\n</tr></table></img></div></div></div></div></div></div>\n\n\n<p>Every PL/SQL statement ends with a semicolon (;). PL/SQL blocks can be nested within other PL/SQL blocks using <b>BEGIN</b> and <b>END</b>. Following is the basic structure of a PL/SQL block \u2212</p>\n<pre class=\"result notranslate\">\nDECLARE \n   &lt;declarations section&gt; \nBEGIN \n   &lt;executable command(s)&gt;\nEXCEPTION \n   &lt;exception handling&gt; \nEND;\n</pre>\n<h2>The 'Hello World' Example</h2>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   message  varchar2(20):= 'Hello, World!'; \nBEGIN \n   dbms_output.put_line(message); \nEND; \n/ \n</pre>\n<p>The <b>end;</b> line signals the end of the PL/SQL block. To run the code from the SQL command line, you may need to type / at the beginning of the first blank line after the last line of the code. When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nHello World  \n\nPL/SQL procedure successfully completed.\n</pre>\n<h2>The PL/SQL Identifiers</h2>\n<p>PL/SQL identifiers are constants, variables, exceptions, procedures, cursors, and reserved words. The identifiers consist of a letter optionally followed by more letters, numerals, dollar signs, underscores, and number signs and should not exceed 30 characters.</p>\n<p>By default, <b>identifiers are not case-sensitive</b>. So you can use <b>integer</b> or <b>INTEGER</b> to represent a numeric value. You cannot use a reserved keyword as an identifier.</p>\n<h2>The PL/SQL Delimiters</h2>\n<p>A delimiter is a symbol with a special meaning. Following is the list of delimiters in PL/SQL \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Delimiter</th>\n<th style=\"text-align:center;\">Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>+, -, *, /</b></td>\n<td>Addition, subtraction/negation, multiplication, division</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>%</b></td>\n<td>Attribute indicator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>'</b></td>\n<td>Character string delimiter</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>.</b></td>\n<td>Component selector</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>(,)</b></td>\n<td>Expression or list delimiter</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>:</b></td>\n<td>Host variable indicator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>,</b></td>\n<td>Item separator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>\"</b></td>\n<td>Quoted identifier delimiter</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>=</b></td>\n<td>Relational operator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>@</b></td>\n<td>Remote access indicator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>;</b></td>\n<td>Statement terminator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>:=</b></td>\n<td>Assignment operator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>=&gt;</b></td>\n<td>Association operator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>||</b></td>\n<td>Concatenation operator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>**</b></td>\n<td>Exponentiation operator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>&lt;&lt;, &gt;&gt;</b></td>\n<td>Label delimiter (begin and end)</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>/*, */</b></td>\n<td>Multi-line comment delimiter (begin and end)</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>--</b></td>\n<td>Single-line comment indicator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>..</b></td>\n<td>Range operator</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>&lt;, &gt;, &lt;=, &gt;=</b></td>\n<td>Relational operators</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><b>&lt;&gt;, '=, ~=, ^=</b></td>\n<td>Different versions of NOT EQUAL</td>\n</tr>\n</table>\n<h2>The PL/SQL Comments</h2>\n<p>Program comments are explanatory statements that can be included in the PL/SQL code that you write and helps anyone reading its source code. All programming languages allow some form of comments.</p>\n<p>The PL/SQL supports single-line and multi-line comments. All characters available inside any comment are ignored by the PL/SQL compiler. The PL/SQL single-line comments start with the delimiter -- (double hyphen) and multi-line comments are enclosed by /* and */.</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   -- variable declaration \n   message  varchar2(20):= 'Hello, World!'; \nBEGIN \n   /* \n   *  PL/SQL executable statement(s) \n   */ \n   dbms_output.put_line(message); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"prettyprint notranslate\">\nHello World\n\nPL/SQL procedure successfully completed.\n</pre>\n<h2>PL/SQL Program Units</h2>\n<p>A PL/SQL unit is any one of the following \u2212</p>\n<ul class=\"list\">\n<li>PL/SQL block</li>\n<li>Function</li>\n<li>Package</li>\n<li>Package body</li>\n<li>Procedure</li>\n<li>Trigger</li>\n<li>Type</li>\n<li>Type body</li>\n</ul>\n<p>Each of these units will be discussed in the following chapters.</p>\n<h1>PL/SQL - Data Types</h1>\n<p>In this chapter, we will discuss the Data Types in PL/SQL. The PL/SQL variables, constants and parameters must have a valid data type, which specifies a storage format, constraints, and a valid range of values. We will focus on the <b>SCALAR</b> and the <b>LOB</b> data types in this chapter. The other two data types will be covered in other chapters.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Category &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>Scalar</b></p>\n<p>Single values with no internal components, such as a <b>NUMBER, DATE,</b> or <b>BOOLEAN</b>.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>Large Object (LOB)</b></p>\n<p>Pointers to large objects that are stored separately from other data items, such as text, graphic images, video clips, and sound waveforms.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>Composite</b></p>\n<p>Data items that have internal components that can be accessed individually. For example, collections and records.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>Reference</b></p>\n<p>Pointers to other data items.</p></td>\n</tr>\n</table>\n<h2>PL/SQL Scalar Data Types and Subtypes</h2>\n<p>PL/SQL Scalar Data Types and Subtypes come under the following categories \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Date Type &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>Numeric</b></p>\n<p>Numeric values on which arithmetic operations are performed.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>Character</b></p>\n<p>Alphanumeric values that represent single characters or strings of characters.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>Boolean</b></p>\n<p>Logical values on which logical operations are performed.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>Datetime</b></p>\n<p>Dates and times.</p></td>\n</tr>\n</table>\n<p>PL/SQL provides subtypes of data types. For example, the data type NUMBER has a subtype called INTEGER. You can use the subtypes in your PL/SQL program to make the data types compatible with data types in other programs while embedding the PL/SQL code in another program, such as a Java program.</p>\n<h2>PL/SQL Numeric Data Types and Subtypes</h2>\n<p>Following table lists out the PL/SQL pre-defined numeric data types and their sub-types \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Data Type &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>PLS_INTEGER</b></p>\n<p>Signed integer in range -2,147,483,648 through 2,147,483,647, represented in 32 bits</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>BINARY_INTEGER</b></p>\n<p>Signed integer in range -2,147,483,648 through 2,147,483,647, represented in 32 bits</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>BINARY_FLOAT</b></p>\n<p>Single-precision IEEE 754-format floating-point number</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>BINARY_DOUBLE</b></p>\n<p>Double-precision IEEE 754-format floating-point number</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><p><b>NUMBER(prec, scale)</b></p>\n<p>Fixed-point or floating-point number with absolute value in range 1E-130 to (but not including) 1.0E126. A NUMBER variable can also represent 0</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">6</td>\n<td><p><b>DEC(prec, scale)</b></p>\n<p>ANSI specific fixed-point type with maximum precision of 38 decimal digits</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">7</td>\n<td><p><b>DECIMAL(prec, scale)</b></p>\n<p>IBM specific fixed-point type with maximum precision of 38 decimal digits</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">8</td>\n<td><p><b>NUMERIC(pre, secale)</b></p>\n<p>Floating type with maximum precision of 38 decimal digits</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">9</td>\n<td><p><b>DOUBLE PRECISION</b></p>\n<p>ANSI specific floating-point type with maximum precision of 126 binary digits (approximately 38 decimal digits)</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">10</td>\n<td><p><b>FLOAT</b></p>\n<p>ANSI and IBM specific floating-point type with maximum precision of 126 binary digits (approximately 38 decimal digits)</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">11</td>\n<td><p><b>INT</b></p>\n<p>ANSI specific integer type with maximum precision of 38 decimal digits</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">12</td>\n<td><p><b>INTEGER</b></p>\n<p>ANSI and IBM specific integer type with maximum precision of 38 decimal digits</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">13</td>\n<td><p><b>SMALLINT</b></p>\n<p>ANSI and IBM specific integer type with maximum precision of 38 decimal digits</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">14</td>\n<td><p><b>REAL</b></p>\n<p>Floating-point type with maximum precision of 63 binary digits (approximately 18 decimal digits)</p></td>\n</tr>\n</table>\n<p>Following is a valid declaration \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   num1 INTEGER; \n   num2 REAL; \n   num3 DOUBLE PRECISION; \nBEGIN \n   null; \nEND; \n/ \n</pre>\n<p>When the above code is compiled and executed, it produces the following result \u2212</p>\n<pre class=\"prettyprint notranslate\">\nPL/SQL procedure successfully completed \n</pre>\n<h2>PL/SQL Character Data Types and Subtypes</h2>\n<p>Following is the detail of PL/SQL pre-defined character data types and their sub-types \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Data Type &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>CHAR</b></p>\n<p>Fixed-length character string with maximum size of 32,767 bytes</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>VARCHAR2</b></p>\n<p>Variable-length character string with maximum size of 32,767 bytes</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>RAW</b></p>\n<p>Variable-length binary or byte string with maximum size of 32,767 bytes, not interpreted by PL/SQL</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>NCHAR</b></p>\n<p>Fixed-length national character string with maximum size of 32,767 bytes</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><p><b>NVARCHAR2</b></p>\n<p>Variable-length national character string with maximum size of 32,767 bytes</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">6</td>\n<td><p><b>LONG</b></p>\n<p>Variable-length character string with maximum size of 32,760 bytes</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">7</td>\n<td><p><b>LONG RAW</b></p>\n<p>Variable-length binary or byte string with maximum size of 32,760 bytes, not interpreted by PL/SQL</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">8</td>\n<td><p><b>ROWID</b></p>\n<p>Physical row identifier, the address of a row in an ordinary table</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">9</td>\n<td><p><b>UROWID</b></p>\n<p>Universal row identifier (physical, logical, or foreign row identifier)</p></td>\n</tr>\n</table>\n<h2>PL/SQL Boolean Data Types</h2>\n<p>The <b>BOOLEAN</b> data type stores logical values that are used in logical operations. The logical values are the Boolean values <b>TRUE</b> and <b>FALSE</b> and the value <b>NULL</b>.</p>\n<p>However, SQL has no data type equivalent to BOOLEAN. Therefore, Boolean values cannot be used in \u2212 </p>\n<ul class=\"list\">\n<li>SQL statements</li>\n<li>Built-in SQL functions (such as <b>TO_CHAR</b>)</li>\n<li>PL/SQL functions invoked from SQL statements</li>\n</ul>\n<h2>PL/SQL Datetime and Interval Types</h2>\n<p>The <b>DATE</b> datatype is used to store fixed-length datetimes, which include the time of day in seconds since midnight. Valid dates range from January 1, 4712 BC to December 31, 9999 AD.</p>\n<p>The default date format is set by the Oracle initialization parameter NLS_DATE_FORMAT. For example, the default might be 'DD-MON-YY', which includes a two-digit number for the day of the month, an abbreviation of the month name, and the last two digits of the year. For example, 01-OCT-12.</p>\n<p>Each DATE includes the century, year, month, day, hour, minute, and second. The following table shows the valid values for each field \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Field Name</th>\n<th style=\"text-align:center;\">Valid Datetime Values</th>\n<th style=\"text-align:center;\">Valid Interval Values</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">YEAR</td>\n<td>-4712 to 9999 (excluding year 0)</td>\n<td style=\"vertical-align:middle;\">Any nonzero integer</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">MONTH</td>\n<td>01 to 12</td>\n<td>0 to 11</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">DAY</td>\n<td>01 to 31 (limited by the values of MONTH and YEAR, according to the rules of the calendar for the locale)</td>\n<td style=\"vertical-align:middle;\">Any nonzero integer</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">HOUR</td>\n<td>00 to 23</td>\n<td>0 to 23</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">MINUTE</td>\n<td>00 to 59</td>\n<td>0 to 59</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">SECOND</td>\n<td>00 to 59.9(n), where 9(n) is the precision of time fractional seconds</td>\n<td>0 to 59.9(n), where 9(n) is the precision of interval fractional seconds</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TIMEZONE_HOUR</td>\n<td>-12 to 14 (range accommodates daylight savings time changes)</td>\n<td style=\"vertical-align:middle;\">Not applicable</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TIMEZONE_MINUTE</td>\n<td>00 to 59</td>\n<td style=\"vertical-align:middle;\">Not applicable</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TIMEZONE_REGION</td>\n<td>Found in the dynamic performance view V$TIMEZONE_NAMES</td>\n<td style=\"vertical-align:middle;\">Not applicable</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TIMEZONE_ABBR</td>\n<td>Found in the dynamic performance view V$TIMEZONE_NAMES</td>\n<td style=\"vertical-align:middle;\">Not applicable</td>\n</tr>\n</table>\n<h2>PL/SQL Large Object (LOB) Data Types</h2>\n<p>Large Object (LOB) data types refer to large data items such as text, graphic images, video clips, and sound waveforms. LOB data types allow efficient, random, piecewise access to this data. Following are the predefined PL/SQL LOB data types \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center; width:20%\">Data Type</th>\n<th style=\"text-align:center;\">Description</th>\n<th style=\"text-align:center;\">Size</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">BFILE</td>\n<td>Used to store large binary objects in operating system files outside the database.</td>\n<td>System-dependent. Cannot exceed 4 gigabytes (GB).</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">BLOB</td>\n<td>Used to store large binary objects in the database.</td>\n<td>8 to 128 terabytes (TB)</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">CLOB</td>\n<td>Used to store large blocks of character data in the database.</td>\n<td>8 to 128 TB</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">NCLOB</td>\n<td>Used to store large blocks of NCHAR data in the database.</td>\n<td>8 to 128 TB</td>\n</tr>\n</table>\n<h2>PL/SQL User-Defined Subtypes</h2>\n<p>A subtype is a subset of another data type, which is called its base type. A subtype has the same valid operations as its base type, but only a subset of its valid values.</p>\n<p>PL/SQL predefines several subtypes in package <b>STANDARD</b>. For example, PL/SQL predefines the subtypes <b>CHARACTER</b> and <b>INTEGER</b> as follows \u2212</p>\n<pre class=\"result notranslate\">\nSUBTYPE CHARACTER IS CHAR; \nSUBTYPE INTEGER IS NUMBER(38,0);\n</pre>\n<p>You can define and use your own subtypes. The following program illustrates defining and using a user-defined subtype \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   SUBTYPE name IS char(20); \n   SUBTYPE message IS varchar2(100); \n   salutation name; \n   greetings message; \nBEGIN \n   salutation := 'Reader '; \n   greetings := 'Welcome to the World of PL/SQL'; \n   dbms_output.put_line('Hello ' || salutation || greetings); \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nHello Reader Welcome to the World of PL/SQL \n \nPL/SQL procedure successfully completed. \n</pre>\n<h2>NULLs in PL/SQL</h2>\n<p>PL/SQL NULL values represent <b>missing</b> or <b>unknown data</b> and they are not an integer, a character, or any other specific data type. Note that <b>NULL</b> is not the same as an empty data string or the null character value <b>'\\0'</b>. A null can be assigned but it cannot be equated with anything, including itself.</p>\n<h1>PL/SQL - Variables</h1>\n<p>In this chapter, we will discuss Variables in Pl/SQL. A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in PL/SQL has a specific data type, which determines the size and the layout of the variable's memory; the range of values that can be stored within that memory and the set of operations that can be applied to the variable.</p>\n<p>The name of a PL/SQL variable consists of a letter optionally followed by more letters, numerals, dollar signs, underscores, and number signs and should not exceed 30 characters. By default, variable names are not case-sensitive. You cannot use a reserved PL/SQL keyword as a variable name.</p>\n<p>PL/SQL programming language allows to define various types of variables, such as date time data types, records, collections, etc. which we will cover in subsequent chapters. For this chapter, let us study only basic variable types.</p>\n<h2>Variable Declaration in PL/SQL</h2>\n<p>PL/SQL variables must be declared in the declaration section or in a package as a global variable. When you declare a variable, PL/SQL allocates memory for the variable's value and the storage location is identified by the variable name.</p>\n<p>The syntax for declaring a variable is \u2212</p>\n<pre class=\"result notranslate\">\nvariable_name [CONSTANT] datatype [NOT NULL] [:= | DEFAULT initial_value] \n</pre>\n<p>Where, <i>variable_name</i> is a valid identifier in PL/SQL, <i>datatype</i> must be a valid PL/SQL data type or any user defined data type which we already have discussed in the last chapter. Some valid variable declarations along with their definition are shown below \u2212</p>\n<pre class=\"result notranslate\">\nsales number(10, 2); \npi CONSTANT double precision := 3.1415; \nname varchar2(25); \naddress varchar2(100);\n</pre>\n<p>When you provide a size, scale or precision limit with the data type, it is called a <b>constrained declaration</b>. Constrained declarations require less memory than unconstrained declarations. For example \u2212</p>\n<pre class=\"result notranslate\">\nsales number(10, 2); \nname varchar2(25); \naddress varchar2(100); \n</pre>\n<h2>Initializing Variables in PL/SQL</h2>\n<p>Whenever you declare a variable, PL/SQL assigns it a default value of NULL. If you want to initialize a variable with a value other than the NULL value, you can do so during the declaration, using either of the following \u2212</p>\n<ul class=\"list\">\n<li><p>The <b>DEFAULT</b> keyword</p></li>\n<li><p>The <b>assignment</b> operator</p></li>\n</ul>\n<p>For example \u2212</p>\n<pre class=\"result notranslate\">\ncounter binary_integer := 0; \ngreetings varchar2(20) DEFAULT 'Have a Good Day';\n</pre>\n<p>You can also specify that a variable should not have a <b>NULL</b> value using the <b>NOT NULL</b> constraint. If you use the NOT NULL constraint, you must explicitly assign an initial value for that variable.</p>\n<p>It is a good programming practice to initialize variables properly otherwise, sometimes programs would produce unexpected results. Try the following example which makes use of various types of variables \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   a integer := 10; \n   b integer := 20; \n   c integer; \n   f real; \nBEGIN \n   c := a + b; \n   dbms_output.put_line('Value of c: ' || c); \n   f := 70.0/3.0; \n   dbms_output.put_line('Value of f: ' || f); \nEND; \n/  \n</pre>\n<p>When the above code is executed, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nValue of c: 30 \nValue of f: 23.333333333333333333  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>Variable Scope in PL/SQL</h2>\n<p>PL/SQL allows the nesting of blocks, i.e., each program block may contain another inner block. If a variable is declared within an inner block, it is not accessible to the outer block. However, if a variable is declared and accessible to an outer block, it is also accessible to all nested inner blocks. There are two types of variable scope \u2212</p>\n<ul class=\"list\">\n<li><p><b>Local variables</b> \u2212 Variables declared in an inner block and not accessible to outer blocks.</p></li>\n<li><p><b>Global variables</b> \u2212 Variables declared in the outermost block or a package.</p></li>\n</ul>\n<p>Following example shows the usage of <b>Local</b> and <b>Global</b> variables in its simple form \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   -- Global variables  \n   num1 number := 95;  \n   num2 number := 85;  \nBEGIN  \n   dbms_output.put_line('Outer Variable num1: ' || num1); \n   dbms_output.put_line('Outer Variable num2: ' || num2); \n   DECLARE  \n      -- Local variables \n      num1 number := 195;  \n      num2 number := 185;  \n   BEGIN  \n      dbms_output.put_line('Inner Variable num1: ' || num1); \n      dbms_output.put_line('Inner Variable num2: ' || num2); \n   END;  \nEND; \n/ \n</pre>\n<p>When the above code is executed, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nOuter Variable num1: 95 \nOuter Variable num2: 85 \nInner Variable num1: 195 \nInner Variable num2: 185  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>Assigning SQL Query Results to PL/SQL Variables</h2>\n<p>You can use the <b>SELECT INTO</b> statement of SQL to assign values to PL/SQL variables. For each item in the <b>SELECT list</b>, there must be a corresponding, type-compatible variable in the <b>INTO list</b>. The following example illustrates the concept. Let us create a table named CUSTOMERS \u2212</p>\n<p>(<b>For SQL statements, please refer to the <a href=\"/sql/index.htm\">SQL tutorial</a></b>)</p>\n<pre class=\"prettyprint notranslate\">\nCREATE TABLE CUSTOMERS( \n   ID   INT NOT NULL, \n   NAME VARCHAR (20) NOT NULL, \n   AGE INT NOT NULL, \n   ADDRESS CHAR (25), \n   SALARY   DECIMAL (18, 2),        \n   PRIMARY KEY (ID) \n);  \n\nTable Created  \n</pre>\n<p>Let us now insert some values in the table \u2212</p>\n<pre class=\"prettyprint notranslate\">\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (1, 'Ramesh', 32, 'Ahmedabad', 2000.00 );  \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (2, 'Khilan', 25, 'Delhi', 1500.00 );  \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (3, 'kaushik', 23, 'Kota', 2000.00 );\n  \nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (4, 'Chaitali', 25, 'Mumbai', 6500.00 ); \n \nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (5, 'Hardik', 27, 'Bhopal', 8500.00 );  \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (6, 'Komal', 22, 'MP', 4500.00 ); \n</pre>\n<p>The following program assigns values from the above table to PL/SQL variables using the <b>SELECT INTO clause</b> of SQL \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   c_id customers.id%type := 1; \n   c_name  customers.name%type; \n   c_addr customers.address%type; \n   c_sal  customers.salary%type; \nBEGIN \n   SELECT name, address, salary INTO c_name, c_addr, c_sal \n   FROM customers \n   WHERE id = c_id;  \n   dbms_output.put_line \n   ('Customer ' ||c_name || ' from ' || c_addr || ' earns ' || c_sal); \nEND; \n/  \n</pre>\n<p>When the above code is executed, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nCustomer Ramesh from Ahmedabad earns 2000  \n\nPL/SQL procedure completed successfully\n</pre>\n<h1>PL/SQL - Constants and Literals</h1>\n<p>In this chapter, we will discuss <b>constants</b> and <b>literals</b> in PL/SQL. A constant holds a value that once declared, does not change in the program. A constant declaration specifies its name, data type, and value, and allocates storage for it. The declaration can also impose the <b>NOT NULL constraint</b>.</p>\n<h2>Declaring a Constant</h2>\n<p>A constant is declared using the <b>CONSTANT</b> keyword. It requires an initial value and does not allow that value to be changed. For example \u2212</p>\n<pre class=\"prettyprint notranslate\">\nPI CONSTANT NUMBER := 3.141592654; \nDECLARE \n   -- constant declaration \n   pi constant number := 3.141592654; \n   -- other declarations \n   radius number(5,2);  \n   dia number(5,2);  \n   circumference number(7, 2); \n   area number (10, 2); \nBEGIN  \n   -- processing \n   radius := 9.5;  \n   dia := radius * 2;  \n   circumference := 2.0 * pi * radius; \n   area := pi * radius * radius; \n   -- output \n   dbms_output.put_line('Radius: ' || radius); \n   dbms_output.put_line('Diameter: ' || dia); \n   dbms_output.put_line('Circumference: ' || circumference); \n   dbms_output.put_line('Area: ' || area); \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nRadius: 9.5 \nDiameter: 19 \nCircumference: 59.69 \nArea: 283.53  \n\nPl/SQL procedure successfully completed. \n</pre>\n<h2>The PL/SQL Literals</h2>\n<p>A literal is an explicit numeric, character, string, or Boolean value not represented by an identifier. For example, TRUE, 786, NULL, 'tutorialspoint' are all literals of type Boolean, number, or string. PL/SQL, literals are case-sensitive. PL/SQL supports the following kinds of literals \u2212</p>\n<ul class=\"list\">\n<li>Numeric Literals</li>\n<li>Character Literals</li>\n<li>String Literals</li>\n<li>BOOLEAN Literals</li>\n<li>Date and Time Literals</li>\n</ul>\n<p>The following table provides examples from all these categories of literal values.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center; width:10%\">S.No</th>\n<th style=\"text-align:center;\">Literal Type &amp; Example</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>Numeric Literals</b></p>\n<p>050   78   -14   0   +32767</p>\n<p>6.6667   0.0   -12.0   3.14159   +7800.00</p>\n<p>6E5   1.0E-8   3.14159e0   -1E38   -9.5e-3</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>Character Literals</b></p>\n<p>'A'   '%'   '9'   ' '   'z'   '('</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>String Literals</b></p>\n<p>'Hello, world!'</p>\n<p>'Tutorials Point'</p>\n<p>'19-NOV-12'</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>BOOLEAN Literals</b></p>\n<p>TRUE, FALSE, and NULL.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><p><b>Date and Time Literals</b></p>\n<p>DATE '1978-12-25';</p>\n<p>TIMESTAMP '2012-10-29 12:01:01';</p>\n</td>\n</tr>\n</table>\n<p>To embed single quotes within a string literal, place two single quotes next to each other as shown in the following program \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   message  varchar2(30):= 'That''s tutorialspoint.com!'; \nBEGIN \n   dbms_output.put_line(message); \nEND; \n/  \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nThat's tutorialspoint.com!  \n\nPL/SQL procedure successfully completed.\n</pre>\n<h1>PL/SQL - Operators</h1>\n<p>In this chapter, we will discuss operators in PL/SQL. An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulation. PL/SQL language is rich in built-in operators and provides the following types of operators \u2212</p>\n<ul class=\"list\">\n<li>Arithmetic operators</li>\n<li>Relational operators</li>\n<li>Comparison operators</li>\n<li>Logical operators</li>\n<li>String operators</li>\n</ul>\n<p>Here, we will understand the arithmetic, relational, comparison and logical operators one by one. The String operators will be discussed in a later chapter \u2212 <b>PL/SQL - Strings</b>.</p>\n<h2>Arithmetic Operators</h2>\n<p>Following table shows all the arithmetic operators supported by PL/SQL. Let us assume <b>variable A</b> holds 10 and <b>variable B</b> holds 5, then \u2212</p>\n<p><a href=\"/plsql/plsql_arithmetic_operators.htm\" title=\"Arithmetic Operators in PL/SQL\">Show Examples</a></p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Operator</th>\n<th style=\"text-align:center;\">Description</th>\n<th style=\"text-align:center;\">Example</th>\n</tr>\n<tr>\n<td style=\"text-align:center;\">+</td>\n<td>Adds two operands</td>\n<td>A + B will give 15</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">-</td>\n<td>Subtracts second operand from the first</td>\n<td>A - B will give 5</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">*</td>\n<td>Multiplies both operands</td>\n<td>A * B will give 50</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">/</td>\n<td>Divides numerator by de-numerator</td>\n<td>A / B will give 2</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">**</td>\n<td>Exponentiation operator, raises one operand to the power of other</td>\n<td>A ** B will give 100000</td>\n</tr>\n</table>\n<h2>Relational Operators</h2>\n<p>Relational operators compare two expressions or values and return a Boolean result. Following table shows all the relational operators supported by PL/SQL. Let us assume <b>variable A</b> holds 10 and <b>variable B</b> holds 20, then \u2212</p>\n<p><a href=\"/plsql/plsql_relational_operators.htm\" title=\"Relational Operators in PL/SQL\">Show Examples</a></p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Operator</th>\n<th style=\"text-align:center;\">Description</th>\n<th style=\"text-align:center;\">Example</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">=</td>\n<td style=\"vertical-align:middle;\">Checks if the values of two operands are equal or not, if yes then condition becomes true.</td>\n<td>(A = B) is not true.</td>\n</tr>\n<tr>\n<td><p style=\"text-align:center;\">!=</p>\n<p style=\"text-align:center;\">&lt;&gt;</p>\n<p style=\"text-align:center;\">~=</p></td>\n<td style=\"vertical-align:middle;\">Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.</td>\n<td style=\"text-align:center; vertical-align:middle;\">(A != B) is true.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">&gt;</td>\n<td style=\"vertical-align:middle;\">Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.</td>\n<td>(A &gt; B) is not true.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">&lt;</td>\n<td style=\"vertical-align:middle;\">Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.</td>\n<td>(A &lt; B) is true.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">&gt;=</td>\n<td style=\"vertical-align:middle;\">Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td>\n<td> (A &gt;= B) is not true. </td>\n</tr>\n<td style=\"text-align:center; vertical-align:middle;\">&lt;=</td>\n<td style=\"vertical-align:middle;\">Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.</td>\n<td>(A &lt;= B) is true</td>\n</table>\n\n<h2>Comparison Operators</h2>\n<p>Comparison operators are used for comparing one expression to another. The result is always either <b>TRUE, FALSE</b> or <b>NULL</b>.</p>\n<p><a href=\"/plsql/plsql_comparison_operators.htm\" title=\"Comparison Operators in PL/SQL\">Show Examples</a></p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Operator</th>\n<th style=\"text-align:center;\">Description</th>\n<th style=\"text-align:center;\">Example</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">LIKE</td>\n<td style=\"vertical-align:middle;\">The LIKE operator compares a character, string, or CLOB value to a pattern and returns TRUE if the value matches the pattern and FALSE if it does not.</td>\n<td style=\"vertical-align:middle;\">If 'Zara Ali' like 'Z% A_i' returns a Boolean true, whereas, 'Nuha Ali' like 'Z% A_i' returns a Boolean false.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">BETWEEN</td>\n<td style=\"vertical-align:middle;\">The BETWEEN operator tests whether a value lies in a specified range. x BETWEEN a AND b means that x &gt;= a and x &lt;= b.</td>\n<td style=\"vertical-align:middle;\">If x = 10 then, x between 5 and 20 returns true, x between 5 and 10 returns true, but x between 11 and 20 returns false.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">IN</td>\n<td style=\"vertical-align:middle;\">The IN operator tests set membership. x IN (set) means that x is equal to any member of set.</td>\n<td style=\"vertical-align:middle;\">If x = 'm' then, x in ('a', 'b', 'c') returns Boolean false but x in ('m', 'n', 'o') returns Boolean true.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">IS NULL</td>\n<td style=\"vertical-align:middle;\">The IS NULL operator returns the BOOLEAN value TRUE if its operand is NULL or FALSE if it is not NULL. Comparisons involving NULL values always yield NULL.</td>\n<td style=\"vertical-align:middle;\">If x = 'm', then 'x is null' returns Boolean false.</td>\n</tr>\n</table>\n<h2>Logical Operators</h2>\n<p>Following table shows the Logical operators supported by PL/SQL. All these operators work on Boolean operands and produce Boolean results. Let us assume <b>variable A</b> holds true and <b>variable B</b> holds false, then \u2212</p>\n<p><a href=\"/plsql/plsql_logical_operators.htm\" title=\"Logical Operators in PL/SQL\">Show Examples</a></p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Operator</th>\n<th style=\"text-align:center;\">Description</th>\n<th style=\"text-align:center;\">Examples</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">and</td>\n<td style=\"vertical-align:middle;\">Called the logical AND operator. If both the operands are true then condition becomes true.</td>\n<td>(A and B) is false.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">or</td>\n<td style=\"vertical-align:middle;\">Called the logical OR Operator. If any of the two operands is true then condition becomes true.</td>\n<td>(A or B) is true.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">not</td>\n<td style=\"vertical-align:middle;\">Called the logical NOT Operator. Used to reverse the logical state of its operand. If a condition is true then Logical NOT operator will make it false.</td>\n<td>not (A and B) is true.</td>\n</tr>\n</table>\n<h2>PL/SQL Operator Precedence</h2>\n<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>\n<p>For example, <b>x = 7 + 3 * 2</b>; here, <b>x</b> is assigned <b>13</b>, not 20 because operator * has higher precedence than +, so it first gets multiplied with <b>3*2</b> and then adds into <b>7</b>.</p>\n<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>\n<p>The precedence of operators goes as follows: =, &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;, !=, ~=, ^=, IS NULL, LIKE, BETWEEN, IN.</p>\n<p><a href=\"/plsql/plsql_operators_precedence.htm\" title=\"Operators Precedence in PL/SQL\">Show Examples</a></p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Operator</th>\n<th style=\"text-align:center;\">Operation</th>\n</tr>\n<tr>\n<td style=\"text-align:center;\">**</td>\n<td>exponentiation</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">+, -</td>\n<td>identity, negation</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">*, /</td>\n<td>multiplication, division</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">+, -, ||</td>\n<td>addition, subtraction, concatenation</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">comparison</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">NOT</td>\n<td>logical negation</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">AND</td>\n<td>conjunction</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">OR</td>\n<td>inclusion</td>\n</tr>\n</table>\n<h1>PL/SQL - Conditions</h1>\n<p>In this chapter, we will discuss conditions in PL/SQL. Decision-making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>\n<p>Following is the general form of a typical conditional (i.e., decision making) structure found in most of the programming languages \u2212</p>\n<img alt=\"Decision making statements in PL/SQL\" src=\"/plsql/images/decision_making.jpg\"/>\n<p>PL/SQL programming language provides following types of decision-making statements. Click the following links to check their detail.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Statement &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><a href=\"/plsql/plsql_if_then.htm\" title=\"if-then statement in PL/SQL\">IF - THEN statement</a>\n<p>The <b>IF statement</b> associates a condition with a sequence of statements enclosed by the keywords <b>THEN</b> and <b>END IF</b>. If the condition is true, the statements get executed and if the condition is false or NULL then the IF statement does nothing.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><a href=\"/plsql/plsql_if_then_else.htm\" title=\"if-then-else statement in PL/SQL\">IF-THEN-ELSE statement</a>\n<p><b>IF statement</b> adds the keyword <b>ELSE</b> followed by an alternative sequence of statement. If the condition is false or NULL, then only the alternative sequence of statements get executed. It ensures that either of the sequence of statements is executed.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><a href=\"/plsql/plsql_if_then_elsif.htm\" title=\"if-then-elsif statement in PL/SQL\">IF-THEN-ELSIF statement</a>\n<p>It allows you to choose between several alternatives.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><a href=\"/plsql/plsql_case_statement.htm\" title=\"case statement in PL/SQL\">Case statement</a>\n<p>Like the IF statement, the <b>CASE statement</b> selects one sequence of statements to execute.</p>\n<p>However, to select the sequence, the CASE statement uses a selector rather than multiple Boolean expressions. A selector is an expression whose value is used to select one of several alternatives.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><a href=\"/plsql/plsql_searched_case.htm\" title=\"searched case statements in PL/SQL\">Searched CASE statement</a>\n<p>The searched CASE statement <b>has no selector</b>, and it's WHEN clauses contain search conditions that yield Boolean values.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">6</td>\n<td><a href=\"/plsql/plsql_nested_if.htm\" title=\"nested if statements in PL/SQL\">nested IF-THEN-ELSE</a>\n<p>You can use one <b>IF-THEN</b> or <b>IF-THEN-ELSIF</b> statement inside another <b>IF-THEN</b> or <b>IF-THEN-ELSIF</b> statement(s).</p></td>\n</tr>\n</table>\n<h1>PL/SQL - Loops</h1>\n<p>In this chapter, we will discuss Loops in PL/SQL. There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>\n<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>\n<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages \u2212</p>\n<img alt=\"Loop Architecture\" src=\"/plsql/images/loop_architecture.jpg\"/>\n<p>PL/SQL provides the following types of loop to handle the looping requirements. Click the following links to check their detail.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Loop Type &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><a href=\"/plsql/plsql_basic_loop.htm\" title=\"Basic loop in PL/SQL\">PL/SQL Basic LOOP</a>\n<p>In this loop structure, sequence of statements is enclosed between the LOOP and the END LOOP statements. At each iteration, the sequence of statements is executed and then control resumes at the top of the loop.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><a href=\"/plsql/plsql_while_loop.htm\" title=\"While loop in Pl/SQL\">PL/SQL WHILE LOOP</a>\n<p>Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><a href=\"/plsql/plsql_for_loop.htm\" title=\"For loop in PL/SQL\">PL/SQL FOR LOOP</a>\n<p>Execute a sequence of statements multiple times and abbreviates the code that manages the loop variable.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><a href=\"/plsql/plsql_nested_loops.htm\" title=\"Nested loops in PL/SQL\">Nested loops in PL/SQL</a>\n<p>You can use one or more loop inside any another basic loop, while, or for loop.</p></td>\n</tr>\n</table>\n<h2>Labeling a PL/SQL Loop</h2>\n<p>PL/SQL loops can be labeled. The label should be enclosed by double angle brackets (&lt;&lt; and &gt;&gt;) and appear at the beginning of the LOOP statement. The label name can also appear at the end of the LOOP statement. You may use the label in the EXIT statement to exit from the loop.</p>\n<p>The following program illustrates the concept \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   i number(1); \n   j number(1); \nBEGIN \n   &lt;&lt; outer_loop &gt;&gt; \n   FOR i IN 1..3 LOOP \n      &lt;&lt; inner_loop &gt;&gt; \n      FOR j IN 1..3 LOOP \n         dbms_output.put_line('i is: '|| i || ' and j is: ' || j); \n      END loop inner_loop; \n   END loop outer_loop; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\ni is: 1 and j is: 1 \ni is: 1 and j is: 2 \ni is: 1 and j is: 3 \ni is: 2 and j is: 1 \ni is: 2 and j is: 2 \ni is: 2 and j is: 3 \ni is: 3 and j is: 1 \ni is: 3 and j is: 2 \ni is: 3 and j is: 3  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>The Loop Control Statements</h2>\n<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>\n<p>PL/SQL supports the following control statements. Labeling loops also help in taking the control outside a loop. Click the following links to check their details.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Control Statement &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><a href=\"/plsql/plsql_exit_statement.htm\" title=\"Exit statement in PL/SQL\">EXIT statement</a>\n<p>The Exit statement completes the loop and control passes to the statement immediately after the END LOOP.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><a href=\"/plsql/plsql_continue_statement.htm\" title=\"Continue statement in PL/SQL\">CONTINUE statement</a>\n<p>Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><a href=\"/plsql/plsql_goto_statement.htm\" title=\"GOTO statement in PL/SQL\">GOTO statement</a>\n<p>Transfers control to the labeled statement. Though it is not advised to use the GOTO statement in your program.</p></td>\n</tr>\n</table>\n<h1>PL/SQL - Strings</h1>\n<p>The string in PL/SQL is actually a sequence of characters with an optional size specification. The characters could be numeric, letters, blank, special characters or a combination of all. PL/SQL offers three kinds of strings \u2212</p>\n<ul class=\"list\">\n<li><p><b>Fixed-length strings</b> \u2212 In such strings, programmers specify the length while declaring the string. The string is right-padded with spaces to the length so specified.</p></li>\n<li><p><b>Variable-length strings</b> \u2212 In such strings, a maximum length up to 32,767, for the string is specified and no padding takes place.</p></li>\n<li><p><b>Character large objects (CLOBs)</b> \u2212 These are variable-length strings that can be up to 128 terabytes.</p></li>\n</ul>\n<p>PL/SQL strings could be either variables or literals. A string literal is enclosed within quotation marks. For example,</p>\n<pre class=\"result notranslate\">\n'This is a string literal.' Or 'hello world'\n</pre>\n<p>To include a single quote inside a string literal, you need to type two single quotes next to one another. For example,</p>\n<pre class=\"result notranslate\">\n'this isn''t what it looks like'\n</pre>\n<h2>Declaring String Variables</h2>\n<p>Oracle database provides numerous string datatypes, such as CHAR, NCHAR, VARCHAR2, NVARCHAR2, CLOB, and NCLOB. The datatypes prefixed with an <b>'N'</b> are <b>'national character set'</b> datatypes, that store Unicode character data.</p>\n<p>If you need to declare a variable-length string, you must provide the maximum length of that string. For example, the VARCHAR2 data type. The following example illustrates declaring and using some string variables \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   name varchar2(20); \n   company varchar2(30); \n   introduction clob; \n   choice char(1); \nBEGIN \n   name := 'John Smith'; \n   company := 'Infotech'; \n   introduction := ' Hello! I''m John Smith from Infotech.'; \n   choice := 'y'; \n   IF choice = 'y' THEN \n      dbms_output.put_line(name); \n      dbms_output.put_line(company); \n      dbms_output.put_line(introduction); \n   END IF; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nJohn Smith \nInfotech\nHello! I'm John Smith from Infotech.  \n\nPL/SQL procedure successfully completed\n</pre>\n<p>To declare a fixed-length string, use the CHAR datatype. Here you do not have to specify a maximum length for a fixed-length variable. If you leave off the length constraint, Oracle Database automatically uses a maximum length required. The following two declarations are identical \u2212</p>\n<pre class=\"result notranslate\">\nred_flag CHAR(1) := 'Y'; \n red_flag CHAR   := 'Y';\n</pre>\n<h2>PL/SQL String Functions and Operators</h2>\n<p>PL/SQL offers the concatenation operator <b>(||)</b> for joining two strings. The following table provides the string functions provided by PL/SQL \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Function &amp; Purpose</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>ASCII(x);</b></p>\n<p>Returns the ASCII value of the character x.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>CHR(x);</b></p>\n<p>Returns the character with the ASCII value of x.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>CONCAT(x, y);</b></p>\n<p>Concatenates the strings x and y and returns the appended string.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>INITCAP(x);</b></p>\n<p>Converts the initial letter of each word in x to uppercase and returns that string.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><p><b>INSTR(x, find_string [, start] [, occurrence]);</b></p>\n<p>Searches for <b>find_string</b> in x and returns the position at which it occurs.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">6</td>\n<td><p><b>INSTRB(x);</b></p>\n<p>Returns the location of a string within another string, but returns the value in bytes.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">7</td>\n<td><p><b>LENGTH(x);</b></p>\n<p>Returns the number of characters in x.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">8</td>\n<td><p><b>LENGTHB(x);</b></p>\n<p>Returns the length of a character string in bytes for single byte character set.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">9</td>\n<td><p><b>LOWER(x);</b></p>\n<p>Converts the letters in x to lowercase and returns that string.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">10</td>\n<td><p><b>LPAD(x, width [, pad_string]) ;</b></p>\n<p>Pads <b>x</b> with spaces to the left, to bring the total length of the string up to width characters.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">11 </td>\n<td><p><b>LTRIM(x [, trim_string]);</b></p>\n<p>Trims characters from the left of <b>x</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">12</td>\n<td><p><b>NANVL(x, value);</b></p>\n<p>Returns value if x matches the NaN special value (not a number), otherwise <b>x</b> is returned.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">13</td>\n<td><p><b>NLS_INITCAP(x);</b></p>\n<p>Same as the INITCAP function except that it can use a different sort method as specified by NLSSORT.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">14</td>\n<td><p><b>NLS_LOWER(x) ;</b></p>\n<p>Same as the LOWER function except that it can use a different sort method as specified by NLSSORT.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">15</td>\n<td><p><b>NLS_UPPER(x);</b></p>\n<p>Same as the UPPER function except that it can use a different sort method as specified by NLSSORT.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">16</td>\n<td><p><b>NLSSORT(x);</b></p>\n<p>Changes the method of sorting the characters. Must be specified before any NLS function; otherwise, the default sort will be used.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">17</td>\n<td><p><b>NVL(x, value);</b></p>\n<p>Returns value if <b>x</b> is null; otherwise, x is returned.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">18</td>\n<td><p><b>NVL2(x, value1, value2);</b></p>\n<p>Returns value1 if x is not null; if x is null, value2 is returned.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">19</td>\n<td><p><b>REPLACE(x, search_string, replace_string);</b></p>\n<p>Searches <b>x</b> for search_string and replaces it with replace_string.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">20</td>\n<td><p><b>RPAD(x, width [, pad_string]);</b></p>\n<p>Pads <b>x</b> to the right.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">21</td>\n<td><p><b>RTRIM(x [, trim_string]);</b></p>\n<p>Trims <b>x</b> from the right.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">22</td>\n<td><p><b>SOUNDEX(x) ;</b></p>\n<p>Returns a string containing the phonetic representation of <b>x</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">23</td>\n<td><p><b>SUBSTR(x, start [, length]);</b></p>\n<p>Returns a substring of <b>x</b> that begins at the position specified by start. An optional length for the substring may be supplied.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">24</td>\n<td><p><b>SUBSTRB(x);</b></p>\n<p>Same as SUBSTR except that the parameters are expressed in bytes instead of characters for the single-byte character systems.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">25</td>\n<td><p><b>TRIM([trim_char FROM) x);</b></p>\n<p>Trims characters from the left and right of <b>x</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">26</td>\n<td><p><b>UPPER(x);</b></p>\n<p>Converts the letters in x to uppercase and returns that string.</p>\n</td>\n</tr>\n</table>\n<p>Let us now work out on a few examples to understand the concept \u2212</p>\n<h3>Example 1</h3>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   greetings varchar2(11) := 'hello world'; \nBEGIN \n   dbms_output.put_line(UPPER(greetings)); \n    \n   dbms_output.put_line(LOWER(greetings)); \n    \n   dbms_output.put_line(INITCAP(greetings)); \n    \n   /* retrieve the first character in the string */ \n   dbms_output.put_line ( SUBSTR (greetings, 1, 1)); \n    \n   /* retrieve the last character in the string */ \n   dbms_output.put_line ( SUBSTR (greetings, -1, 1)); \n    \n   /* retrieve five characters,  \n      starting from the seventh position. */ \n   dbms_output.put_line ( SUBSTR (greetings, 7, 5)); \n    \n   /* retrieve the remainder of the string, \n      starting from the second position. */ \n   dbms_output.put_line ( SUBSTR (greetings, 2)); \n     \n   /* find the location of the first \"e\" */ \n   dbms_output.put_line ( INSTR (greetings, 'e')); \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nHELLO WORLD \nhello world \nHello World \nh \nd \nWorld \nello World \n2  \n\nPL/SQL procedure successfully completed.\n</pre>\n<h3>Example 2</h3>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   greetings varchar2(30) := '......Hello World.....'; \nBEGIN \n   dbms_output.put_line(RTRIM(greetings,'.')); \n   dbms_output.put_line(LTRIM(greetings, '.')); \n   dbms_output.put_line(TRIM( '.' from greetings)); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\n......Hello World  \nHello World..... \nHello World  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h1>PL/SQL - Arrays</h1>\n<p>In this chapter, we will discuss arrays in PL/SQL. The PL/SQL programming language provides a data structure called the <b>VARRAY</b>, which can store a fixed-size sequential collection of elements of the same type. A varray is used to store an ordered collection of data, however it is often better to think of an array as a collection of variables of the same type.</p>\n<p>All varrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>\n<img alt=\"Varrays in PL/SQL\" src=\"/plsql/images/varrays.jpg\"/>\n<p>An array is a part of collection type data and it stands for variable-size arrays. We will study other collection types in a later chapter <b>'PL/SQL Collections'</b>.</p>\n<p>Each element in a <b>varray</b> has an index associated with it. It also has a maximum size that can be changed dynamically.</p>\n<h2>Creating a Varray Type</h2>\n<p>A varray type is created with the <b>CREATE TYPE</b> statement. You must specify the maximum size and the type of elements stored in the varray.</p>\n<p>The basic syntax for creating a VARRAY type at the schema level is \u2212</p>\n<pre class=\"result notranslate\">\nCREATE OR REPLACE TYPE varray_type_name IS VARRAY(n) of &lt;element_type&gt;\n</pre>\n<p>Where,</p>\n<ul class=\"list\">\n<li><i>varray_type_name</i> is a valid attribute name,</li>\n<li><i>n</i> is the number of elements (maximum) in the varray,</li>\n<li><i>element_type</i> is the data type of the elements of the array.</li>\n</ul>\n<p>Maximum size of a varray can be changed using the <b>ALTER TYPE</b> statement.</p>\n<p>For example,</p>\n<pre class=\"prettyprint notranslate\">\nCREATE Or REPLACE TYPE namearray AS VARRAY(3) OF VARCHAR2(10); \n/ \n\nType created.\n</pre>\n<p>The basic syntax for creating a VARRAY type within a PL/SQL block is \u2212<p>\n<pre class=\"result notranslate\">\nTYPE varray_type_name IS VARRAY(n) of &lt;element_type&gt;\n</pre>\n<p>For example \u2212</p>\n<pre class=\"prettyprint notranslate\">\nTYPE namearray IS VARRAY(5) OF VARCHAR2(10); \nType grades IS VARRAY(5) OF INTEGER;\n</pre>\n<p>Let us now work out on a few examples to understand the concept \u2212</p>\n<h3>Example 1</h3>\n<p>The following program illustrates the use of varrays \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   type namesarray IS VARRAY(5) OF VARCHAR2(10); \n   type grades IS VARRAY(5) OF INTEGER; \n   names namesarray; \n   marks grades; \n   total integer; \nBEGIN \n   names := namesarray('Kavita', 'Pritam', 'Ayan', 'Rishav', 'Aziz'); \n   marks:= grades(98, 97, 78, 87, 92); \n   total := names.count; \n   dbms_output.put_line('Total '|| total || ' Students'); \n   FOR i in 1 .. total LOOP \n      dbms_output.put_line('Student: ' || names(i) || ' \n      Marks: ' || marks(i)); \n   END LOOP; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nTotal 5 Students \nStudent: Kavita  Marks: 98 \nStudent: Pritam  Marks: 97 \nStudent: Ayan  Marks: 78 \nStudent: Rishav  Marks: 87 \nStudent: Aziz  Marks: 92 \n\nPL/SQL procedure successfully completed. \n</pre>\n<p><b>Please note</b> \u2212</p>\n<ul class=\"list\">\n<li><p>In Oracle environment, the starting index for varrays is always 1.</p></li>\n<li><p>You can initialize the varray elements using the constructor method of the varray type, which has the same name as the varray.</p></li>\n<li><p>Varrays are one-dimensional arrays.</p></li>\n<li><p>A varray is automatically NULL when it is declared and must be initialized before its elements can be referenced.</p></li>\n</ul>\n<h3>Example 2</h3>\n<p>Elements of a varray could also be a %ROWTYPE of any database table or %TYPE of any database table field. The following example illustrates the concept.</p>\n<p>We will use the CUSTOMERS table stored in our database as \u2212</p>\n<pre class=\"result notranslate\">\nSelect * from customers;  \n\n+----+----------+-----+-----------+----------+ \n| ID | NAME     | AGE | ADDRESS   | SALARY   | \n+----+----------+-----+-----------+----------+ \n|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 | \n|  2 | Khilan   |  25 | Delhi     |  1500.00 | \n|  3 | kaushik  |  23 | Kota      |  2000.00 | \n|  4 | Chaitali |  25 | Mumbai    |  6500.00 | \n|  5 | Hardik   |  27 | Bhopal    |  8500.00 | \n|  6 | Komal    |  22 | MP        |  4500.00 | \n+----+----------+-----+-----------+----------+ \n</pre>\n<p>Following example makes the use of <b>cursor</b>, which you will study in detail in a separate chapter.</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   CURSOR c_customers is \n   SELECT  name FROM customers; \n   type c_list is varray (6) of customers.name%type; \n   name_list c_list := c_list(); \n   counter integer :=0; \nBEGIN \n   FOR n IN c_customers LOOP \n      counter := counter + 1; \n      name_list.extend; \n      name_list(counter)  := n.name; \n      dbms_output.put_line('Customer('||counter ||'):'||name_list(counter)); \n   END LOOP; \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCustomer(1): Ramesh  \nCustomer(2): Khilan  \nCustomer(3): kaushik     \nCustomer(4): Chaitali  \nCustomer(5): Hardik  \nCustomer(6): Komal  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h1>PL/SQL - Procedures</h1>\n<p>In this chapter, we will discuss Procedures in PL/SQL. A <b>subprogram</b> is a program unit/module that performs a particular task. These subprograms are combined to form larger programs. This is basically called the 'Modular design'. A subprogram can be invoked by another subprogram or program which is called the <b>calling program</b>.</p>\n<p>A subprogram can be created \u2212</p>\n<ul class=\"list\">\n<li>At the schema level</li>\n<li>Inside a package</li>\n<li>Inside a PL/SQL block</li>\n</ul>\n<p>At the schema level, subprogram is a <b>standalone subprogram</b>. It is created with the CREATE PROCEDURE or the CREATE FUNCTION statement. It is stored in the database and can be deleted with the DROP PROCEDURE or DROP FUNCTION statement.</p>\n<p>A subprogram created inside a package is a <b>packaged subprogram</b>. It is stored in the database and can be deleted only when the package is deleted with the DROP PACKAGE statement. We will discuss packages in the chapter <b>'PL/SQL - Packages'</b>.</p>\n<p>PL/SQL subprograms are named PL/SQL blocks that can be invoked with a set of parameters. PL/SQL provides two kinds of subprograms \u2212</p>\n<ul class=\"list\">\n<li><p><b>Functions</b> \u2212 These subprograms return a single value; mainly used to compute and return a value.</p></li>\n<li><p><b>Procedures</b> \u2212 These subprograms do not return a value directly; mainly used to perform an action.</p></li>\n</ul>\n<p>This chapter is going to cover important aspects of a <b>PL/SQL procedure</b>. We will discuss <b>PL/SQL function</b> in the next chapter.</p>\n<h2>Parts of a PL/SQL Subprogram</h2>\n<p>Each PL/SQL subprogram has a name, and may also have a parameter list. Like anonymous PL/SQL blocks, the named blocks will also have the following three parts \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Parts &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>Declarative Part</b></p>\n<p>It is an optional part. However, the declarative part for a subprogram does not start with the DECLARE keyword. It contains declarations of types, cursors, constants, variables, exceptions, and nested subprograms. These items are local to the subprogram and cease to exist when the subprogram completes execution.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>Executable Part</b></p>\n<p>This is a mandatory part and contains statements that perform the designated action.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>Exception-handling</b></p>\n<p>This is again an optional part. It contains the code that handles run-time errors.</p>\n</td>\n</tr>\n</table>\n<h2>Creating a Procedure</h2>\n<p>A procedure is created with the <b>CREATE OR REPLACE PROCEDURE</b> statement. The simplified syntax for the CREATE OR REPLACE PROCEDURE statement is as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE [OR REPLACE] PROCEDURE procedure_name \n[(parameter_name [IN | OUT | IN OUT] type [, ...])] \n{IS | AS} \nBEGIN \n  &lt; procedure_body &gt; \nEND procedure_name; \n</pre>\n<p>Where,</p>\n<ul class=\"list\">\n<li><p><i>procedure-name</i> specifies the name of the procedure.</p></li>\n<li><p>[OR REPLACE] option allows the modification of an existing procedure.</p></li>\n<li><p>The optional parameter list contains name, mode and types of the parameters. <b>IN</b> represents the value that will be passed from outside and OUT represents the parameter that will be used to return a value outside of the procedure.</p></li>\n<li><p><i>procedure-body</i> contains the executable part.</p></li>\n<li><p>The AS keyword is used instead of the IS keyword for creating a standalone procedure.</p></li>\n</ul>\n<h3>Example</h3>\n<p>The following example creates a simple procedure that displays the string 'Hello World!' on the screen when executed.</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE PROCEDURE greetings \nAS \nBEGIN \n   dbms_output.put_line('Hello World!'); \nEND; \n/\n</pre>\n<p>When the above code is executed using the SQL prompt, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nProcedure created.\n</pre>\n<h2>Executing a Standalone Procedure</h2>\n<p>A standalone procedure can be called in two ways \u2212</p>\n<ul class=\"list\">\n<li><p>Using the <b>EXECUTE</b> keyword</p></li>\n<li><p>Calling the name of the procedure from a PL/SQL block</p></li>\n</ul>\n<p>The above procedure named <b>'greetings'</b> can be called with the EXECUTE keyword as \u2212</p>\n<pre class=\"result notranslate\">\nEXECUTE greetings;\n</pre>\n<p>The above call will display \u2212</p>\n<pre class=\"result notranslate\">\nHello World\n\nPL/SQL procedure successfully completed.\n</pre>\n<p>The procedure can also be called from another PL/SQL block \u2212</p>\n<pre class=\"prettyprint notranslate\">\nBEGIN \n   greetings; \nEND; \n/\n</pre>\n<p>The above call will display \u2212</p>\n<pre class=\"result notranslate\">\nHello World  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>Deleting a Standalone Procedure</h2>\n<p>A standalone procedure is deleted with the <b>DROP PROCEDURE</b> statement. Syntax for deleting a procedure is \u2212</p>\n<pre class=\"result notranslate\">\nDROP PROCEDURE procedure-name; \n</pre>\n<p>You can drop the greetings procedure by using the following statement \u2212</p>\n<pre class=\"result notranslate\">\nDROP PROCEDURE greetings; \n</pre>\n<h2>Parameter Modes in PL/SQL Subprograms</h2>\n<p>The following table lists out the parameter modes in PL/SQL subprograms \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Parameter Mode &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>IN</b></p>\n<p>An IN parameter lets you pass a value to the subprogram. <b>It is a read-only parameter</b>. Inside the subprogram, an IN parameter acts like a constant. It cannot be assigned a value. You can pass a constant, literal, initialized variable, or expression as an IN parameter. You can also initialize it to a default value; however, in that case, it is omitted from the subprogram call. <b>It is the default mode of parameter passing. Parameters are passed by reference</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>OUT</b></p>\n<p>An OUT parameter returns a value to the calling program. Inside the subprogram, an OUT parameter acts like a variable. You can change its value and reference the value after assigning it. <b>The actual parameter must be variable and it is passed by value</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>IN OUT</b></p>\n<p>An <b>IN OUT</b> parameter passes an initial value to a subprogram and returns an updated value to the caller. It can be assigned a value and the value can be read.</p>\n<p>The actual parameter corresponding to an IN OUT formal parameter must be a variable, not a constant or an expression. Formal parameter must be assigned a value. <b>Actual parameter is passed by value.</b></p>\n</td>\n</tr>\n</table>\n<h3>IN &amp; OUT Mode Example 1</h3>\n<p>This program finds the minimum of two values. Here, the procedure takes two numbers using the IN mode and returns their minimum using the OUT parameters.</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   a number; \n   b number; \n   c number;\nPROCEDURE findMin(x IN number, y IN number, z OUT number) IS \nBEGIN \n   IF x &lt; y THEN \n      z:= x; \n   ELSE \n      z:= y; \n   END IF; \nEND;   \nBEGIN \n   a:= 23; \n   b:= 45; \n   findMin(a, b, c); \n   dbms_output.put_line(' Minimum of (23, 45) : ' || c); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nMinimum of (23, 45) : 23  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h3>IN &amp; OUT Mode Example 2</h3>\n<p>This procedure computes the square of value of a passed value. This example shows how we can use the same parameter to accept a value and then return another result.</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   a number; \nPROCEDURE squareNum(x IN OUT number) IS \nBEGIN \n  x := x * x; \nEND;  \nBEGIN \n   a:= 23; \n   squareNum(a); \n   dbms_output.put_line(' Square of (23): ' || a); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nSquare of (23): 529 \n\nPL/SQL procedure successfully completed.\n</pre>\n<h2>Methods for Passing Parameters</h2>\n<p>Actual parameters can be passed in three ways \u2212</p>\n<ul class=\"list\">\n<li>Positional notation</li>\n<li>Named notation</li>\n<li>Mixed notation</li>\n</ul>\n<h3>Positional Notation</h3>\n<p>In positional notation, you can call the procedure as \u2212</p>\n<pre class=\"result notranslate\">\nfindMin(a, b, c, d);\n</pre>\n<p>In positional notation, the first actual parameter is substituted for the first formal parameter; the second actual parameter is substituted for the second formal parameter, and so on. So, <b>a</b> is substituted for <b>x, b</b> is substituted for <b>y, c</b> is substituted for <b>z</b> and <b>d</b> is substituted for <b>m</b>.</p>\n<h3>Named Notation</h3>\n<p>In named notation, the actual parameter is associated with the formal parameter using the <b>arrow symbol ( =&gt; )</b>. The procedure call will be like the following \u2212</p>\n<pre class=\"result notranslate\">\nfindMin(x =&gt; a, y =&gt; b, z =&gt; c, m =&gt; d);\n</pre>\n<h3>Mixed Notation</h3>\n<p>In mixed notation, you can mix both notations in procedure call; however, the positional notation should precede the named notation.</p>\n<p>The following call is legal \u2212</p>\n<pre class=\"result notranslate\">\nfindMin(a, b, c, m =&gt; d);\n</pre>\n<p>However, this is not legal:</p>\n<pre class=\"result notranslate\">\nfindMin(x =&gt; a, b, c, d); \n</pre>\n<h1>PL/SQL - Functions</h1>\n<p>In this chapter, we will discuss the functions in PL/SQL. A function is same as a procedure except that it returns a value. Therefore, all the discussions of the previous chapter are true for functions too.</p>\n<h2>Creating a Function</h2>\n<p>A standalone function is created using the <b>CREATE FUNCTION</b> statement. The simplified syntax for the <b>CREATE OR REPLACE PROCEDURE</b> statement is as follows \u2212</p>\n<pre class=\"result notranslate\">\nCREATE [OR REPLACE] FUNCTION function_name \n[(parameter_name [IN | OUT | IN OUT] type [, ...])] \nRETURN return_datatype \n{IS | AS} \nBEGIN \n   &lt; function_body &gt; \nEND [function_name];\n</pre>\n<p>Where,</p>\n<ul class=\"list\">\n<li><p><i>function-name</i> specifies the name of the function.</p></li>\n<li><p>[OR REPLACE] option allows the modification of an existing function.</p></li>\n<li><p>The optional parameter list contains name, mode and types of the parameters. IN represents the value that will be passed from outside and OUT represents the parameter that will be used to return a value outside of the procedure.</p></li>\n<li><p>The function must contain a <b>return</b> statement.</p></li>\n<li><p>The <i>RETURN</i> clause specifies the data type you are going to return from the function.</p></li>\n<li><p><i>function-body</i> contains the executable part.</p></li>\n<li><p>The AS keyword is used instead of the IS keyword for creating a standalone function.</p></li>\n</ul>\n<h3>Example</h3>\n<p>The following example illustrates how to create and call a standalone function. This function returns the total number of CUSTOMERS in the customers table.</p>\n<p>We will use the CUSTOMERS table, which we had created in the <a href=\"/plsql/plsql_variable_types.htm\">PL/SQL Variables</a> chapter \u2212</p>\n<pre class=\"result notranslate\">\nSelect * from customers; \n \n+----+----------+-----+-----------+----------+ \n| ID | NAME     | AGE | ADDRESS   | SALARY   | \n+----+----------+-----+-----------+----------+ \n|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 | \n|  2 | Khilan   |  25 | Delhi     |  1500.00 | \n|  3 | kaushik  |  23 | Kota      |  2000.00 | \n|  4 | Chaitali |  25 | Mumbai    |  6500.00 | \n|  5 | Hardik   |  27 | Bhopal    |  8500.00 | \n|  6 | Komal    |  22 | MP        |  4500.00 | \n+----+----------+-----+-----------+----------+  \n</pre>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE FUNCTION totalCustomers \nRETURN number IS \n   total number(2) := 0; \nBEGIN \n   SELECT count(*) into total \n   FROM customers; \n    \n   RETURN total; \nEND; \n/ \n</pre>\n<p>When the above code is executed using the SQL prompt, it will produce the following result \u2212</p>\n<pre class=\"result notranslate\">\nFunction created.\n</pre>\n<h2>Calling a Function</h2>\n<p>While creating a function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task. When a program calls a function, the program control is transferred to the called function.</p>\n<p>A called function performs the defined task and when its return statement is executed or when the <b>last end statement</b> is reached, it returns the program control back to the main program.</p>\n<p>To call a function, you simply need to pass the required parameters along with the function name and if the function returns a value, then you can store the returned value. Following program calls the function <b>totalCustomers</b> from an anonymous block \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   c number(2); \nBEGIN \n   c := totalCustomers(); \n   dbms_output.put_line('Total no. of Customers: ' || c); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nTotal no. of Customers: 6  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h3>Example</h3>\n<p>The following example demonstrates Declaring, Defining, and Invoking a Simple PL/SQL Function that computes and returns the maximum of two values.</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   a number; \n   b number; \n   c number; \nFUNCTION findMax(x IN number, y IN number)  \nRETURN number \nIS \n    z number; \nBEGIN \n   IF x &gt; y THEN \n      z:= x; \n   ELSE \n      Z:= y; \n   END IF;  \n   RETURN z; \nEND; \nBEGIN \n   a:= 23; \n   b:= 45;  \n   c := findMax(a, b); \n   dbms_output.put_line(' Maximum of (23,45): ' || c); \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nMaximum of (23,45): 45   \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>PL/SQL Recursive Functions</h2>\n<p>We have seen that a program or subprogram may call another subprogram. When a subprogram calls itself, it is referred to as a recursive call and the process is known as <b>recursion</b>.</p>\n<p>To illustrate the concept, let us calculate the factorial of a number. Factorial of a number n is defined as \u2212</p>\n<pre class=\"result notranslate\">\nn! = n*(n-1)! \n   = n*(n-1)*(n-2)! \n      ... \n   = n*(n-1)*(n-2)*(n-3)... 1 \n</pre>\n<p>The following program calculates the factorial of a given number by calling itself recursively \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   num number; \n   factorial number;  \n   \nFUNCTION fact(x number) \nRETURN number  \nIS \n   f number; \nBEGIN \n   IF x=0 THEN \n      f := 1; \n   ELSE \n      f := x * fact(x-1); \n   END IF; \nRETURN f; \nEND;  \n\nBEGIN \n   num:= 6; \n   factorial := fact(num); \n   dbms_output.put_line(' Factorial '|| num || ' is ' || factorial); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nFactorial 6 is 720 \n  \nPL/SQL procedure successfully completed.\n</pre>\n<h1>PL/SQL - Cursors</h1>\n<p>In this chapter, we will discuss the cursors in PL/SQL. Oracle creates a memory area, known as the context area, for processing an SQL statement, which contains all the information needed for processing the statement; for example, the number of rows processed, etc.</p>\n<p>A <b>cursor</b> is a pointer to this context area. PL/SQL controls the context area through a cursor. A cursor holds the rows (one or more) returned by a SQL statement. The set of rows the cursor holds is referred to as the <b>active set</b>.</p>\n<p>You can name a cursor so that it could be referred to in a program to fetch and process the rows returned by the SQL statement, one at a time. There are two types of cursors \u2212</p>\n<ul class=\"list\">\n<li>Implicit cursors</li>\n<li>Explicit cursors</li>\n</ul>\n<h2>Implicit Cursors</h2>\n<p>Implicit cursors are automatically created by Oracle whenever an SQL statement is executed, when there is no explicit cursor for the statement. Programmers cannot control the implicit cursors and the information in it.</p>\n<p>Whenever a DML statement (INSERT, UPDATE and DELETE) is issued, an implicit cursor is associated with this statement. For INSERT operations, the cursor holds the data that needs to be inserted. For UPDATE and DELETE operations, the cursor identifies the rows that would be affected.</p>\n<p>In PL/SQL, you can refer to the most recent implicit cursor as the <b>SQL cursor</b>, which always has attributes such as <b>%FOUND, %ISOPEN, %NOTFOUND</b>, and <b>%ROWCOUNT</b>. The SQL cursor has additional attributes, <b>%BULK_ROWCOUNT</b> and <b>%BULK_EXCEPTIONS</b>, designed for use with the <b>FORALL</b> statement. The following table provides the description of the most used attributes \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Attribute &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>%FOUND</b></p>\n<p>Returns TRUE if an INSERT, UPDATE, or DELETE statement affected one or more rows or a SELECT INTO statement returned one or more rows. Otherwise, it returns FALSE.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>%NOTFOUND</b></p>\n<p>The logical opposite of %FOUND. It returns TRUE if an INSERT, UPDATE, or DELETE statement affected no rows, or a SELECT INTO statement returned no rows. Otherwise, it returns FALSE.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>%ISOPEN</b></p>\n<p>Always returns FALSE for implicit cursors, because Oracle closes the SQL cursor automatically after executing its associated SQL statement.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>%ROWCOUNT</b></p>\n<p>Returns the number of rows affected by an INSERT, UPDATE, or DELETE statement, or returned by a SELECT INTO statement.</p></td>\n</tr>\n</table>\n<p>Any SQL cursor attribute will be accessed as <b>sql%attribute_name</b> as shown below in the example.</p>\n<h3>Example</h3>\n<p>We will be using the CUSTOMERS table we had created and used in the previous chapters.</p>\n<pre class=\"result notranslate\">\nSelect * from customers;  \n\n+----+----------+-----+-----------+----------+ \n| ID | NAME     | AGE | ADDRESS   | SALARY   | \n+----+----------+-----+-----------+----------+ \n|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 | \n|  2 | Khilan   |  25 | Delhi     |  1500.00 | \n|  3 | kaushik  |  23 | Kota      |  2000.00 | \n|  4 | Chaitali |  25 | Mumbai    |  6500.00 | \n|  5 | Hardik   |  27 | Bhopal    |  8500.00 | \n|  6 | Komal    |  22 | MP        |  4500.00 | \n+----+----------+-----+-----------+----------+\n</pre>\n<p>The following program will update the table and increase the salary of each customer by 500 and use the <b>SQL%ROWCOUNT</b> attribute to determine the number of rows affected \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE  \n   total_rows number(2); \nBEGIN \n   UPDATE customers \n   SET salary = salary + 500; \n   IF sql%notfound THEN \n      dbms_output.put_line('no customers selected'); \n   ELSIF sql%found THEN \n      total_rows := sql%rowcount;\n      dbms_output.put_line( total_rows || ' customers selected '); \n   END IF;  \nEND; \n/      \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\n6 customers selected  \n\nPL/SQL procedure successfully completed. \n</pre>\n<p>If you check the records in customers table, you will find that the rows have been updated \u2212</p>\n<pre class=\"result notranslate\">\nSelect * from customers;  \n\n+----+----------+-----+-----------+----------+ \n| ID | NAME     | AGE | ADDRESS   | SALARY   | \n+----+----------+-----+-----------+----------+ \n|  1 | Ramesh   |  32 | Ahmedabad |  2500.00 | \n|  2 | Khilan   |  25 | Delhi     |  2000.00 | \n|  3 | kaushik  |  23 | Kota      |  2500.00 | \n|  4 | Chaitali |  25 | Mumbai    |  7000.00 | \n|  5 | Hardik   |  27 | Bhopal    |  9000.00 | \n|  6 | Komal    |  22 | MP        |  5000.00 | \n+----+----------+-----+-----------+----------+\n</pre>\n<h2>Explicit Cursors</h2>\n<p>Explicit cursors are programmer-defined cursors for gaining more control over the <b>context area</b>. An explicit cursor should be defined in the declaration section of the PL/SQL Block. It is created on a SELECT Statement which returns more than one row.</p>\n<p>The syntax for creating an explicit cursor is \u2212</p>\n<pre class=\"result notranslate\">\nCURSOR cursor_name IS select_statement; \n</pre>\n<p>Working with an explicit cursor includes the following steps \u2212</p>\n<ul class=\"list\">\n<li>Declaring the cursor for initializing the memory</li>\n<li>Opening the cursor for allocating the memory</li>\n<li>Fetching the cursor for retrieving the data</li>\n<li>Closing the cursor to release the allocated memory</li>\n</ul>\n<h2>Declaring the Cursor</h2>\n<p>Declaring the cursor defines the cursor with a name and the associated SELECT statement. For example \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCURSOR c_customers IS \n   SELECT id, name, address FROM customers; \n</pre>\n<h2>Opening the Cursor</h2>\n<p>Opening the cursor allocates the memory for the cursor and makes it ready for fetching the rows returned by the SQL statement into it. For example, we will open the above defined cursor as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\nOPEN c_customers; \n</pre>\n<h2>Fetching the Cursor</h2>\n<p>Fetching the cursor involves accessing one row at a time. For example, we will fetch rows from the above-opened cursor as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\nFETCH c_customers INTO c_id, c_name, c_addr; \n</pre>\n<h2>Closing the Cursor</h2>\n<p>Closing the cursor means releasing the allocated memory. For example, we will close the above-opened cursor as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCLOSE c_customers;\n</pre>\n<h3>Example</h3>\n<p>Following is a complete example to illustrate the concepts of explicit cursors &amp;minua</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   c_id customers.id%type; \n   c_name customerS.No.ame%type; \n   c_addr customers.address%type; \n   CURSOR c_customers is \n      SELECT id, name, address FROM customers; \nBEGIN \n   OPEN c_customers; \n   LOOP \n   FETCH c_customers into c_id, c_name, c_addr; \n      EXIT WHEN c_customers%notfound; \n      dbms_output.put_line(c_id || ' ' || c_name || ' ' || c_addr); \n   END LOOP; \n   CLOSE c_customers; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\n1 Ramesh Ahmedabad  \n2 Khilan Delhi  \n3 kaushik Kota     \n4 Chaitali Mumbai  \n5 Hardik Bhopal   \n6 Komal MP  \n  \nPL/SQL procedure successfully completed. \n</pre>\n<h1>PL/SQL - Records</h1>\n<p>In this chapter, we will discuss Records in PL/SQL. A <b>record</b> is a data structure that can hold data items of different kinds. Records consist of different fields, similar to a row of a database table.</p>\n<p>For example, you want to keep track of your books in a library. You might want to track the following attributes about each book, such as Title, Author, Subject, Book ID. A record containing a field for each of these items allows treating a BOOK as a logical unit and allows you to organize and represent its information in a better way.</p>\n<p>PL/SQL can handle the following types of records \u2212</p>\n<ul class=\"list\">\n<li>Table-based</li>\n<li>Cursor-based records</li>\n<li>User-defined records</li>\n</ul>\n<h2>Table-Based Records</h2>\n<p>The %ROWTYPE attribute enables a programmer to create <b>table-based</b> and <b>cursorbased</b> records.</p>\n<p>The following example illustrates the concept of <b>table-based</b> records. We will be using the CUSTOMERS table we had created and used in the previous chapters \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   customer_rec customers%rowtype; \nBEGIN \n   SELECT * into customer_rec \n   FROM customers \n   WHERE id = 5;  \n   dbms_output.put_line('Customer ID: ' || customer_rec.id); \n   dbms_output.put_line('Customer Name: ' || customer_rec.name); \n   dbms_output.put_line('Customer Address: ' || customer_rec.address); \n   dbms_output.put_line('Customer Salary: ' || customer_rec.salary); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nCustomer ID: 5 \nCustomer Name: Hardik \nCustomer Address: Bhopal \nCustomer Salary: 9000 \n \nPL/SQL procedure successfully completed.\n</pre>\n<h2>Cursor-Based Records</h2>\n<p>The following example illustrates the concept of <b>cursor-based</b> records. We will be using the CUSTOMERS table we had created and used in the previous chapters \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   CURSOR customer_cur is \n      SELECT id, name, address  \n      FROM customers; \n   customer_rec customer_cur%rowtype; \nBEGIN \n   OPEN customer_cur; \n   LOOP \n      FETCH customer_cur into customer_rec; \n      EXIT WHEN customer_cur%notfound; \n      DBMS_OUTPUT.put_line(customer_rec.id || ' ' || customer_rec.name); \n   END LOOP; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\n1 Ramesh \n2 Khilan \n3 kaushik \n4 Chaitali \n5 Hardik \n6 Komal  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>User-Defined Records</h2>\n<p>PL/SQL provides a user-defined record type that allows you to define the different record structures. These records consist of different fields. Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book \u2212</p>\n<ul class=\"list\">\n<li>Title</li>\n<li>Author</li>\n<li>Subject</li>\n<li>Book ID</li>\n</ul>\n<h3>Defining a Record</h3>\n<p>The record type is defined as \u2212</p>\n<pre class=\"result notranslate\">\nTYPE \ntype_name IS RECORD \n  ( field_name1  datatype1  [NOT NULL]  [:= DEFAULT EXPRESSION], \n   field_name2   datatype2   [NOT NULL]  [:= DEFAULT EXPRESSION], \n   ... \n   field_nameN  datatypeN  [NOT NULL]  [:= DEFAULT EXPRESSION); \nrecord-name  type_name;\n</pre>\n<p>The Book record is declared in the following way \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \nTYPE books IS RECORD \n(title  varchar(50), \n   author  varchar(50), \n   subject varchar(100), \n   book_id   number); \nbook1 books; \nbook2 books; \n</pre>\n<h3>Accessing Fields</h3>\n<p>To access any field of a record, we use the dot <b>(.)</b> operator. The member access operator is coded as a period between the record variable name and the field that we wish to access. Following is an example to explain the usage of record \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   type books is record \n      (title varchar(50), \n      author varchar(50), \n      subject varchar(100), \n      book_id number); \n   book1 books; \n   book2 books; \nBEGIN \n   -- Book 1 specification \n   book1.title  := 'C Programming'; \n   book1.author := 'Nuha Ali ';  \n   book1.subject := 'C Programming Tutorial'; \n   book1.book_id := 6495407;  \n   -- Book 2 specification \n   book2.title := 'Telecom Billing'; \n   book2.author := 'Zara Ali'; \n   book2.subject := 'Telecom Billing Tutorial'; \n   book2.book_id := 6495700;  \n  \n  -- Print book 1 record \n   dbms_output.put_line('Book 1 title : '|| book1.title); \n   dbms_output.put_line('Book 1 author : '|| book1.author); \n   dbms_output.put_line('Book 1 subject : '|| book1.subject); \n   dbms_output.put_line('Book 1 book_id : ' || book1.book_id); \n   \n   -- Print book 2 record \n   dbms_output.put_line('Book 2 title : '|| book2.title); \n   dbms_output.put_line('Book 2 author : '|| book2.author); \n   dbms_output.put_line('Book 2 subject : '|| book2.subject); \n   dbms_output.put_line('Book 2 book_id : '|| book2.book_id); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nBook 1 title : C Programming \nBook 1 author : Nuha Ali \nBook 1 subject : C Programming Tutorial \nBook 1 book_id : 6495407 \nBook 2 title : Telecom Billing \nBook 2 author : Zara Ali \nBook 2 subject : Telecom Billing Tutorial \nBook 2 book_id : 6495700  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h3>Records as Subprogram Parameters</h3>\n<p>You can pass a record as a subprogram parameter just as you pass any other variable. You can also access the record fields in the same way as you accessed in the above example \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   type books is record \n      (title  varchar(50), \n      author  varchar(50), \n      subject varchar(100), \n      book_id   number); \n   book1 books; \n   book2 books;  \nPROCEDURE printbook (book books) IS \nBEGIN \n   dbms_output.put_line ('Book  title :  ' || book.title); \n   dbms_output.put_line('Book  author : ' || book.author); \n   dbms_output.put_line( 'Book  subject : ' || book.subject); \n   dbms_output.put_line( 'Book book_id : ' || book.book_id); \nEND; \n   \nBEGIN \n   -- Book 1 specification \n   book1.title  := 'C Programming'; \n   book1.author := 'Nuha Ali ';  \n   book1.subject := 'C Programming Tutorial'; \n   book1.book_id := 6495407;\n   \n   -- Book 2 specification \n   book2.title := 'Telecom Billing'; \n   book2.author := 'Zara Ali'; \n   book2.subject := 'Telecom Billing Tutorial'; \n   book2.book_id := 6495700;  \n   \n   -- Use procedure to print book info \n   printbook(book1); \n   printbook(book2); \nEND; \n/  \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nBook  title : C Programming \nBook  author : Nuha Ali \nBook subject : C Programming Tutorial \nBook  book_id : 6495407 \nBook title : Telecom Billing \nBook author : Zara Ali \nBook subject : Telecom Billing Tutorial \nBook book_id : 6495700  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h1>PL/SQL - Exceptions</h1>\n<p>In this chapter, we will discuss Exceptions in PL/SQL. An exception is an error condition during a program execution. PL/SQL supports programmers to catch such conditions using <b>EXCEPTION</b> block in the program and an appropriate action is taken against the error condition. There are two types of exceptions \u2212</p>\n<ul class=\"list\">\n<li>System-defined exceptions</li>\n<li>User-defined exceptions</li>\n</ul>\n<h2>Syntax for Exception Handling</h2>\n<p>The general syntax for exception handling is as follows. Here you can list down as many exceptions as you can handle. The default exception will be handled using <b><i>WHEN others THEN</i></b> \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   &lt;declarations section&gt; \nBEGIN \n   &lt;executable command(s)&gt; \nEXCEPTION \n   &lt;exception handling goes here &gt; \n   WHEN exception1 THEN  \n      exception1-handling-statements  \n   WHEN exception2  THEN  \n      exception2-handling-statements  \n   WHEN exception3 THEN  \n      exception3-handling-statements \n   ........ \n   WHEN others THEN \n      exception3-handling-statements \nEND;\n</pre>\n<h3>Example</h3>\n<p>Let us write a code to illustrate the concept. We will be using the CUSTOMERS table we had created and used in the previous chapters \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   c_id customers.id%type := 8; \n   c_name customerS.Name%type; \n   c_addr customers.address%type; \nBEGIN \n   SELECT  name, address INTO  c_name, c_addr \n   FROM customers \n   WHERE id = c_id;  \n   DBMS_OUTPUT.PUT_LINE ('Name: '||  c_name); \n   DBMS_OUTPUT.PUT_LINE ('Address: ' || c_addr); \n\nEXCEPTION \n   WHEN no_data_found THEN \n      dbms_output.put_line('No such customer!'); \n   WHEN others THEN \n      dbms_output.put_line('Error!'); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nNo such customer!  \n\nPL/SQL procedure successfully completed. \n</pre>\n<p>The above program displays the name and address of a customer whose ID is given. Since there is no customer with ID value 8 in our database, the program raises the run-time exception <b>NO_DATA_FOUND</b>, which is captured in the <b>EXCEPTION block</b>.</p>\n<h2>Raising Exceptions</h2>\n<p>Exceptions are raised by the database server automatically whenever there is any internal database error, but exceptions can be raised explicitly by the programmer by using the command <b>RAISE</b>. Following is the simple syntax for raising an exception \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   exception_name EXCEPTION; \nBEGIN \n   IF condition THEN \n      RAISE exception_name; \n   END IF; \nEXCEPTION \n   WHEN exception_name THEN \n   statement; \nEND; \n</pre>\n<p>You can use the above syntax in raising the Oracle standard exception or any user-defined exception. In the next section, we will give you an example on raising a user-defined exception. You can raise the Oracle standard exceptions in a similar way.</p>\n<h2>User-defined Exceptions</h2>\n<p>PL/SQL allows you to define your own exceptions according to the need of your program. A user-defined exception must be declared and then raised explicitly, using either a RAISE statement or the procedure <b>DBMS_STANDARD.RAISE_APPLICATION_ERROR</b>.</p>\n<p>The syntax for declaring an exception is \u2212</p>\n<pre class=\"result notranslate\">\nDECLARE \n   my-exception EXCEPTION; \n</pre>\n<h3>Example</h3>\n<p>The following example illustrates the concept. This program asks for a customer ID, when the user enters an invalid ID, the exception <b>invalid_id</b> is raised.</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   c_id customers.id%type := &amp;cc_id; \n   c_name customerS.Name%type; \n   c_addr customers.address%type;  \n   -- user defined exception \n   ex_invalid_id  EXCEPTION; \nBEGIN \n   IF c_id &lt;= 0 THEN \n      RAISE ex_invalid_id; \n   ELSE \n      SELECT  name, address INTO  c_name, c_addr \n      FROM customers \n      WHERE id = c_id;\n      DBMS_OUTPUT.PUT_LINE ('Name: '||  c_name);  \n      DBMS_OUTPUT.PUT_LINE ('Address: ' || c_addr); \n   END IF; \n\nEXCEPTION \n   WHEN ex_invalid_id THEN \n      dbms_output.put_line('ID must be greater than zero!'); \n   WHEN no_data_found THEN \n      dbms_output.put_line('No such customer!'); \n   WHEN others THEN \n      dbms_output.put_line('Error!');  \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nEnter value for cc_id: -6 (let's enter a value -6) \nold  2: c_id customers.id%type := &amp;cc_id; \nnew  2: c_id customers.id%type := -6; \nID must be greater than zero! \n \nPL/SQL procedure successfully completed. \n</pre>\n<h2>Pre-defined Exceptions</h2>\n<p>PL/SQL provides many pre-defined exceptions, which are executed when any database rule is violated by a program. For example, the predefined exception NO_DATA_FOUND is raised when a SELECT INTO statement returns no rows. The following table lists few of the important pre-defined exceptions \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center; vertical-align:middle;\">Exception</th>\n<th style=\"text-align:center; vertical-align:middle;\">Oracle Error</th>\n<th style=\"text-align:center; vertical-align:middle;\">SQLCODE</th>\n<th style=\"text-align:center; vertical-align:middle;\">Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">ACCESS_INTO_NULL</td>\n<td style=\"text-align:center; vertical-align:middle;\">06530</td>\n<td style=\"text-align:center; vertical-align:middle;\">-6530</td>\n<td>It is raised when a null object is automatically assigned a value.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">CASE_NOT_FOUND</td>\n<td style=\"text-align:center; vertical-align:middle;\">06592</td>\n<td style=\"text-align:center; vertical-align:middle;\">-6592</td>\n<td>It is raised when none of the choices in the WHEN clause of a CASE statement is selected, and there is no ELSE clause.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">COLLECTION_IS_NULL</td>\n<td style=\"text-align:center; vertical-align:middle;\">06531</td>\n<td style=\"text-align:center; vertical-align:middle;\">-6531</td>\n<td>It is raised when a program attempts to apply collection methods other than EXISTS to an uninitialized nested table or varray, or the program attempts to assign values to the elements of an uninitialized nested table or varray.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">DUP_VAL_ON_INDEX</td>\n<td style=\"text-align:center; vertical-align:middle;\">00001</td>\n<td style=\"text-align:center; vertical-align:middle;\">-1</td>\n<td>It is raised when duplicate values are attempted to be stored in a column with unique index.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">INVALID_CURSOR</td>\n<td style=\"text-align:center; vertical-align:middle;\">01001</td>\n<td style=\"text-align:center; vertical-align:middle;\">-1001</td>\n<td>It is raised when attempts are made to make a cursor operation that is not allowed, such as closing an unopened cursor.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">INVALID_NUMBER</td>\n<td style=\"text-align:center; vertical-align:middle;\">01722</td>\n<td style=\"text-align:center; vertical-align:middle;\">-1722</td>\n<td>It is raised when the conversion of a character string into a number fails because the string does not represent a valid number.</td></tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">LOGIN_DENIED</td>\n<td style=\"text-align:center; vertical-align:middle;\">01017</td>\n<td style=\"text-align:center; vertical-align:middle;\">-1017</td>\n<td>It is raised when a program attempts to log on to the database with an invalid username or password.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">NO_DATA_FOUND</td>\n<td style=\"text-align:center; vertical-align:middle;\">01403</td>\n<td style=\"text-align:center; vertical-align:middle;\">+100</td>\n<td>It is raised when a SELECT INTO statement returns no rows.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">NOT_LOGGED_ON</td>\n<td style=\"text-align:center; vertical-align:middle;\">01012</td>\n<td style=\"text-align:center; vertical-align:middle;\">-1012</td>\n<td>It is raised when a database call is issued without being connected to the database.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">PROGRAM_ERROR</td>\n<td style=\"text-align:center; vertical-align:middle;\">06501</td>\n<td style=\"text-align:center; vertical-align:middle;\">-6501</td>\n<td>It is raised when PL/SQL has an internal problem.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">ROWTYPE_MISMATCH</td>\n<td style=\"text-align:center; vertical-align:middle;\">06504</td>\n<td style=\"text-align:center; vertical-align:middle;\">-6504</td>\n<td>It is raised when a cursor fetches value in a variable having incompatible data type.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">SELF_IS_NULL</td>\n<td style=\"text-align:center; vertical-align:middle;\">30625</td>\n<td style=\"text-align:center; vertical-align:middle;\">-30625</td>\n<td>It is raised when a member method is invoked, but the instance of the object type was not initialized. </td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">STORAGE_ERROR</td>\n<td style=\"text-align:center; vertical-align:middle;\">06500</td>\n<td style=\"text-align:center; vertical-align:middle;\">-6500</td>\n<td>It is raised when PL/SQL ran out of memory or memory was corrupted.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TOO_MANY_ROWS</td>\n<td style=\"text-align:center; vertical-align:middle;\">01422</td>\n<td style=\"text-align:center; vertical-align:middle;\">-1422</td>\n<td>It is raised when a SELECT INTO statement returns more than one row.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">VALUE_ERROR</td>\n<td style=\"text-align:center; vertical-align:middle;\">06502</td>\n<td style=\"text-align:center; vertical-align:middle;\">-6502</td>\n<td>It is raised when an arithmetic, conversion, truncation, or sizeconstraint error occurs.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">ZERO_DIVIDE</td>\n<td style=\"text-align:center; vertical-align:middle;\">01476</td>\n<td style=\"text-align:center; vertical-align:middle;\">1476</td>\n<td>It is raised when an attempt is made to divide a number by zero.</td>\n</tr>\n</table>\n<h1>PL/SQL - Triggers</h1>\n<p>In this chapter, we will discuss Triggers in PL/SQL. Triggers are stored programs, which are automatically executed or fired when some events occur. Triggers are, in fact, written to be executed in response to any of the following events \u2212</p>\n<ul class=\"list\">\n<li><p>A <b>database manipulation (DML)</b> statement (DELETE, INSERT, or UPDATE)</p></li>\n<li><p>A <b>database definition (DDL)</b> statement (CREATE, ALTER, or DROP).</p></li>\n<li><p>A <b>database operation</b> (SERVERERROR, LOGON, LOGOFF, STARTUP, or SHUTDOWN).</p></li>\n</ul>\n<p>Triggers can be defined on the table, view, schema, or database with which the event is associated.</p>\n<h3>Benefits of Triggers</h3>\n<p>Triggers can be written for the following purposes \u2212</p>\n<ul class=\"list\">\n<li>Generating some derived column values automatically</li>\n<li>Enforcing referential integrity</li>\n<li>Event logging and storing information on table access</li>\n<li>Auditing</li>\n<li>Synchronous replication of tables</li>\n<li>Imposing security authorizations</li>\n<li>Preventing invalid transactions</li>\n</ul>\n<h2>Creating Triggers</h2>\n<p>The syntax for creating a trigger is \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE [OR REPLACE ] TRIGGER trigger_name  \n{BEFORE | AFTER | INSTEAD OF }  \n{INSERT [OR] | UPDATE [OR] | DELETE}  \n[OF col_name]  \nON table_name  \n[REFERENCING OLD AS o NEW AS n]  \n[FOR EACH ROW]  \nWHEN (condition)   \nDECLARE \n   Declaration-statements \nBEGIN  \n   Executable-statements \nEXCEPTION \n   Exception-handling-statements \nEND; \n</pre>\n<p>Where,</p>\n<ul class=\"list\">\n<li><p>CREATE [OR REPLACE] TRIGGER trigger_name \u2212 Creates or replaces an existing trigger with the <i>trigger_name</i>.</p></li>\n<li><p>{BEFORE | AFTER | INSTEAD OF} \u2212 This specifies when the trigger will be executed. The INSTEAD OF clause is used for creating trigger on a view.</p></li>\n<li><p>{INSERT [OR] | UPDATE [OR] | DELETE} \u2212 This specifies the DML operation.</p></li>\n<li><p>[OF col_name] \u2212 This specifies the column name that will be updated.</p></li>\n<li><p>[ON table_name] \u2212 This specifies the name of the table associated with the trigger.</p></li>\n<li><p>[REFERENCING OLD AS o NEW AS n] \u2212 This allows you to refer new and old values for various DML statements, such as INSERT, UPDATE, and DELETE.</p></li>\n<li><p>[FOR EACH ROW] \u2212 This specifies a row-level trigger, i.e., the trigger will be executed for each row being affected. Otherwise the trigger will execute just once when the SQL statement is executed, which is called a table level trigger.</p></li>\n<li><p>WHEN (condition) \u2212 This provides a condition for rows for which the trigger would fire. This clause is valid only for row-level triggers.</p></li>\n</ul>\n<h3>Example</h3>\n<p>To start with, we will be using the CUSTOMERS table we had created and used in the previous chapters \u2212</p>\n<pre class=\"result notranslate\">\nSelect * from customers;  \n\n+----+----------+-----+-----------+----------+ \n| ID | NAME     | AGE | ADDRESS   | SALARY   | \n+----+----------+-----+-----------+----------+ \n|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 | \n|  2 | Khilan   |  25 | Delhi     |  1500.00 | \n|  3 | kaushik  |  23 | Kota      |  2000.00 | \n|  4 | Chaitali |  25 | Mumbai    |  6500.00 | \n|  5 | Hardik   |  27 | Bhopal    |  8500.00 | \n|  6 | Komal    |  22 | MP        |  4500.00 | \n+----+----------+-----+-----------+----------+ \n</pre>\n<p>The following program creates a <b>row-level</b> trigger for the customers table that would fire for INSERT or UPDATE or DELETE operations performed on the CUSTOMERS table. This trigger will display the salary difference between the old values and new values \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TRIGGER display_salary_changes \nBEFORE DELETE OR INSERT OR UPDATE ON customers \nFOR EACH ROW \nWHEN (NEW.ID &gt; 0) \nDECLARE \n   sal_diff number; \nBEGIN \n   sal_diff := :NEW.salary  - :OLD.salary; \n   dbms_output.put_line('Old salary: ' || :OLD.salary); \n   dbms_output.put_line('New salary: ' || :NEW.salary); \n   dbms_output.put_line('Salary difference: ' || sal_diff); \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nTrigger created.\n</pre>\n<p>The following points need to be considered here \u2212</p>\n<ul class=\"list\">\n<li><p>OLD and NEW references are not available for table-level triggers, rather you can use them for record-level triggers.</p></li>\n<li><p>If you want to query the table in the same trigger, then you should use the AFTER keyword, because triggers can query the table or change it again only after the initial changes are applied and the table is back in a consistent state.</p></li>\n<li><p>The above trigger has been written in such a way that it will fire before any DELETE or INSERT or UPDATE operation on the table, but you can write your trigger on a single or multiple operations, for example BEFORE DELETE, which will fire whenever a record will be deleted using the DELETE operation on the table.</p></li>\n</ul>\n<h2>Triggering a Trigger</h2>\n<p>Let us perform some DML operations on the CUSTOMERS table. Here is one INSERT statement, which will create a new record in the table \u2212</p>\n<pre class=\"prettyprint notranslate\">\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (7, 'Kriti', 22, 'HP', 7500.00 ); \n</pre>\n<p>When a record is created in the CUSTOMERS table, the above create trigger, <b>display_salary_changes</b> will be fired and it will display the following result \u2212</p>\n<pre class=\"result notranslate\">\nOld salary: \nNew salary: 7500 \nSalary difference:\n</pre>\n<p>Because this is a new record, old salary is not available and the above result comes as null. Let us now perform one more DML operation on the CUSTOMERS table. The UPDATE statement will update an existing record in the table \u2212</p>\n<pre class=\"prettyprint notranslate\">\nUPDATE customers \nSET salary = salary + 500 \nWHERE id = 2; \n</pre>\n<p>When a record is updated in the CUSTOMERS table, the above create trigger, <b>display_salary_changes</b> will be fired and it will display the following result \u2212</p>\n<pre class=\"result notranslate\">\nOld salary: 1500 \nNew salary: 2000 \nSalary difference: 500 \n</pre>\n<h1>PL/SQL - Packages</h1>\n<p>In this chapter, we will discuss the Packages in PL/SQL. Packages are schema objects that groups logically related PL/SQL types, variables, and subprograms.</p>\n<p>A package will have two mandatory parts \u2212</p>\n<ul class=\"list\">\n<li>Package specification</li>\n<li>Package body or definition</li>\n</ul>\n<h2>Package Specification</h2>\n<p>The specification is the interface to the package. It just <b>DECLARES</b> the types, variables, constants, exceptions, cursors, and subprograms that can be referenced from outside the package. In other words, it contains all information about the content of the package, but excludes the code for the subprograms.</p>\n<p>All objects placed in the specification are called <b>public</b> objects. Any subprogram not in the package specification but coded in the package body is called a <b>private</b> object.</p>\n<p>The following code snippet shows a package specification having a single procedure. You can have many global variables defined and multiple procedures or functions inside a package.</p>\n<pre class=\"prettyprint notranslate\">\nCREATE PACKAGE cust_sal AS \n   PROCEDURE find_sal(c_id customers.id%type); \nEND cust_sal; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nPackage created.\n</pre>\n<h2>Package Body</h2>\n<p>The package body has the codes for various methods declared in the package specification and other private declarations, which are hidden from the code outside the package.</p>\n<p>The <b>CREATE PACKAGE BODY</b> Statement is used for creating the package body. The following code snippet shows the package body declaration for the <b><i>cust_sal</i></b> package created above. I assumed that we already have CUSTOMERS table created in our database as mentioned in the <a href=\"/plsql/plsql_variable_types.htm\">PL/SQL - Variables</a> chapter.</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE PACKAGE BODY cust_sal AS  \n   \n   PROCEDURE find_sal(c_id customers.id%TYPE) IS \n   c_sal customers.salary%TYPE; \n   BEGIN \n      SELECT salary INTO c_sal \n      FROM customers \n      WHERE id = c_id; \n      dbms_output.put_line('Salary: '|| c_sal); \n   END find_sal; \nEND cust_sal; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nPackage body created.\n</pre>\n<h2>Using the Package Elements</h2>\n<p>The package elements (variables, procedures or functions) are accessed with the following syntax \u2212</p>\n<pre class=\"result notranslate\">\npackage_name.element_name;\n</pre>\n<p>Consider, we already have created the above package in our database schema, the following program uses the <b><i>find_sal</i></b> method of the <b><i>cust_sal</i></b> package \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   code customers.id%type := &amp;cc_id; \nBEGIN \n   cust_sal.find_sal(code); \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it prompts to enter the customer ID and when you enter an ID, it displays the corresponding salary as follows \u2212</p>\n<pre class=\"result notranslate\">\nEnter value for cc_id: 1 \nSalary: 3000 \n\nPL/SQL procedure successfully completed. \n</pre>\n<h3>Example</h3>\n<p>The following program provides a more complete package. We will use the CUSTOMERS table stored in our database with the following records \u2212</p>\n<pre class=\"result notranslate\">\nSelect * from customers;  \n\n+----+----------+-----+-----------+----------+ \n| ID | NAME     | AGE | ADDRESS   | SALARY   | \n+----+----------+-----+-----------+----------+ \n|  1 | Ramesh   |  32 | Ahmedabad |  3000.00 | \n|  2 | Khilan   |  25 | Delhi     |  3000.00 | \n|  3 | kaushik  |  23 | Kota      |  3000.00 | \n|  4 | Chaitali |  25 | Mumbai    |  7500.00 | \n|  5 | Hardik   |  27 | Bhopal    |  9500.00 | \n|  6 | Komal    |  22 | MP        |  5500.00 | \n+----+----------+-----+-----------+----------+\n</pre>\n<h3>The Package Specification</h3>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE PACKAGE c_package AS \n   -- Adds a customer \n   PROCEDURE addCustomer(c_id   customers.id%type, \n   c_name  customerS.No.ame%type, \n   c_age  customers.age%type, \n   c_addr customers.address%type,  \n   c_sal  customers.salary%type); \n   \n   -- Removes a customer \n   PROCEDURE delCustomer(c_id  customers.id%TYPE); \n   --Lists all customers \n   PROCEDURE listCustomer; \n  \nEND c_package; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it creates the above package and displays the following result \u2212</p>\n<pre class=\"result notranslate\">\nPackage created.\n</pre>\n<h3>Creating the Package Body</h3>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE PACKAGE BODY c_package AS \n   PROCEDURE addCustomer(c_id  customers.id%type, \n      c_name customerS.No.ame%type, \n      c_age  customers.age%type, \n      c_addr  customers.address%type,  \n      c_sal   customers.salary%type) \n   IS \n   BEGIN \n      INSERT INTO customers (id,name,age,address,salary) \n         VALUES(c_id, c_name, c_age, c_addr, c_sal); \n   END addCustomer; \n   \n   PROCEDURE delCustomer(c_id   customers.id%type) IS \n   BEGIN \n      DELETE FROM customers \n      WHERE id = c_id; \n   END delCustomer;  \n   \n   PROCEDURE listCustomer IS \n   CURSOR c_customers is \n      SELECT  name FROM customers; \n   TYPE c_list is TABLE OF customerS.No.ame%type; \n   name_list c_list := c_list(); \n   counter integer :=0; \n   BEGIN \n      FOR n IN c_customers LOOP \n      counter := counter +1; \n      name_list.extend; \n      name_list(counter) := n.name; \n      dbms_output.put_line('Customer(' ||counter|| ')'||name_list(counter)); \n      END LOOP; \n   END listCustomer;\n   \nEND c_package; \n/\n</pre>\n<p>The above example makes use of the <b>nested table</b>. We will discuss the concept of nested table in the next chapter.</p>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nPackage body created.\n</pre>\n<h3>Using The Package</h3>\n<p>The following program uses the methods declared and defined in the package <i>c_package</i>.</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   code customers.id%type:= 8; \nBEGIN \n   c_package.addcustomer(7, 'Rajnish', 25, 'Chennai', 3500); \n   c_package.addcustomer(8, 'Subham', 32, 'Delhi', 7500); \n   c_package.listcustomer; \n   c_package.delcustomer(code); \n   c_package.listcustomer; \nEND; \n/  \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nCustomer(1): Ramesh  \nCustomer(2): Khilan  \nCustomer(3): kaushik     \nCustomer(4): Chaitali  \nCustomer(5): Hardik  \nCustomer(6): Komal \nCustomer(7): Rajnish \nCustomer(8): Subham \nCustomer(1): Ramesh  \nCustomer(2): Khilan  \nCustomer(3): kaushik     \nCustomer(4): Chaitali  \nCustomer(5): Hardik  \nCustomer(6): Komal\nCustomer(7): Rajnish \n\nPL/SQL procedure successfully completed \n</pre>\n<h1>PL/SQL - Collections</h1>\n<p>In this chapter, we will discuss the Collections in PL/SQL. A collection is an ordered group of elements having the same data type. Each element is identified by a unique subscript that represents its position in the collection.</p>\n<p>PL/SQL provides three collection types \u2212</p>\n<ul class=\"list\">\n<li>Index-by tables or Associative array</li>\n<li>Nested table</li>\n<li>Variable-size array or Varray</li>\n</ul>\n<p>Oracle documentation provides the following characteristics for each type of collections \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center; vertical-align:middle;\">Collection Type</th>\n<th style=\"text-align:center; vertical-align:middle;\">Number of Elements</th>\n<th style=\"text-align:center; vertical-align:middle;\">Subscript Type</th>\n<th style=\"text-align:center; vertical-align:middle;\">Dense or Sparse</th>\n<th style=\"text-align:center; vertical-align:middle;\">Where Created</th>\n<th style=\"text-align:center; vertical-align:middle;\">Can Be Object Type Attribute</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">Associative array (or index-by table)</td>\n<td style=\"text-align:center; vertical-align:middle;\">Unbounded</td>\n<td style=\"text-align:center; vertical-align:middle;\">String or integer</td>\n<td style=\"text-align:center; vertical-align:middle;\">Either</td>\n<td style=\"vertical-align:middle;\">Only in PL/SQL block</td>\n<td style=\"text-align:center; vertical-align:middle;\">No</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">Nested table</td>\n<td style=\"text-align:center; vertical-align:middle;\">Unbounded</td>\n<td style=\"text-align:center; vertical-align:middle;\">Integer</td>\n<td style=\"text-align:center; vertical-align:middle;\">Starts dense, can become sparse</td>\n<td style=\"vertical-align:middle;\">Either in PL/SQL block or at schema level</td>\n<td style=\"text-align:center; vertical-align:middle;\">Yes</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">Variablesize array (Varray)</td>\n<td style=\"text-align:center; vertical-align:middle;\">Bounded</td>\n<td style=\"text-align:center; vertical-align:middle;\">Integer</td>\n<td style=\"text-align:center; vertical-align:middle;\">Always dense</td>\n<td style=\"vertical-align:middle;\">Either in PL/SQL block or at schema level</td>\n<td style=\"text-align:center; vertical-align:middle;\">Yes</td>\n</tr>\n</table>\n<p>We have already discussed varray in the chapter <b>'PL/SQL arrays'</b>. In this chapter, we will discuss the PL/SQL tables.</p>\n<p>Both types of PL/SQL tables, i.e., the index-by tables and the nested tables have the same structure and their rows are accessed using the subscript notation. However, these two types of tables differ in one aspect; the nested tables can be stored in a database column and the index-by tables cannot.</p>\n<h2>Index-By Table</h2>\n<p>An <b>index-by</b> table (also called an <b>associative array</b>) is a set of <b>key-value</b> pairs. Each key is unique and is used to locate the corresponding value. The key can be either an integer or a string.</p>\n<p>An index-by table is created using the following syntax. Here, we are creating an <b>index-by</b> table named <b>table_name</b>, the keys of which will be of the subscript_type and associated values will be of the <i>element_type</i></p>\n<pre class=\"result notranslate\">\nTYPE type_name IS TABLE OF element_type [NOT NULL] INDEX BY subscript_type; \n \ntable_name type_name;\n</pre>\n<h3>Example</h3>\n<p>Following example shows how to create a table to store integer values along with names and later it prints the same list of names.</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   TYPE salary IS TABLE OF NUMBER INDEX BY VARCHAR2(20); \n   salary_list salary; \n   name   VARCHAR2(20); \nBEGIN \n   -- adding elements to the table \n   salary_list('Rajnish') := 62000; \n   salary_list('Minakshi') := 75000; \n   salary_list('Martin') := 100000; \n   salary_list('James') := 78000;  \n   \n   -- printing the table \n   name := salary_list.FIRST; \n   WHILE name IS NOT null LOOP \n      dbms_output.put_line \n      ('Salary of ' || name || ' is ' || TO_CHAR(salary_list(name))); \n      name := salary_list.NEXT(name); \n   END LOOP; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nSalary of James is 78000 \nSalary of Martin is 100000 \nSalary of Minakshi is 75000 \nSalary of Rajnish is 62000  \n\nPL/SQL procedure successfully completed.\n</pre>\n<h3>Example</h3>\n<p>Elements of an index-by table could also be a <b>%ROWTYPE</b> of any database table or <b>%TYPE</b> of any database table field. The following example illustrates the concept. We will use the <b>CUSTOMERS</b> table stored in our database as \u2212</p>\n<pre class=\"result notranslate\">\nSelect * from customers;  \n\n+----+----------+-----+-----------+----------+ \n| ID | NAME     | AGE | ADDRESS   | SALARY   | \n+----+----------+-----+-----------+----------+ \n|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 | \n|  2 | Khilan   |  25 | Delhi     |  1500.00 | \n|  3 | kaushik  |  23 | Kota      |  2000.00 | \n|  4 | Chaitali |  25 | Mumbai    |  6500.00 | \n|  5 | Hardik   |  27 | Bhopal    |  8500.00 | \n|  6 | Komal    |  22 | MP        |  4500.00 | \n+----+----------+-----+-----------+----------+  \n</pre>\n<p></p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   CURSOR c_customers is \n      select name from customers; \n\n   TYPE c_list IS TABLE of customers.Name%type INDEX BY binary_integer; \n   name_list c_list; \n   counter integer :=0; \nBEGIN \n   FOR n IN c_customers LOOP \n      counter := counter +1; \n      name_list(counter) := n.name; \n      dbms_output.put_line('Customer('||counter||'):'||name_lis t(counter)); \n   END LOOP; \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nCustomer(1): Ramesh  \nCustomer(2): Khilan  \nCustomer(3): kaushik     \nCustomer(4): Chaitali  \nCustomer(5): Hardik  \nCustomer(6): Komal  \n\nPL/SQL procedure successfully completed\n</pre>\n<h2>Nested Tables</h2>\n<p>A <b>nested table</b> is like a one-dimensional array with an arbitrary number of elements. However, a nested table differs from an array in the following aspects \u2212</p>\n<ul class=\"list\">\n<li><p>An array has a declared number of elements, but a nested table does not. The size of a nested table can increase dynamically.</p></li>\n<li><p>An array is always dense, i.e., it always has consecutive subscripts. A nested array is dense initially, but it can become sparse when elements are deleted from it.</p></li>\n</ul>\n<p>A nested table is created using the following syntax \u2212</p>\n<pre class=\"result notranslate\">\nTYPE type_name IS TABLE OF element_type [NOT NULL]; \n \ntable_name type_name; \n</pre>\n<p>This declaration is similar to the declaration of an <b>index-by</b> table, but there is no <b>INDEX BY</b> clause.</p>\n<p>A nested table can be stored in a database column. It can further be used for simplifying SQL operations where you join a single-column table with a larger table. An associative array cannot be stored in the database.</p>\n<h3>Example</h3>\n<p>The following examples illustrate the use of nested table \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   TYPE names_table IS TABLE OF VARCHAR2(10); \n   TYPE grades IS TABLE OF INTEGER;  \n   names names_table; \n   marks grades; \n   total integer; \nBEGIN \n   names := names_table('Kavita', 'Pritam', 'Ayan', 'Rishav', 'Aziz'); \n   marks:= grades(98, 97, 78, 87, 92); \n   total := names.count; \n   dbms_output.put_line('Total '|| total || ' Students'); \n   FOR i IN 1 .. total LOOP \n      dbms_output.put_line('Student:'||names(i)||', Marks:' || marks(i)); \n   end loop; \nEND; \n/  \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nTotal 5 Students \nStudent:Kavita, Marks:98 \nStudent:Pritam, Marks:97 \nStudent:Ayan, Marks:78 \nStudent:Rishav, Marks:87 \nStudent:Aziz, Marks:92  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h3>Example</h3>\n<p>Elements of a <b>nested table</b> can also be a <b>%ROWTYPE</b> of any database table or %TYPE of any database table field. The following example illustrates the concept. We will use the CUSTOMERS table stored in our database as \u2212</p>\n<pre class=\"result notranslate\">\nSelect * from customers;  \n\n+----+----------+-----+-----------+----------+ \n| ID | NAME     | AGE | ADDRESS   | SALARY   | \n+----+----------+-----+-----------+----------+ \n|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 | \n|  2 | Khilan   |  25 | Delhi     |  1500.00 | \n|  3 | kaushik  |  23 | Kota      |  2000.00 | \n|  4 | Chaitali |  25 | Mumbai    |  6500.00 | \n|  5 | Hardik   |  27 | Bhopal    |  8500.00 | \n|  6 | Komal    |  22 | MP        |  4500.00 | \n+----+----------+-----+-----------+----------+ \n</pre>\n<p></p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   CURSOR c_customers is  \n      SELECT  name FROM customers;  \n   TYPE c_list IS TABLE of customerS.No.ame%type; \n   name_list c_list := c_list(); \n   counter integer :=0; \nBEGIN \n   FOR n IN c_customers LOOP \n      counter := counter +1; \n      name_list.extend; \n      name_list(counter)  := n.name; \n      dbms_output.put_line('Customer('||counter||'):'||name_list(counter)); \n   END LOOP; \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nCustomer(1): Ramesh  \nCustomer(2): Khilan  \nCustomer(3): kaushik     \nCustomer(4): Chaitali  \nCustomer(5): Hardik  \nCustomer(6): Komal  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>Collection Methods</h2>\n<p>PL/SQL provides the built-in collection methods that make collections easier to use. The following table lists the methods and their purpose \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Method Name &amp; Purpose</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>EXISTS(n)</b></p>\n<p>Returns TRUE if the nth element in a collection exists; otherwise returns FALSE.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>COUNT</b></p>\n<p>Returns the number of elements that a collection currently contains.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>LIMIT</b></p>\n<p>Checks the maximum size of a collection.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>FIRST</b></p>\n<p>Returns the first (smallest) index numbers in a collection that uses the integer subscripts.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><p><b>LAST</b></p>\n<p>Returns the last (largest) index numbers in a collection that uses the integer subscripts.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">6</td>\n<td><p><b>PRIOR(n)</b></p>\n<p>Returns the index number that precedes index n in a collection.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">7</td>\n<td><p><b>NEXT(n)</b></p>\n<p>Returns the index number that succeeds index n.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">8</td>\n<td><p><b>EXTEND</b></p>\n<p>Appends one null element to a collection.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">9</td>\n<td><p><b>EXTEND(n)</b></p>\n<p>Appends n null elements to a collection.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">10</td>\n<td><p><b>EXTEND(n,i)</b></p>\n<p>Appends <b>n</b> copies of the i<sup>th</sup> element to a collection.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">11</td>\n<td><p><b>TRIM</b></p>\n<p>Removes one element from the end of a collection.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">12</td>\n<td><p><b>TRIM(n)</b></p>\n<p>Removes <b>n</b> elements from the end of a collection.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">13</td>\n<td><p><b>DELETE</b></p>\n<p>Removes all elements from a collection, setting COUNT to 0.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">14</td>\n<td><p><b>DELETE(n)</b></p>\n<p>Removes the <b>n<sup>th</sup></b> element from an associative array with a numeric key or a nested table. If the associative array has a string key, the element corresponding to the key value is deleted. If <b>n</b> is null, <b>DELETE(n)</b> does nothing.</p></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">15</td>\n<td><p><b>DELETE(m,n)</b></p>\n<p>Removes all elements in the range <b>m..n</b> from an associative array or nested table. If <b>m</b> is larger than <b>n</b> or if <b>m</b> or <b>n</b> is null, <b>DELETE(m,n)</b> does nothing.</p></td>\n</tr>\n</table>\n<h2>Collection Exceptions</h2>\n<p>The following table provides the collection exceptions and when they are raised \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">Collection Exception</th>\n<th style=\"text-align:center;\">Raised in Situations</th>\n</tr>\n<tr>\n<td style=\"text-align:center;\">COLLECTION_IS_NULL</td>\n<td>You try to operate on an atomically null collection.</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">NO_DATA_FOUND</td>\n<td>A subscript designates an element that was deleted, or a nonexistent element of an associative array.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">SUBSCRIPT_BEYOND_COUNT</td>\n<td>A subscript exceeds the number of elements in a collection.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;\">SUBSCRIPT_OUTSIDE_LIMIT</td>\n<td>A subscript is outside the allowed range.</td>\n</tr>\n<tr>\n<td style=\"text-align:center;vertical-align:middle;\">VALUE_ERROR</td>\n<td>A subscript is null or not convertible to the key type. This exception might occur if the key is defined as a <b>PLS_INTEGER</b> range, and the subscript is outside this range.</td>\n</tr>\n</table>\n<h1>PL/SQL - Transactions</h1>\n<p>In this chapter, we will discuss the transactions in PL/SQL. A database <b>transaction</b> is an atomic unit of work that may consist of one or more related SQL statements. It is called atomic because the database modifications brought about by the SQL statements that constitute a transaction can collectively be either committed, i.e., made permanent to the database or rolled back (undone) from the database.</p>\n<p>A successfully executed SQL statement and a committed transaction are not same. Even if an SQL statement is executed successfully, unless the transaction containing the statement is committed, it can be rolled back and all changes made by the statement(s) can be undone.</p>\n<h2>Starting and Ending a Transaction</h2>\n<p>A transaction has a <b>beginning</b> and an <b>end</b>. A transaction starts when one of the following events take place \u2212</p>\n<ul class=\"list\">\n<li><p>The first SQL statement is performed after connecting to the database.</p></li>\n<li><p>At each new SQL statement issued after a transaction is completed.</p></li>\n</ul>\n<p>A transaction ends when one of the following events take place \u2212</p>\n<ul class=\"list\">\n<li><p>A <b>COMMIT</b> or a <b>ROLLBACK</b> statement is issued.</p></li>\n<li><p>A <b>DDL</b> statement, such as <b>CREATE TABLE</b> statement, is issued; because in that case a COMMIT is automatically performed.</p></li>\n<li><p>A <b>DCL</b> statement, such as a <b>GRANT</b> statement, is issued; because in that case a COMMIT is automatically performed.</p></li>\n<li><p>User disconnects from the database.</p></li>\n<li><p>User exits from <b>SQL*PLUS</b> by issuing the <b>EXIT</b> command, a COMMIT is automatically performed.</p></li>\n<li><p>SQL*Plus terminates abnormally, a <b>ROLLBACK</b> is automatically performed.</p></li>\n<li><p>A <b>DML</b> statement fails; in that case a ROLLBACK is automatically performed for undoing that DML statement.</p></li>\n</ul>\n<h2>Committing a Transaction</h2>\n<p>A transaction is made permanent by issuing the SQL command COMMIT. The general syntax for the COMMIT command is \u2212</p>\n<pre class=\"result notranslate\">\nCOMMIT;\n</pre>\n<p>For example,</p>\n<pre class=\"prettyprint notranslate\">\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (1, 'Ramesh', 32, 'Ahmedabad', 2000.00 ); \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (2, 'Khilan', 25, 'Delhi', 1500.00 ); \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (3, 'kaushik', 23, 'Kota', 2000.00 ); \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (4, 'Chaitali', 25, 'Mumbai', 6500.00 ); \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (5, 'Hardik', 27, 'Bhopal', 8500.00 ); \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (6, 'Komal', 22, 'MP', 4500.00 ); \n\nCOMMIT;\n</pre>\n<h2>Rolling Back Transactions</h2>\n<p>Changes made to the database without COMMIT could be undone using the ROLLBACK command.</p>\n<p>The general syntax for the ROLLBACK command is \u2212</p>\n<pre class=\"result notranslate\">\nROLLBACK [TO SAVEPOINT &lt; savepoint_name&gt;]; \n</pre>\n<p>When a transaction is aborted due to some unprecedented situation, like system failure, the entire transaction since a commit is automatically rolled back. If you are not using <b>savepoint</b>, then simply use the following statement to rollback all the changes \u2212</p>\n<pre class=\"result notranslate\">\nROLLBACK;\n</pre>\n<h3>Savepoints</h3>\n<p>Savepoints are sort of markers that help in splitting a long transaction into smaller units by setting some checkpoints. By setting savepoints within a long transaction, you can roll back to a checkpoint if required. This is done by issuing the <b>SAVEPOINT</b> command.</p>\n<p>The general syntax for the SAVEPOINT command is \u2212</p>\n<pre class=\"result notranslate\">\nSAVEPOINT &lt; savepoint_name &gt;;\n</pre>\n<p>For example</p>\n<pre class=\"prettyprint notranslate\">\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (7, 'Rajnish', 27, 'HP', 9500.00 ); \n\nINSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) \nVALUES (8, 'Riddhi', 21, 'WB', 4500.00 ); \nSAVEPOINT sav1;\n  \nUPDATE CUSTOMERS \nSET SALARY = SALARY + 1000; \nROLLBACK TO sav1;\n  \nUPDATE CUSTOMERS \nSET SALARY = SALARY + 1000 \nWHERE ID = 7; \nUPDATE CUSTOMERS \nSET SALARY = SALARY + 1000 \nWHERE ID = 8; \n\nCOMMIT;\n</pre>\n<p><b>ROLLBACK TO sav1</b> \u2212 This statement rolls back all the changes up to the point, where you had marked savepoint sav1.</p>\n<p>After that, the new changes that you make will start.</p>\n<h2>Automatic Transaction Control</h2>\n<p>To execute a <b>COMMIT</b> automatically whenever an <b>INSERT, UPDATE</b> or <b>DELETE</b> command is executed, you can set the <b>AUTOCOMMIT</b> environment variable as \u2212</p>\n<pre class=\"result notranslate\">\nSET AUTOCOMMIT ON; \n</pre>\n<p>You can turn-off the auto commit mode using the following command \u2212</p>\n<pre class=\"result notranslate\">\nSET AUTOCOMMIT OFF;\n</pre>\n<h1>PL/SQL - Date &amp; Time</h1>\n<p>In this chapter, we will discuss the Date and Time in PL/SQL. There are two classes of date and time related data types in PL/SQL \u2212</p>\n<ul class=\"list\">\n<li>Datetime data types</li>\n<li>Interval data types</li>\n</ul>\n<p>The Datetime data types are \u2212</p>\n<ul class=\"list\">\n<li>DATE</li>\n<li>TIMESTAMP</li>\n<li>TIMESTAMP WITH TIME ZONE</li>\n<li>TIMESTAMP WITH LOCAL TIME ZONE</li>\n</ul>\n<p>The Interval data types are \u2212</p>\n<ul class=\"list\">\n<li>INTERVAL YEAR TO MONTH</li>\n<li>INTERVAL DAY TO SECOND</li>\n</ul>\n<h2>Field Values for Datetime and Interval Data Types</h2>\n<p>Both <b>datetime</b> and <b>interval</b> data types consist of <b>fields</b>. The values of these fields determine the value of the data type. The following table lists the fields and their possible values for datetimes and intervals.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center; vertical-align:middle;\">Field Name</th>\n<th style=\"text-align:center; vertical-align:middle;\">Valid Datetime Values</th>\n<th style=\"text-align:center; vertical-align:middle;\">Valid Interval Values</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">YEAR</td>\n<td style=\"text-align:center; vertical-align:middle;\">-4712 to 9999 (excluding year 0)</td>\n<td style=\"text-align:center; vertical-align:middle;\">Any nonzero integer</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">MONTH</td>\n<td style=\"text-align:center; vertical-align:middle;\">01 to 12</td>\n<td style=\"text-align:center; vertical-align:middle;\">0 to 11</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">DAY</td>\n<td>01 to 31 (limited by the values of MONTH and YEAR, according to the rules of the calendar for the locale)</td>\n<td style=\"text-align:center; vertical-align:middle;\">Any nonzero integer</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">HOUR</td>\n<td style=\"text-align:center; vertical-align:middle;\">00 to 23</td>\n<td style=\"text-align:center; vertical-align:middle;\">0 to 23</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">MINUTE</td>\n<td style=\"text-align:center; vertical-align:middle;\">00 to 59</td>\n<td style=\"text-align:center; vertical-align:middle;\">0 to 59</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">SECOND</td>\n<td><p>00 to 59.9(n), where 9(n) is the precision of time fractional seconds</p>\n<p>The 9(n) portion is not applicable for DATE.</p>\n</td>\n<td style=\"text-align:center; vertical-align:middle;\">0 to 59.9(n), where 9(n) is the precision of interval fractional seconds</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TIMEZONE_HOUR</td>\n<td><p>-12 to 14 (range accommodates daylight savings time changes)</p>\n<p>Not applicable for DATE or TIMESTAMP.</p>\n</td>\n<td style=\"text-align:center; vertical-align:middle;\">Not applicable</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TIMEZONE_MINUTE</td>\n<td><p>00 to 59</p>\n<p>Not applicable for DATE or TIMESTAMP.</p>\n</td>\n<td style=\"text-align:center; vertical-align:middle;\">Not applicable</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TIMEZONE_REGION</td>\n<td>Not applicable for DATE or TIMESTAMP.</td>\n<td style=\"text-align:center; vertical-align:middle;\">Not applicable</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">TIMEZONE_ABBR</td>\n<td>Not applicable for DATE or TIMESTAMP.</td>\n<td style=\"text-align:center; vertical-align:middle;\">Not applicable</td>\n</tr>\n</table>\n<h2>The Datetime Data Types and Functions</h2>\n<p>Following are the Datetime data types \u2212</p>\n<h3>DATE</h3>\n<p>It stores date and time information in both character and number datatypes. It is made of information on century, year, month, date, hour, minute, and second. It is specified as \u2212</p>\n<h3>TIMESTAMP</h3>\n<p>It is an extension of the DATE data type. It stores the year, month, and day of the DATE datatype, along with hour, minute, and second values. It is useful for storing precise time values.</p>\n<h3>TIMESTAMP WITH TIME ZONE</h3>\n<p>It is a variant of TIMESTAMP that includes a time zone region name or a time zone offset in its value. The time zone offset is the difference (in hours and minutes) between local time and UTC. This data type is useful for collecting and evaluating date information across geographic regions.</p>\n<h3>TIMESTAMP WITH LOCAL TIME ZONE</h3>\n<p>It is another variant of TIMESTAMP that includes a time zone offset in its value.</p>\n<p>Following table provides the Datetime functions (where, x has the datetime value) \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Function Name &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>ADD_MONTHS(x, y);</b></p>\n<p>Adds <b>y</b> months to <b>x</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>LAST_DAY(x);</b></p>\n<p>Returns the last day of the month.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>MONTHS_BETWEEN(x, y);</b></p>\n<p>Returns the number of months between <b>x</b> and <b>y</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>NEXT_DAY(x, day);</b></p>\n<p>Returns the datetime of the next <i>day</i> after <b>x</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><p><b>NEW_TIME;</b></p>\n<p>Returns the time/day value from a time zone specified by the user.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">6</td>\n<td><p><b>ROUND(x [, unit]);</b></p>\n<p>Rounds <b>x</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">7</td>\n<td><p><b>SYSDATE();</b></p>\n<p>Returns the current datetime.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">8</td>\n<td><p><b>TRUNC(x [, unit]);</b></p>\n<p>Truncates <b>x</b>.</p>\n</td>\n</tr>\n</table>\n<p>Timestamp functions (where, x has a timestamp value) \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Function Name &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>CURRENT_TIMESTAMP();</b></p>\n<p>Returns a TIMESTAMP WITH TIME ZONE containing the current session time along with the session time zone.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>EXTRACT({ YEAR | MONTH | DAY | HOUR | MINUTE | SECOND } | { TIMEZONE_HOUR | TIMEZONE_MINUTE } | { TIMEZONE_REGION | } TIMEZONE_ABBR ) FROM x)</b></p>\n<p>Extracts and returns a year, month, day, hour, minute, second, or time zone from <b>x</b>.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>FROM_TZ(x, time_zone);</b></p>\n<p>Converts the TIMESTAMP x and the time zone specified by time_zone to a TIMESTAMP WITH TIMEZONE.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>LOCALTIMESTAMP();</b></p>\n<p>Returns a TIMESTAMP containing the local time in the session time zone.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><p><b>SYSTIMESTAMP();</b></p>\n<p>Returns a TIMESTAMP WITH TIME ZONE containing the current database time along with the database time zone.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">6</td>\n<td><p><b>SYS_EXTRACT_UTC(x);</b></p>\n<p>Converts the TIMESTAMP WITH TIMEZONE x to a TIMESTAMP containing the date and time in UTC.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">7</td>\n<td><p><b>TO_TIMESTAMP(x, [format]);</b></p>\n<p>Converts the string x to a TIMESTAMP.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">8</td>\n<td><p><b>TO_TIMESTAMP_TZ(x, [format]);</b></p>\n<p>Converts the string x to a TIMESTAMP WITH TIMEZONE.</p>\n</td>\n</tr>\n</table>\n<h3>Examples</h3>\n<p>The following code snippets illustrate the use of the above functions \u2212</p>\n<p><b>Example 1</b></p>\n<pre class=\"prettyprint notranslate\">\nSELECT SYSDATE FROM DUAL; \n</pre>\n<p><b>Output</b> \u2212</p>\n<pre class=\"result notranslate\">\n08/31/2012 5:25:34 PM \n</pre>\n<p><b>Example 2</b></p>\n<pre class=\"prettyprint notranslate\">\nSELECT TO_CHAR(CURRENT_DATE, 'DD-MM-YYYY HH:MI:SS') FROM DUAL; \n</pre>\n<p><b>Output</b> \u2212</p>\n<pre class=\"result notranslate\">\n31-08-2012 05:26:14\n</pre>\n<p><b>Example 3</b></p>\n<pre class=\"prettyprint notranslate\">\nSELECT ADD_MONTHS(SYSDATE, 5) FROM DUAL;\n</pre>\n<p><b>Output</b> \u2212</p>\n<pre class=\"result notranslate\">\n01/31/2013 5:26:31 PM \n</pre>\n<p><b>Example 4</b></p>\n<pre class=\"prettyprint notranslate\">\nSELECT LOCALTIMESTAMP FROM DUAL; \n</pre>\n<p><b>Output</b> \u2212</p>\n<pre class=\"result notranslate\">\n8/31/2012 5:26:55.347000 PM \n</pre>\n<h2>The Interval Data Types and Functions</h2>\n<p>Following are the Interval data types \u2212</p>\n<ul class=\"list\">\n<li><p>IINTERVAL YEAR TO MONTH \u2212 It stores a period of time using the YEAR and MONTH datetime fields.</p></li>\n<li><p>INTERVAL DAY TO SECOND \u2212 It stores a period of time in terms of days, hours, minutes, and seconds. </p></li>\n</ul>\n<h3>Interval Functions</h3>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Function Name &amp; Description</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>NUMTODSINTERVAL(x, interval_unit);</b></p>\n<p>Converts the number x to an INTERVAL DAY TO SECOND.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>NUMTOYMINTERVAL(x, interval_unit);</b></p>\n<p>Converts the number x to an INTERVAL YEAR TO MONTH.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>TO_DSINTERVAL(x);</b></p>\n<p>Converts the string x to an INTERVAL DAY TO SECOND.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>TO_YMINTERVAL(x);</b></p>\n<p>Converts the string x to an INTERVAL YEAR TO MONTH.</p>\n</td>\n</tr>\n</table>\n<h1>PL/SQL - DBMS Output</h1>\n<p>In this chapter, we will discuss the DBMS Output in PL/SQL. The <b>DBMS_OUTPUT</b> is a built-in package that enables you to display output, debugging information, and send messages from PL/SQL blocks, subprograms, packages, and triggers. We have already used this package throughout our tutorial.</p>\n<p>Let us look at a small code snippet that will display all the user tables in the database. Try it in your database to list down all the table names \u2212</p>\n<pre class=\"prettyprint notranslate\">\nBEGIN \n   dbms_output.put_line  (user || ' Tables in the database:'); \n   FOR t IN (SELECT table_name FROM user_tables) \n   LOOP \n      dbms_output.put_line(t.table_name); \n   END LOOP; \nEND; \n/ \n</pre>\n<h2>DBMS_OUTPUT Subprograms</h2>\n<p>The DBMS_OUTPUT package has the following subprograms \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"text-align:center;\">S.No</th>\n<th style=\"text-align:center;\">Subprogram &amp; Purpose</th>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">1</td>\n<td><p><b>DBMS_OUTPUT.DISABLE;</b></p>\n<p>Disables message output.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">2</td>\n<td><p><b>DBMS_OUTPUT.ENABLE(buffer_size IN INTEGER DEFAULT 20000);</b></p>\n<p>Enables message output. A NULL value of <b>buffer_size</b> represents unlimited buffer size.</p>\n</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">3</td>\n<td><p><b>DBMS_OUTPUT.GET_LINE (line OUT VARCHAR2, status OUT INTEGER);</b></p>\n<p>Retrieves a single line of buffered information.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">4</td>\n<td><p><b>DBMS_OUTPUT.GET_LINES (lines OUT CHARARR, numlines IN OUT INTEGER);</b></p>\n<p>Retrieves an array of lines from the buffer.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">5</td>\n<td><p><b>DBMS_OUTPUT.NEW_LINE;</b></p>\n<p>Puts an end-of-line marker.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">6</td>\n<td><p><b>DBMS_OUTPUT.PUT(item IN VARCHAR2);</b></p>\n<p>Places a partial line in the buffer.</p>\n</td>\n</tr>\n<tr>\n<td style=\"text-align:center; vertical-align:middle;\">7</td>\n<td><p><b>DBMS_OUTPUT.PUT_LINE(item IN VARCHAR2);</b></p>\n<p>Places a line in the buffer.</p>\n</td>\n</tr>\n</table>\n<h3>Example</h3>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   lines dbms_output.chararr; \n   num_lines number; \nBEGIN \n   -- enable the buffer with default size 20000 \n   dbms_output.enable; \n   \n   dbms_output.put_line('Hello Reader!'); \n   dbms_output.put_line('Hope you have enjoyed the tutorials!'); \n   dbms_output.put_line('Have a great time exploring pl/sql!'); \n  \n   num_lines := 3; \n  \n   dbms_output.get_lines(lines, num_lines); \n  \n   FOR i IN 1..num_lines LOOP \n      dbms_output.put_line(lines(i)); \n   END LOOP; \nEND; \n/  \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nHello Reader! \nHope you have enjoyed the tutorials! \nHave a great time exploring pl/sql!  \n\nPL/SQL procedure successfully completed.\n</pre>\n<h1>PL/SQL - Object Oriented</h1>\n<p>In this chapter, we will discuss Object-Oriented PL/SQL. PL/SQL allows defining an object type, which helps in designing object-oriented database in Oracle. An object type allows you to create composite types. Using objects allow you to implement real world objects with specific structure of data and methods for operating it. Objects have attributes and methods. Attributes are properties of an object and are used for storing an object's state; and methods are used for modeling its behavior.</p>\n<p>Objects are created using the CREATE [OR REPLACE] TYPE statement. Following is an example to create a simple <b>address</b> object consisting of few attributes \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE address AS OBJECT \n(house_no varchar2(10), \n street varchar2(30), \n city varchar2(20), \n state varchar2(10), \n pincode varchar2(10) \n); \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType created. \n</pre>\n<p>Let's create one more object <b>customer</b> where we will wrap <b>attributes</b> and <b>methods</b> together to have object-oriented feeling \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE customer AS OBJECT \n(code number(5), \n name varchar2(30), \n contact_no varchar2(12), \n addr address, \n member procedure display \n); \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType created.\n</pre>\n<h2>Instantiating an Object</h2>\n<p>Defining an object type provides a blueprint for the object. To use this object, you need to create instances of this object. You can access the attributes and methods of the object using the instance name and <b>the access operator (.)</b> as follows \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   residence address; \nBEGIN \n   residence := address('103A', 'M.G.Road', 'Jaipur', 'Rajasthan','201301'); \n   dbms_output.put_line('House No: '|| residence.house_no); \n   dbms_output.put_line('Street: '|| residence.street); \n   dbms_output.put_line('City: '|| residence.city); \n   dbms_output.put_line('State: '|| residence.state); \n   dbms_output.put_line('Pincode: '|| residence.pincode); \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nHouse No: 103A \nStreet: M.G.Road \nCity: Jaipur \nState: Rajasthan \nPincode: 201301  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>Member Methods</h2>\n<p><b>Member methods</b> are used for manipulating the <b>attributes</b> of the object. You provide the declaration of a member method while declaring the object type. The object body defines the code for the member methods. The object body is created using the CREATE TYPE BODY statement.</p>\n<p><b>Constructors</b> are functions that return a new object as its value. Every object has a system defined constructor method. The name of the constructor is same as the object type. For example \u2212</p>\n<pre class=\"prettyprint notranslate\">\nresidence := address('103A', 'M.G.Road', 'Jaipur', 'Rajasthan','201301'); \n</pre>\n<p>The <b>comparison methods</b> are used for comparing objects. There are two ways to compare objects \u2212</p>\n<h3>Map method</h3>\n<p>The <b>Map method</b> is a function implemented in such a way that its value depends upon the value of the attributes. For example, for a customer object, if the customer code is same for two customers, both customers could be the same. So the relationship between these two objects would depend upon the value of code.</p>\n<h3>Order method</h3>\n<p>The <b>Order method</b> implements some internal logic for comparing two objects. For example, for a rectangle object, a rectangle is bigger than another rectangle if both its sides are bigger.</p>\n<h2>Using Map method</h2>\n<p>Let us try to understand the above concepts using the following rectangle object \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE rectangle AS OBJECT \n(length number, \n width number, \n member function enlarge( inc number) return rectangle, \n member procedure display, \n map member function measure return number \n); \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType created.\n</pre>\n<p>Creating the type body \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE BODY rectangle AS \n   MEMBER FUNCTION enlarge(inc number) return rectangle IS \n   BEGIN \n      return rectangle(self.length + inc, self.width + inc); \n   END enlarge;  \n   MEMBER PROCEDURE display IS \n   BEGIN  \n      dbms_output.put_line('Length: '|| length); \n      dbms_output.put_line('Width: '|| width); \n   END display;  \n   MAP MEMBER FUNCTION measure return number IS \n   BEGIN \n      return (sqrt(length*length + width*width)); \n   END measure; \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType body created.\n</pre>\n<p>Now using the rectangle object and its member functions \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   r1 rectangle; \n   r2 rectangle; \n   r3 rectangle; \n   inc_factor number := 5; \nBEGIN \n   r1 := rectangle(3, 4); \n   r2 := rectangle(5, 7); \n   r3 := r1.enlarge(inc_factor); \n   r3.display;  \n   IF (r1 &gt; r2) THEN -- calling measure function \n      r1.display; \n   ELSE \n      r2.display; \n   END IF; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nLength: 8 \nWidth: 9 \nLength: 5 \nWidth: 7  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>Using Order method</h2>\n<p>Now, the <b>same effect could be achieved using an order method</b>. Let us recreate the rectangle object using an order method \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE rectangle AS OBJECT \n(length number, \n width number, \n member procedure display, \n order member function measure(r rectangle) return number \n); \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType created.\n</pre>\n<p>Creating the type body \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE BODY rectangle AS \n   MEMBER PROCEDURE display IS \n   BEGIN \n      dbms_output.put_line('Length: '|| length); \n      dbms_output.put_line('Width: '|| width); \n   END display;  \n   ORDER MEMBER FUNCTION measure(r rectangle) return number IS \n   BEGIN \n      IF(sqrt(self.length*self.length + self.width*self.width)&gt; \n         sqrt(r.length*r.length + r.width*r.width)) then \n         return(1); \n      ELSE \n         return(-1); \n      END IF; \n   END measure; \nEND; \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType body created.\n</pre>\n<p>Using the rectangle object and its member functions \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   r1 rectangle; \n   r2 rectangle; \nBEGIN \n   r1 := rectangle(23, 44); \n   r2 := rectangle(15, 17); \n   r1.display; \n   r2.display; \n   IF (r1 &gt; r2) THEN -- calling measure function \n      r1.display; \n   ELSE \n      r2.display; \n   END IF; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"prettyprint notranslate\">\nLength: 23 \nWidth: 44 \nLength: 15 \nWidth: 17 \nLength: 23 \nWidth: 44 \n\nPL/SQL procedure successfully completed.\n</pre>\n<h2>Inheritance for PL/SQL Objects</h2>\n<p>PL/SQL allows creating object from the existing base objects. To implement inheritance, the base objects should be declared as <b>NOT FINAL</b>. The default is <b>FINAL</b>.</p>\n<p>The following programs illustrate the inheritance in PL/SQL Objects. Let us create another object named <b>TableTop</b>, this is inherited from the Rectangle object. For this, we need to create the base <i>rectangle</i> object \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE rectangle AS OBJECT \n(length number, \n width number, \n member function enlarge( inc number) return rectangle, \n NOT FINAL member procedure display) NOT FINAL \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType created.\n</pre>\n<p>Creating the base type body \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE BODY rectangle AS \n   MEMBER FUNCTION enlarge(inc number) return rectangle IS \n   BEGIN \n      return rectangle(self.length + inc, self.width + inc); \n   END enlarge;  \n   MEMBER PROCEDURE display IS \n   BEGIN \n      dbms_output.put_line('Length: '|| length); \n      dbms_output.put_line('Width: '|| width); \n   END display; \nEND; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType body created.\n</pre>\n<p>Creating the child object <i>tabletop</i> \u2212</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE tabletop UNDER rectangle \n(   \n   material varchar2(20), \n   OVERRIDING member procedure display \n) \n/ \n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType created.\n</pre>\n<p>Creating the type body for the child object <i>tabletop</i></p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE BODY tabletop AS \nOVERRIDING MEMBER PROCEDURE display IS \nBEGIN \n   dbms_output.put_line('Length: '|| length); \n   dbms_output.put_line('Width: '|| width); \n   dbms_output.put_line('Material: '|| material); \nEND display; \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType body created.\n</pre>\n<p>Using the <i>tabletop</i> object and its member functions \u2212</p>\n<pre class=\"prettyprint notranslate\">\nDECLARE \n   t1 tabletop; \n   t2 tabletop; \nBEGIN \n   t1:= tabletop(20, 10, 'Wood'); \n   t2 := tabletop(50, 30, 'Steel'); \n   t1.display; \n   t2.display; \nEND;\n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nLength: 20 \nWidth: 10 \nMaterial: Wood \nLength: 50 \nWidth: 30 \nMaterial: Steel  \n\nPL/SQL procedure successfully completed. \n</pre>\n<h2>Abstract Objects in PL/SQL</h2>\n<p>The <b>NOT INSTANTIABLE</b> clause allows you to declare an abstract object. You cannot use an abstract object as it is; you will have to create a subtype or child type of such objects to use its functionalities.</p>\n<p>For example,</p>\n<pre class=\"prettyprint notranslate\">\nCREATE OR REPLACE TYPE rectangle AS OBJECT \n(length number, \n width number, \n NOT INSTANTIABLE NOT FINAL MEMBER PROCEDURE display)  \n NOT INSTANTIABLE NOT FINAL \n/\n</pre>\n<p>When the above code is executed at the SQL prompt, it produces the following result \u2212</p>\n<pre class=\"result notranslate\">\nType created.\n</pre>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/plsql/plsql_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"print-btn center\">\n<a href=\"/cgi-bin/printpage.cgi\" target=\"_blank\"><i class=\"icon icon-print big-font\"></i> Print</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/plsql/plsql_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<hr/>\n<!-- PRINTING ENDS HERE -->\n<div class=\"bottomgooglead\">\n<div class=\"bottomadtag\">Advertisements</div>\n<script><!--\nvar width = 580;\nvar height = 400;\nvar format = \"580x400_as\";\nif( window.innerWidth < 468 ){\n   width = 300;\n   height = 250;\n   format = \"300x250_as\";\n}\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = width;\ngoogle_ad_height = height;\ngoogle_ad_format = format;\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n</p></p>\n\n<div class=\"row\">\n<div class=\"col-md-3\" id=\"rightbar\">\n<div class=\"simple-ad\">\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'https://www.tutorialspoint.com/plsql/plsql_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/facebookIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'https://www.tutorialspoint.com/plsql/plsql_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/twitterIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'https://www.tutorialspoint.com/plsql/plsql_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/linkedinIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=https://www.tutorialspoint.com/plsql/plsql_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/googlePlusIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=https://www.tutorialspoint.com/plsql/plsql_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/StumbleUponIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=https://www.tutorialspoint.com/plsql/plsql_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/reddit.jpg\"/>\n</a>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 250;\ngoogle_ad_format = \"300x250_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 600;\ngoogle_ad_format = \"300x600_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"ca-pub-2537027957187252\";\n/* Right Side Ad */\ngoogle_ad_slot = \"right_side_ad\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 250;\n//-->\n</script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n</div>\n</div>\n\n\n\n<div class=\"footer-copyright\">\n<div class=\"container\">\n<div class=\"row\">\n<div class=\"col-md-1\">\n<a class=\"logo\" href=\"index.htm\"> <img alt=\"Tutorials Point\" class=\"img-responsive\" src=\"/scripts/img/logo-footer.png\"/> </a>\n</div>\n<div class=\"col-md-4 col-sm-12 col-xs-12\">\n<nav id=\"sub-menu\">\n<ul>\n<li><a href=\"/about/about_privacy.htm\">Privacy Policy</a></li>\n<li><a href=\"/about/about_cookies.htm\">Cookies Policy</a></li>\n<li><a href=\"/about/contact_us.htm\">Contact</a></li>\n</ul>\n</nav>\n</div>\n<div class=\"col-md-3 col-sm-12 col-xs-12\">\n<p>\u00a9 Copyright 2019. All Rights Reserved.</p>\n</div>\n<div class=\"col-md-4 col-sm-12 col-xs-12\">\n<div class=\"news-group\">\n<input autocomplete=\"off\" class=\"form-control-foot search\" id=\"textemail\" name=\"textemail\" onblur=\"if (this.value == '') {this.value = 'Enter email for newsletter...';}\" onfocus=\"if (this.value == 'Enter email for newsletter...') {this.value = '';}\" placeholder=\"Enter email for newsletter\" type=\"text\"/>\n<span class=\"input-group-btn\"> <button class=\"btn btn-default btn-footer\" id=\"btnemail\" onclick=\"javascript:void(0);\" type=\"submit\">go</button> </span>\n<div id=\"newsresponse\"></div>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div id=\"privacy-banner\">\n<div>\n<p>\n      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.\n      <a href=\"javascript:void(0)\" id=\"banner-accept\">Accept</a>\n<a href=\"/about/about_cookies.htm\" id=\"banner-learn\" target=\"_blank\">Learn more</a>\n</p>\n</div>\n</div>\n<script>\n// Banner Trigger if Not Closed\nif (!localStorage.bannerClosed) {\n  document.getElementById('privacy-banner').style.display = \"inherit\";\n} else {\n  document.getElementById('privacy-banner').style.display = \"none\";\n}\ndocument.getElementById('banner-accept').addEventListener('click', function() {\n  document.getElementById('privacy-banner').style.display = \"none\";\n  localStorage.bannerClosed = 'true';\n});\nif (navigator.userAgent.match(/Opera|OPR\\//)) {\n  document.getElementById('privacy-banner').style.display = \"inherit\";\n}\n</script>\n<!-- Libs -->\n<script src=\"/theme/js/custom-min.js?v=7\"></script>\n<script src=\"https://www.google-analytics.com/urchin.js\">\n</script>\n<script>\n_uacct = \"UA-232293-6\";\nurchinTracker();\n$('.pg-icon').click(function(){\n   $('.wrapLoader').show();\n});\n</script>\n\n\n\n", "url": "https://www.tutorialspoint.com/plsql/plsql_quick_guide.htm", "title_html": "<h1>PL/SQL - Quick Guide</h1>"}