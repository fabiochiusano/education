{"content": "\n Operating System - Quick Guide \n  \n Advertisements \n \n<!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//-->\n\n\n \n  \n \n Previous Page\n \n \nNext Page \u00a0\n \n  \n  \n Operating System - Overview \n An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers. \n Some popular Operating Systems include Linux Operating System, Windows Operating System, VMS, OS/400, AIX, z/OS, etc. \n Definition \n An operating system is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs. \n  \n Following are some of important functions of an operating System. \n \nMemory Management\nProcessor Management\nDevice Management\nFile Management\nSecurity\nControl over system performance\nJob accounting\nError detecting aids\nCoordination between other software and users\n \n Memory Management \n Memory management refers to management of Primary Memory or Main Memory. Main memory is a large array of words or bytes where each word or byte has its own address. \n Main memory provides a fast storage that can be accessed directly by the CPU. For a program to be executed, it must in the main memory. An Operating System does the following activities for memory management \u2212 \n \nKeeps tracks of primary memory, i.e., what part of it are in use by whom, what part are not in use.\nIn multiprogramming, the OS decides which process will get memory when and how much.\nAllocates the memory when a process requests it to do so.\nDe-allocates the memory when a process no longer needs it or has been terminated.\n \n Processor Management \n In multiprogramming environment, the OS decides which process gets the processor when and for how much time. This function is called process  scheduling. An Operating System does the following activities for processor management \u2212 \n \nKeeps tracks of processor and status of process. The program responsible for this task is known as traffic controller.\nAllocates the processor (CPU) to a process.\nDe-allocates processor when a process is no longer required.\n \n Device Management \n An Operating System manages device communication via their respective drivers. It does the following activities for device management \u2212 \n \nKeeps tracks of all devices. Program responsible for this task is known as the I/O controller.\nDecides which process gets the device when and for how much time.\nAllocates the device in the efficient way.\nDe-allocates devices.\n \n File Management \n A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. \n An Operating System does the following activities for file management \u2212 \n \nKeeps track of information, location, uses, status etc. The collective facilities are often known as file system.\nDecides who gets the resources.\nAllocates the resources.\nDe-allocates the resources.\n \n Other Important Activities \n Following are some of the important activities that an Operating System performs \u2212 \n \nSecurity \u2212  By means of password and similar other techniques, it prevents unauthorized access to programs and data.\nControl over system performance \u2212 Recording delays between request for a service and response from the system.\nJob accounting \u2212 Keeping track of time and resources used by various jobs and users.\nError detecting aids \u2212 Production of dumps, traces, error messages, and other debugging and error detecting aids.\nCoordination between other softwares and users \u2212 Coordination and assignment of compilers, interpreters, assemblers and other software to the various users of the computer systems.\n \n Types of Operating System \n Operating systems are there from the very first computer generation and they keep evolving with time. In this chapter, we will discuss some of the important types of operating systems which are most commonly used. \n Batch operating system \n The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator. To speed up processing, jobs with similar needs are batched together and run as a group. The programmers leave their programs with the operator and the operator then sorts the programs with similar requirements into batches. \n The problems with Batch Systems are as follows \u2212 \n \nLack of interaction between the user and the job.\nCPU is often idle, because the speed of the mechanical I/O devices is slower than the CPU.\nDifficult to provide the desired priority.\n \n Time-sharing operating systems \n Time-sharing is a technique which enables many people, located at various terminals, to use a particular computer system at the same time. Time-sharing or multitasking is a logical extension of multiprogramming. Processor's time which is shared among multiple users simultaneously is termed as time-sharing. \n The main difference between Multiprogrammed Batch Systems and Time-Sharing Systems is that in case of Multiprogrammed batch systems, the objective is to maximize processor use, whereas in Time-Sharing Systems, the objective is to minimize response time. \n Multiple jobs are executed by the CPU by switching between them, but the switches occur so frequently. Thus, the user can receive an immediate response. For example, in a transaction processing, the processor executes each user program in a short burst or quantum of computation. That is, if n users are present, then each user can get a time quantum. When the user submits the command, the response time is in few seconds at most. \n The operating system uses CPU scheduling and multiprogramming to provide each user with a small portion of a time. Computer systems that were designed primarily as batch systems have been modified to time-sharing systems. \n Advantages of Timesharing operating systems are as follows \u2212 \n \nProvides the advantage of quick response.\nAvoids duplication of software.\nReduces CPU idle time.\n \n Disadvantages of Time-sharing operating systems are as follows \u2212 \n \nProblem of reliability.\nQuestion of security and integrity of user programs and data.\nProblem of data communication.\n \n Distributed operating System \n Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly. \n The processors communicate with one another through various communication lines (such as high-speed buses or telephone lines). These are referred as loosely coupled systems or distributed systems. Processors in a distributed system may vary in size and function. These processors are referred as sites, nodes, computers, and so on. \n The advantages of distributed systems are as follows \u2212 \n \nWith resource sharing facility, a user at one site may be able to use the resources available at another.\nSpeedup the exchange of data with one another via electronic mail.\nIf one site fails in a distributed system, the remaining sites can potentially continue operating.\nBetter service to the customers.\nReduction of the load on the host computer.\nReduction of delays in data processing.\n \n Network operating System \n A Network Operating System runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a local area network (LAN), a private network or to other networks. \n Examples of network operating systems include Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD. \n The advantages of network operating systems are as follows \u2212 \n \nCentralized servers are highly stable.\nSecurity is server managed.\nUpgrades to new technologies and hardware can be easily integrated into the system.\nRemote access to servers is possible from different locations and types of systems.\n \n The disadvantages of network operating systems are as follows \u2212 \n \nHigh cost of buying and running a server.\nDependency on a central location for most operations.\nRegular maintenance and updates are required.\n \n Real Time operating System \n A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment. The time taken by the system to respond to an input and display of required updated information is termed as the response time. So in this method, the response time is very less as compared to online processing. \n Real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application. A real-time operating system must have well-defined, fixed time constraints, otherwise the system will fail. For example, Scientific experiments, medical imaging systems, industrial control systems, weapon systems, robots, air traffic control systems, etc. \n There are two types of real-time operating systems. \n Hard real-time systems \n Hard real-time systems guarantee that critical tasks complete on time. In hard real-time systems, secondary storage is limited or missing and the data is stored in ROM. In these systems, virtual memory is almost never found. \n Soft real-time systems \n Soft real-time systems are less restrictive. A critical real-time task gets priority over other tasks and retains the priority until it completes. Soft real-time systems have limited utility than hard real-time systems. For example, multimedia, virtual reality, Advanced Scientific Projects like undersea exploration and planetary rovers, etc. \n Operating System - Services \n An Operating System provides services to both the users and to the programs. \n \nIt provides programs an environment to execute.\nIt provides users the services to execute the programs in a convenient manner.\n \n Following are a few common services provided by an operating system \u2212 \n \nProgram execution\nI/O operations\nFile System manipulation\nCommunication\nError Detection\nResource Allocation\nProtection\n \n Program execution \n Operating systems handle many kinds of activities from user programs to system programs like printer spooler, name servers, file server, etc. Each of these activities is encapsulated as a process. \n A process includes the complete execution context (code to execute, data to manipulate, registers, OS resources in use). Following are the major activities of an operating system with respect to program management \u2212 \n \nLoads a program into memory.\nExecutes the program.\nHandles program's execution.\nProvides a mechanism for process synchronization.\nProvides a mechanism for process communication.\nProvides a mechanism for deadlock handling.\n \n I/O Operation \n An I/O subsystem comprises of I/O devices and their corresponding driver software. Drivers hide the peculiarities of specific hardware devices from the users. \n An Operating System manages the communication between user and device drivers. \n \nI/O operation means read or write operation with any file or any specific I/O device.\nOperating system provides the access to the required I/O device when required.\n \n File system manipulation \n A file represents a collection of related information. Computers can store files on the disk (secondary storage), for long-term storage purpose. Examples of storage media include magnetic tape, magnetic disk and optical disk drives like CD, DVD. Each of these media has its own properties like speed, capacity, data transfer rate and data access methods. \n A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. Following are the major activities of an operating system with respect to file management \u2212 \n \nProgram needs to read a file or write a file.\nThe operating system gives the permission to the program for operation on file.\nPermission varies from read-only, read-write, denied and so on.\nOperating System provides an interface to the user to create/delete files.\nOperating System provides an interface to the user to create/delete directories.\nOperating System provides an interface to create the backup of file system.\n \n Communication \n In case of distributed systems which are a collection of processors that do not share memory, peripheral devices, or a clock, the operating system manages communications between all the processes. Multiple processes communicate with one another through communication lines in the network. \n The OS handles routing and connection strategies, and the problems of contention and security. Following are the major activities of an operating system with respect to communication \u2212 \n \nTwo processes often require data to be transferred between them\nBoth the processes can be on one computer or on different computers, but are connected through a computer network.\nCommunication may be implemented by two methods, either by Shared Memory or by Message Passing.\n \n Error handling \n Errors can occur anytime and anywhere. An error may occur in CPU, in I/O devices or in the memory hardware. Following are the major activities of an operating system with respect to error handling \u2212 \n \nThe OS constantly checks for possible errors.\nThe OS takes an appropriate action to ensure correct and consistent computing.\n \n Resource Management \n In case of multi-user or multi-tasking environment, resources such as main memory, CPU cycles and files storage are to be allocated to each user or job. Following are the major activities of an operating system with respect to resource management \u2212 \n \nThe OS manages all kinds of resources using schedulers.\nCPU scheduling algorithms are used for better utilization of CPU.\n \n Protection \n Considering a computer system having multiple users and concurrent execution of multiple processes, the various processes must be protected from each other's activities. \n Protection refers to a mechanism or a way to control the access of programs, processes, or users to the resources defined by a computer system. Following are the major activities of an operating system with respect to protection \u2212 \n \nThe OS ensures that all access to system resources is controlled.\nThe OS ensures that external I/O devices are protected from invalid access attempts.\nThe OS provides authentication features for each user by means of passwords.\n \n Operating System - Properties \n Batch processing \n Batch processing is a technique in which an Operating System collects the programs and data together in a batch before processing starts. An operating system does the following activities related to batch processing \u2212 \n \nThe OS defines a job which has predefined sequence of commands, programs and data as a single unit.\nThe OS keeps a number a jobs in memory and executes them without any manual information.\nJobs are processed in the order of submission, i.e., first come first served fashion.\nWhen a job completes its execution, its memory is released and the output for the job gets copied into an output spool for later printing or processing.\n \n  \n Advantages \n \nBatch processing takes much of the work of the operator to the computer.\nIncreased performance as a new job get started as soon as the previous job is finished, without any manual intervention.\n \n Disadvantages \n \nDifficult to debug program.\nA job could enter an infinite loop.\nDue to lack of protection scheme, one batch job can affect pending jobs.\n \n Multitasking \n Multitasking is when multiple jobs are executed by the CPU simultaneously by switching between them. Switches occur so frequently that the users may interact with each program while it is running. An OS does the following activities related to multitasking \u2212 \n \nThe user gives instructions to the operating system or to a program directly, and receives an immediate response.\nThe OS handles multitasking in the way that it can handle multiple operations/executes multiple programs at a time.\nMultitasking Operating Systems are also known as Time-sharing systems.\nThese Operating Systems were developed to provide interactive use of a computer system at a reasonable cost.\nA time-shared operating system uses the concept of CPU scheduling and multiprogramming to provide each user with a small portion of a time-shared CPU.\nEach user has at least one separate program in memory.\n \n  \n \nA program that is loaded into memory and is executing is commonly referred to as a process.\nWhen a process executes, it typically executes for only a very short time before it either finishes or needs to perform I/O.\nSince interactive I/O typically runs at slower speeds, it may take a long time to complete. During this time, a CPU can be utilized by another process.\nThe operating system allows the users to share the computer simultaneously. Since each action or command in a time-shared system tends to be short, only a little CPU time is needed for each user.\nAs the system switches CPU rapidly from one user/program to the next, each user is given the impression that he/she has his/her own CPU, whereas actually one CPU is being shared among many users.\n \n Multiprogramming \n Sharing the processor, when two or more programs reside in memory at the same time, is referred as  multiprogramming. Multiprogramming assumes a single shared processor. Multiprogramming increases CPU utilization by organizing jobs so that the CPU always has one to execute. \n The following figure shows the memory layout for a multiprogramming system. \n  \n An OS does the following activities related to multiprogramming. \n \nThe operating system keeps several jobs in memory at a time.\nThis set of jobs is a subset of the jobs kept in the job pool.\nThe operating system picks and begins to execute one of the jobs in the memory.\nMultiprogramming operating systems monitor the state of all active programs and system resources using memory management programs to ensures that the CPU is never idle, unless there are no jobs to process.\n \n Advantages \n \nHigh and efficient CPU utilization.\nUser feels that many programs are allotted CPU almost simultaneously.\n \n Disadvantages \n \nCPU scheduling is required.\nTo accommodate many jobs in memory, memory management is required.\n \n Interactivity \n Interactivity refers to the ability of users to interact with a computer system. An Operating system does the following activities related to interactivity \u2212 \n \nProvides the user an interface to interact with the system.\nManages input devices to take inputs from the user. For example, keyboard.\nManages output devices to show outputs to the user. For example, Monitor.\n \n The response time of the OS needs to be short, since the user submits and waits for the result. \n Real Time System \n Real-time systems are usually dedicated, embedded systems. An operating system does the following activities related to real-time system activity. \n \nIn such systems, Operating Systems typically read from and react to sensor data.\nThe Operating system must guarantee response to events within fixed periods of time to ensure correct performance.\n \n Distributed Environment  \n A distributed environment refers to multiple independent CPUs or processors in a computer system. An operating system does the following activities related to distributed environment \u2212 \n \nThe OS distributes computation logics among several physical processors.\nThe processors do not share memory or a clock. Instead, each processor has its own local memory.\nThe OS manages the communications between the processors. They communicate with each other through various communication lines.\n \n Spooling \n Spooling is an acronym for simultaneous peripheral operations on line. Spooling refers to putting data of various I/O jobs in a buffer. This buffer is a special area in memory or hard disk which is accessible to I/O devices. \n An operating system does the following activities related to distributed environment \u2212 \n \nHandles I/O device data spooling as devices have different data access rates.\nMaintains the spooling buffer which provides a waiting station where data can rest while the slower device catches up.\nMaintains parallel computation because of spooling process as a computer can perform I/O in parallel fashion. It becomes possible to have the computer read data from a tape, write data to disk and to write out to a tape printer while it is doing its computing task.\n \n  \n Advantages \n \nThe spooling operation uses a disk as a very large buffer.\nSpooling is capable of overlapping I/O operation for one job with processor operations for another job.\n \n Operating System - Processes \n Process \n A process is basically a program in execution. The execution of a process must progress in a sequential fashion. \n A process is defined as an entity which represents the basic unit of work to be implemented in the system. \n To put it in simple terms, we write our computer programs in a text file and when we execute this program, it becomes a process which performs all the tasks mentioned in the program. \n When a program is loaded into the memory and it becomes a process, it can be divided into four sections \u2500 stack, heap, text and data. The following image shows a simplified layout of a process inside main memory \u2212 \n  \n \n\nS.N.\nComponent & Description\n\n\n1\nStack\nThe process Stack contains the temporary data such as method/function parameters, return address and local variables.\n\n\n\n2\nHeap\nThis is dynamically allocated memory to a process during its run time.\n\n\n\n3\nText\nThis includes the current activity represented by the value of Program Counter and the contents of the processor's registers.\n\n\n\n4\nData\nThis section contains the global and static variables.\n\n\n \n Program \n A program is a piece of code which may be a single line or millions of lines. A computer program is usually written by a computer programmer in a programming language. For example, here is a simple program written in C programming language \u2212 \n \n#include <stdio.h>\n\nint main() {\n   printf(\"Hello, World! \\n\");\n   return 0;\n}\n \n A computer program is a collection of instructions that performs a specific task when executed by a computer. When we compare a program with a process, we can conclude that a process is a dynamic instance of a computer program. \n A part of a computer program that performs a well-defined task is known as an algorithm. A collection of computer programs, libraries and related data are referred to as a software. \n Process Life Cycle \n  When a process executes, it passes through different states. These stages may differ in different operating systems, and the names of these states are also not standardized. \n In general, a process can have one of the following five states at a time. \n \n\nS.N.\nState & Description\n\n\n1\n\nStart\nThis is the initial state when a process is first started/created.\n\n\n\n2\n\nReady\nThe process is waiting to be assigned to a processor. Ready processes are waiting to have the processor allocated to them by the operating system so that they can run. Process may come into this state after Start state or while running it by but interrupted by the scheduler to assign CPU to some other process.\n\n\n\n3\nRunning\nOnce the process has been assigned to a processor by the OS scheduler, the process state is set to running and the processor executes its instructions.\n\n\n4\nWaiting\nProcess moves into the waiting state if it needs to wait for a resource, such as waiting for user input, or waiting for a file to become available.\n\n\n5\nTerminated or Exit\nOnce the process finishes its execution, or it is terminated by the operating system, it is moved to the terminated state where it waits to be removed from main memory.\n\n \n  \n Process Control Block (PCB) \n A Process Control Block is a data structure maintained by the Operating System for every process. The PCB is identified by an integer process ID (PID). A PCB keeps all the information needed to keep track of a process as listed below in the table \u2212 \n \n\nS.N.\nInformation & Description\n\n\n1\nProcess State\nThe current state of the process i.e., whether it is ready, running, waiting, or whatever.\n\n\n\n2\nProcess privileges\nThis is required to allow/disallow access to system resources.\n\n\n3\nProcess ID\nUnique identification for each of the process in the operating system.\n\n\n4\nPointer\nA pointer to parent process.\n\n\n5\nProgram Counter\nProgram Counter is a pointer to the address of the next instruction to be executed for this process.\n\n\n6\nCPU registers\nVarious CPU registers where process need to be stored for execution for running state.\n\n\n7\nCPU Scheduling Information\nProcess priority and other scheduling information  which is required to schedule the process.\n\n\n8\nMemory management information\nThis includes the information of page table, memory limits, Segment table depending on memory used by the operating system.\n\n\n9\nAccounting information\nThis  includes the amount of CPU used for process execution, time limits, execution ID etc.\n\n\n10\nIO status information\nThis includes a list of I/O devices allocated to the process.\n\n \n The architecture of a PCB is completely dependent on Operating System and may contain different information in different operating systems. Here is a simplified diagram of a PCB \u2212 \n  \n The PCB is maintained for a process throughout its lifetime, and is deleted once the process terminates. \n Operating System - Process Scheduling \n Definition \n The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy. \n Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing. \n Process Scheduling Queues \n The OS maintains all PCBs in Process Scheduling Queues. The OS maintains a separate queue for each of the process states and PCBs of all processes in the same execution state are placed in the same queue. When the state of a process is changed, its PCB is unlinked from its current queue and moved to its new state queue. \n The Operating System maintains the following important process scheduling queues \u2212 \n \nJob queue \u2212 This queue keeps all the processes in the system.\nReady queue \u2212 This queue keeps a set of all processes residing in main memory, ready and waiting to execute. A new process is always put in this queue.\nDevice queues \u2212 The processes which are blocked due to unavailability of an I/O device constitute this queue.\n \n  \n The OS can use different policies to manage each queue (FIFO, Round Robin, Priority, etc.). The OS scheduler determines how to move processes between the ready and run queues which can only have one entry per processor core on the system; in the above diagram, it has been merged with the CPU. \n Two-State Process Model \n Two-state process model refers to running and non-running states which are described below \u2212 \n \n\nS.N.\nState & Description\n\n\n1\nRunning\nWhen a new process is created, it enters into the system as in the running state.\n\n\n\n2\nNot Running\nProcesses that are not running are kept in queue, waiting for their turn to execute. Each entry in the queue is a pointer to a particular process. Queue is implemented by using linked list. Use of dispatcher is as follows. When a process is interrupted, that process is transferred in the waiting queue. If the process has completed or aborted, the process is discarded. In either case, the dispatcher then selects a process from the queue to execute.\n\n\n \n Schedulers \n Schedulers are special system software which handle process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run. Schedulers are of three types \u2212 \n \nLong-Term Scheduler\nShort-Term Scheduler\nMedium-Term Scheduler\n \n Long Term Scheduler \n It is also called a job scheduler. A long-term scheduler determines which programs are admitted to the system for processing. It selects processes from the queue and loads them into memory for execution. Process loads into the memory for CPU scheduling. \n The primary objective of the job scheduler is to provide a balanced mix of jobs, such as I/O bound and processor bound. It also controls the degree of multiprogramming. If the degree of multiprogramming is stable, then the average rate of process creation must be equal to the average departure rate of processes leaving the system. \n On some systems, the long-term scheduler may not be available or minimal. Time-sharing operating systems have no long term scheduler. When a process changes the state from new to ready, then there is use of long-term scheduler. \n Short Term Scheduler \n It is also called as CPU scheduler. Its main objective is to increase system performance in accordance with the chosen set of criteria. It is the change of ready state to running state of the process. CPU scheduler selects a process among the processes that are ready to execute and allocates CPU to one of them. \n Short-term schedulers, also known as dispatchers, make the decision of which process to execute next. Short-term schedulers are faster than long-term schedulers. \n Medium Term Scheduler \n Medium-term scheduling is a part of swapping. It removes the processes from the memory. It reduces the degree of multiprogramming. The medium-term scheduler is in-charge of handling the swapped out-processes. \n A running process may become suspended if it makes an I/O request. A suspended processes cannot make any progress towards completion. In this condition, to remove the process from memory and make space for other processes, the suspended process is moved to the secondary storage. This process is called swapping, and the process is said to be swapped out or rolled out. Swapping may be necessary to improve the process mix. \n Comparison among Scheduler \n \n\nS.N.\nLong-Term Scheduler\nShort-Term Scheduler\nMedium-Term Scheduler\n\n\n1\nIt is a job scheduler\nIt is a CPU scheduler\nIt is a process swapping scheduler.\n\n\n2\nSpeed is lesser than short term scheduler\nSpeed is fastest among other two\nSpeed is in between both short and long term scheduler.\n\n\n3\nIt controls the degree of multiprogramming\nIt provides lesser control over degree of multiprogramming\nIt reduces the degree of multiprogramming.\n\n\n4\nIt is almost absent or minimal in time sharing system\nIt is also minimal in time sharing system\nIt is a part of Time sharing systems.\n\n\n5\nIt selects processes from pool and loads them into memory for execution\nIt selects those processes which are ready to execute\nIt can re-introduce the process into memory and execution can be continued.\n\n \n Context Switch \n A context switch is the mechanism to store and restore the state or context of a CPU in Process Control block so that a process execution can be resumed from the same point at a later time. Using this technique, a context switcher enables multiple processes to share a single CPU. Context switching is an essential part of a multitasking operating system features. \n When the scheduler switches the CPU from executing one process to execute another, the state from the current running process is stored into the process control block. After this, the state for the process to run next is loaded from its own PCB and used to set the PC, registers, etc. At that point, the second process can start executing. \n  \n Context switches are computationally intensive since register and memory state must be saved and restored. To avoid the amount of context switching time, some hardware systems employ two or more sets of processor registers. When the process is switched, the following information is stored for later use. \n \nProgram Counter\nScheduling information\nBase and limit register value\nCurrently used register\nChanged State\nI/O State information\nAccounting information\n \n Operating System Scheduling algorithms \n A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are six popular process scheduling algorithms which we are going to discuss in this chapter \u2212 \n \nFirst-Come, First-Served (FCFS) Scheduling\nShortest-Job-Next (SJN) Scheduling\nPriority Scheduling\nShortest Remaining Time\nRound Robin(RR) Scheduling\nMultiple-Level Queues Scheduling\n \n These algorithms are either non-preemptive or preemptive. Non-preemptive\nalgorithms are designed so that once a process enters the running state, it cannot be preempted until it completes its allotted time, whereas the preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state. \n First Come First Serve (FCFS) \n \nJobs are executed on first come, first serve basis.\nIt is a non-preemptive, pre-emptive scheduling algorithm.\nEasy to understand and implement.\nIts implementation is based on FIFO queue.\nPoor in performance as average wait time is high.\n \n  \n Wait time of each process is as follows \u2212 \n \n\nProcess\nWait Time : Service Time - Arrival Time\n\n\nP0\n0 - 0 = 0\n\n\nP1\n5 - 1 = 4\n\n\nP2\n8 - 2 = 6\n\n\nP3\n16 - 3 = 13\n\n \n Average Wait Time: (0+4+6+13) / 4 = 5.75 \n Shortest Job Next (SJN) \n \nThis is also known as shortest job first, or SJF\nThis is a non-preemptive, pre-emptive scheduling algorithm.\nBest approach to minimize waiting time.\nEasy to implement in Batch systems where required CPU time is known in advance.\nImpossible to implement in interactive systems where required CPU time is not known.\nThe processer should know in advance how much time process will take.\n \n  \n Wait time of each process is as follows \u2212 \n \n\nProcess\nWait Time : Service Time - Arrival Time\n\n\nP0\n3 - 0 = 3\n\n\nP1\n0 - 0 = 0\n\n\nP2\n16 - 2 = 14\n\n\nP3\n8 - 3 = 5\n\n \n Average Wait Time: (3+0+14+5) / 4 = 5.50 \n Priority Based Scheduling \n \nPriority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems.\nEach process is assigned a priority. Process with highest priority is to be executed first and so on.\nProcesses with same priority are executed on first come first served basis.\nPriority can be decided based on memory requirements, time requirements or any other resource requirement.\n \n  \n Wait time of each process is as follows \u2212 \n \n\nProcess\nWait Time : Service Time - Arrival Time\n\n\nP0\n9 - 0 = 9\n\n\nP1\n6 - 1 = 5\n\n\nP2\n14 - 2 = 12\n\n\nP3\n0 - 0 = 0\n\n \n Average Wait Time: (9+5+12+0) / 4 = 6.5 \n Shortest Remaining Time \n \nShortest remaining time (SRT) is the preemptive version of the SJN algorithm.\nThe processor is allocated to the job closest to completion but it can be preempted by a newer ready job with shorter time to completion.\nImpossible to implement in interactive systems where required CPU time is not known.\nIt is often used in batch environments where short jobs need to give preference.\n \n Round Robin Scheduling \n \nRound Robin is the preemptive process scheduling algorithm.\nEach process is provided a fix time to execute, it is called a quantum.\nOnce a process is executed for a given time period, it is preempted and other process executes for a given time period.\nContext switching is used to save states of preempted processes.\n \n  \n Wait time of each process is as follows \u2212 \n \n\nProcess\nWait Time : Service Time - Arrival Time\n\n\nP0\n(0 - 0) + (12 - 3) = 9\n\n\nP1\n(3 - 1) = 2\n\n\nP2\n(6 - 2) + (14 - 9) + (20 - 17) = 12\n\n\nP3\n(9 - 3) + (17 - 12) = 11\n\n \n Average Wait Time: (9+2+12+11) / 4 = 8.5 \n Multiple-Level Queues Scheduling \n Multiple-level queues are not an independent scheduling algorithm. They make use of other existing algorithms to group and schedule jobs with common characteristics. \n \nMultiple queues are maintained for processes with common characteristics.\nEach queue can have its own scheduling algorithms.\nPriorities are assigned to each queue.\n \n For example, CPU-bound jobs can be scheduled in one queue and all I/O-bound jobs in another queue. The Process Scheduler then alternately selects jobs from each queue and assigns them to the CPU based on the algorithm assigned to the queue. \n Operating System - Multi-Threading \n What is Thread? \n A thread is a flow of execution through the process code, with its own program counter that keeps track of which instruction to execute next, system registers which hold its current working variables, and a stack which contains the execution history. \n A thread shares with its peer threads few information like code segment, data segment and open files. When one thread alters a code segment memory item, all other threads see that. \n A thread is also called a lightweight process. Threads provide a way to improve application performance through parallelism. Threads represent a software approach to improving performance of operating system by reducing the overhead thread is equivalent to a classical process. \n Each thread belongs to exactly one process and no thread can exist outside a process. Each thread represents a separate flow of control. Threads have been successfully used in implementing network servers and web server. They also provide a suitable foundation for parallel execution of applications on shared memory multiprocessors. The following figure shows the working of a single-threaded and a multithreaded process. \n  \n Difference between Process and Thread \n \n\nS.N.\nProcess\nThread\n\n\n1\nProcess is heavy weight or resource intensive.\nThread is light weight, taking lesser resources than a process.\n\n\n2\nProcess switching needs interaction with operating system.\nThread switching does not need to interact with operating system.\n\n\n3\nIn multiple processing environments, each process executes the same code but has its own memory and file resources.\nAll threads can share same set of open files, child processes.\n\n\n4\nIf one process is blocked, then no other process can execute until the first process is unblocked.\nWhile one thread is blocked and waiting, a second thread in the same task can run.\n\n\n5\nMultiple processes without using threads use more resources.\nMultiple threaded processes use fewer resources.\n\n\n6\nIn multiple processes each process operates independently of the others.\nOne thread can read, write or change another thread's data.\n\n \n Advantages of Thread \n \nThreads minimize the context switching time.\nUse of threads provides concurrency within a process.\nEfficient communication.\nIt is more economical to create and context switch threads.\nThreads allow utilization of multiprocessor architectures to a greater scale and efficiency.\n \n Types of Thread \n Threads are implemented in following two ways \u2212 \n \nUser Level Threads \u2212 User managed threads.\nKernel Level Threads \u2212 Operating System managed threads acting on kernel, an operating system core.\n \n User Level Threads \n In this case, the thread management kernel is not aware of the existence of threads. The thread library contains code for creating and destroying threads, for passing message and data between threads, for scheduling thread execution and for saving and restoring thread contexts. The application starts with a single thread. \n  \n Advantages \n \nThread switching does not require Kernel mode privileges.\nUser level thread can run on any operating system.\nScheduling can be application specific in the user level thread.\nUser level threads are fast to create and manage.\n \n Disadvantages \n \nIn a typical operating system, most system calls are blocking.\nMultithreaded application cannot take advantage of multiprocessing.\n \n Kernel Level Threads \n In this case, thread management is done by the Kernel. There is no thread management code in the application area. Kernel threads are supported directly by the operating system. Any application can be programmed to be multithreaded. All of the threads within an application are supported within a single process. \n The Kernel maintains context information for the process as a whole and for individuals threads within the process. Scheduling by the Kernel is done on a thread basis. The Kernel performs thread creation, scheduling and management in Kernel space. Kernel threads are generally slower to create and manage than the user threads. \n Advantages \n \nKernel can simultaneously schedule multiple threads from the same process on multiple processes.\nIf one thread in a process is blocked, the Kernel can schedule another thread of the same process.\nKernel routines themselves can be multithreaded.\n \n Disadvantages \n \nKernel threads are generally slower to create and manage than the user threads.\nTransfer of control from one thread to another within the same process requires a mode switch to the Kernel.\n \n Multithreading Models \n Some operating system provide a combined user level thread and Kernel level thread facility. Solaris is a good example of this combined approach. In a combined system, multiple threads within the same application can run in parallel on multiple processors and a blocking system call need not block the entire process. Multithreading models are three types \n \nMany to many relationship.\nMany to one relationship.\nOne to one relationship.\n \n Many to Many Model \n The many-to-many model multiplexes any number of user threads onto an equal or smaller number of kernel threads. \n The following diagram shows the many-to-many threading model where 6 user level threads are multiplexing with 6 kernel level threads. In this model, developers can create as many user threads as necessary and the corresponding Kernel threads can run in parallel on a multiprocessor machine. This model provides the best accuracy on concurrency and when a thread performs a blocking system call, the kernel can schedule another thread for execution. \n  \n Many to One Model \n Many-to-one model maps many user level threads to one Kernel-level thread. Thread management is done in user space by the thread library. When thread makes a blocking system call, the entire process will be blocked. Only one thread can access the Kernel at a time, so multiple threads are unable to run in parallel on multiprocessors. \n If the user-level thread libraries are implemented in the operating system in such a way that the system does not support them, then the Kernel threads use the many-to-one relationship modes. \n  \n One to One Model \n There is one-to-one relationship of user-level thread to the kernel-level thread. This model provides more concurrency than the many-to-one model. It also allows another thread to run when a thread makes a blocking system call. It supports multiple threads to execute in parallel on microprocessors. \n Disadvantage of this model is that creating user thread requires the corresponding Kernel thread. OS/2, windows NT and windows 2000 use one to one relationship model. \n  \n Difference between User-Level & Kernel-Level Thread \n \n\nS.N.\nUser-Level Threads\nKernel-Level Thread\n\n\n1\nUser-level threads are faster to create and manage.\nKernel-level threads are slower to create and manage.\n\n\n2\nImplementation is by a thread library at the user level.\nOperating system supports creation of Kernel threads.\n\n\n3\nUser-level thread is generic and can run on any operating system.\nKernel-level thread is specific to the operating system.\n\n\n4\nMulti-threaded applications cannot take advantage of multiprocessing.\nKernel routines themselves can be multithreaded.\n\n \n Operating System - Memory Management \n Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or unallocated and correspondingly it updates the status. \n This tutorial will teach you basic concepts related to Memory Management. \n Process Address Space \n The process address space is the set of logical addresses that a process references in its code. For example, when 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes. \n The operating system takes care of mapping the logical addresses to physical addresses at the time of memory allocation to the program. There are three types of addresses used in a program before and after memory is allocated \u2212 \n \n\nS.N.\nMemory Addresses & Description\n\n\n1\n\nSymbolic addresses\nThe addresses used in a source code. The variable names, constants, and instruction labels are the basic elements of the symbolic address space.\n\n\n\n2\n\nRelative addresses\nAt the time of compilation, a compiler converts symbolic addresses into relative\naddresses.\n\n\n\n3\nPhysical addresses\nThe loader generates these addresses at the time when a program is loaded into main memory.\n\n\n \n Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. Virtual and physical addresses differ in execution-time address-binding scheme. \n The set of all logical addresses generated by a program is referred to as a logical address space. The set of all physical addresses corresponding to these logical addresses is referred to as a physical address space. \n The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device. MMU uses following mechanism to convert virtual address to physical address. \n \nThe value in the base register is added to every address generated by a user process, which is treated as offset at the time it is sent to memory. For example, if the base register value is 10000, then an attempt by the user to use address location 100 will be dynamically reallocated to location 10100.\nThe user program deals with virtual addresses; it never sees the real physical addresses.\n \n Static vs Dynamic Loading \n The choice between Static or Dynamic Loading is to be made at the time of computer program being developed. If you have to load your program statically, then at the time of compilation, the complete programs will be compiled and linked without leaving any external program or module dependency. The linker combines the object program with other necessary object modules into an absolute program, which also includes logical addresses. \n If you are writing a Dynamically loaded program, then your compiler will compile the program and for all the modules which you want to include dynamically, only references will be provided and rest of the work will be done at the time of execution. \n At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start. \n If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program. \n Static vs Dynamic Linking \n As explained above, when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency. \n When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking. Dynamic Link Libraries (DLL) in Windows and Shared Objects in Unix are good examples of dynamic libraries. \n Swapping \n Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory. \n Though performance is usually affected by swapping process but it helps in running multiple and big processes in parallel and that's the reason Swapping is also known as a technique for memory compaction. \n  \n The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, as well as the time the process takes to regain main memory. \n Let us assume that the user process is of size 2048KB and on a standard hard disk where swapping will take place has a data transfer rate around 1 MB per second. The actual transfer of the 1000K process to or from memory will take \n \n2048KB / 1024KB per second\n= 2 seconds\n= 2000 milliseconds\n \n Now considering in and out time, it will take complete 4000 milliseconds plus other overhead where the process competes to regain main memory. \n Memory Allocation \n Main memory usually has two partitions \u2212 \n \nLow Memory \u2212 Operating system resides in this memory.\nHigh Memory \u2212 User processes are held in high memory.\n \n Operating system uses the following memory allocation mechanism. \n \n\nS.N.\nMemory Allocation & Description\n\n\n1\nSingle-partition allocation\nIn this type of allocation, relocation-register scheme is used to protect user processes from each other, and from changing operating-system code and data. Relocation register contains value of smallest physical address whereas limit register contains range of logical addresses. Each logical address must be less than the limit register.\n\n\n2\nMultiple-partition allocation\nIn this type of allocation, main memory is divided into a number of fixed-sized\npartitions where each partition should contain only one process. When a partition\nis free, a process is selected from the input queue and is loaded into the free\npartition. When the process terminates, the partition becomes available for\nanother process.\n\n \n Fragmentation \n As processes are loaded and removed from memory, the free memory space is broken into little pieces. It happens after sometimes that processes cannot be allocated to memory blocks considering their small size and memory blocks remains unused. This problem is known as Fragmentation. \n Fragmentation is of two types \u2212 \n \n\nS.N.\nFragmentation & Description\n\n\n1\nExternal fragmentation\nTotal memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used.\n\n\n2\nInternal fragmentation\nMemory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.\n\n \n The following diagram shows how fragmentation can cause waste of memory and a compaction technique can be used to create more free memory out of fragmented memory \u2212 \n  \n External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction feasible, relocation should be dynamic. \n The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process. \n Paging \n A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard that's set up to emulate the computer's RAM. Paging technique plays an important role in implementing virtual memory. \n Paging is a memory management technique in which process address space is broken into blocks of the same size called pages (size is power of 2, between 512 bytes and 8192 bytes). The size of the process is measured in the number of pages. \n Similarly, main memory is divided into small fixed-sized blocks of (physical) memory called frames and the size of a frame is kept the same as that of a page to have optimum utilization of the main memory and to avoid external fragmentation. \n  \n Address Translation \n Page address is called logical address and represented by page number and the offset. \n \nLogical Address = Page number + page offset\n \n Frame address is called physical address and represented by a frame number and the offset. \n \nPhysical Address = Frame number + page offset\n \n A data structure called page map table is used to keep track of the relation between a page of a process to a frame in physical memory. \n  \n When the system allocates a frame to any page, it translates this logical address into a physical address and create entry into the page table to be used throughout execution of the program. \n When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program. \n This process continues during the whole execution of the program where the OS keeps removing idle pages from the main memory and write them onto the secondary memory and bring them back when required by the program. \n Advantages and Disadvantages of Paging \n Here is a list of advantages and disadvantages of paging \u2212 \n \nPaging reduces external fragmentation, but still suffer from internal fragmentation.\nPaging is simple to implement and assumed as an efficient memory management technique.\nDue to equal size of the pages and frames, swapping becomes very easy.\nPage table requires extra memory space, so may not be good for a system having small RAM.\n \n Segmentation \n Segmentation is a memory management technique in which each job is divided into several segments of different sizes, one for each module that contains pieces that perform related functions. Each segment is actually a different logical address space of the program. \n When a process is to be executed, its corresponding segmentation are loaded into non-contiguous memory though every segment is loaded into a contiguous block of available memory. \n Segmentation memory management works very similar to paging but here segments are of variable-length where as in paging pages are of fixed size. \n A program segment contains the program's main function, utility functions, data structures, and so on. The operating system maintains a segment map table for every process and a list of free memory blocks along with segment numbers, their size and corresponding memory locations in main memory. For each segment, the table stores the starting address of the segment and the length of the segment. A reference to a memory location includes a value that identifies a segment and an offset. \n  \n Operating System - Virtual Memory \n A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard disk that's set up to emulate the computer's RAM. \n The main visible advantage of this scheme is that programs can be larger than physical memory. Virtual memory serves two purposes. First, it allows us to extend the use of physical memory by using disk. Second, it allows us to have memory protection, because each virtual address is translated to a physical address. \n Following are the situations, when entire program is not required to be loaded fully in main memory. \n \nUser written error handling routines are used only when an error occurred in the data or computation.\nCertain options and features of a program may be used rarely.\nMany tables are assigned a fixed amount of address space even though only a small amount of the table is actually used.\nThe ability to execute a program that is only partially in memory would counter many benefits.\nLess number of I/O would be needed to load or swap each user program into memory.\nA program would no longer be constrained by the amount of physical memory that is available.\nEach user program could take less physical memory, more programs could be run the same time, with a corresponding increase in CPU utilization and throughput.\n \n Modern microprocessors intended for general-purpose use, a memory management unit, or MMU, is built into the hardware. The MMU's job is to translate virtual addresses into physical addresses. A basic example is given below \u2212 \n  \n Virtual memory is commonly implemented by demand paging. It can also be implemented in a segmentation system. Demand segmentation can also be used to provide virtual memory. \n Demand Paging \n A demand paging system is quite similar to a paging system with swapping where processes reside in secondary memory and pages are loaded only on demand, not in advance. When a context switch occurs, the operating system does not copy any of the old program\u2019s pages out to the disk or any of the new program\u2019s pages into the main memory Instead, it just begins executing the new program after loading the first page and fetches that program\u2019s pages as they are referenced. \n  \n While executing a program, if the program references a page which is not available in the main memory because it was swapped out a little ago, the processor treats this invalid memory reference as a page fault and transfers control from the program to the operating system to demand the page back into the memory. \n Advantages \n Following are the advantages of Demand Paging \u2212 \n \nLarge virtual memory.\nMore efficient use of memory.\nThere is no limit on degree of multiprogramming.\n \n Disadvantages \n \nNumber of tables and the amount of processor overhead for handling page interrupts are greater than in the case of the simple paged management techniques.\n \n Page Replacement Algorithm \n Page replacement algorithms are the techniques using which an Operating System decides which memory pages to swap out, write to disk when a page of memory needs to be allocated. Paging happens whenever a page fault occurs and a free page cannot be used for allocation purpose accounting to reason that pages are not available or the number of free pages is lower than required pages. \n When the page that was selected for replacement and was paged out, is referenced again, it has to read in from disk, and this requires for I/O completion. This process determines the quality of the page replacement algorithm: the lesser the time waiting for page-ins, the better is the algorithm. \n A page replacement algorithm looks at the limited information about accessing the pages provided by hardware, and tries to select which pages should be replaced to minimize the total number of page misses, while balancing it with the costs of primary storage and processor time of the algorithm itself. There are many different page replacement algorithms. We evaluate an algorithm by running it on a particular string of memory reference and computing the number of page faults, \n Reference String \n The string of memory references is called reference string. Reference strings are generated artificially or by tracing a given system and recording the address of each memory reference. The latter choice produces a large number of data, where we note two things. \n \nFor a given page size, we need to consider only the page number, not the entire address.\nIf we have a reference to a page p, then any immediately following references to page p will never cause a page fault. Page p will be in memory after the first reference; the immediately following references will not fault.\nFor example, consider the following sequence of addresses \u2212 123,215,600,1234,76,96\nIf page size is 100, then the reference string is 1,2,6,12,0,0\n \n First In First Out (FIFO) algorithm \n \nOldest page in main memory is the one which will be selected for replacement.\nEasy to implement, keep a list, replace pages from the tail and add new pages at the head.\n \n  \n Optimal Page algorithm \n \nAn optimal page-replacement algorithm has the lowest page-fault rate of all algorithms. An optimal page-replacement algorithm exists, and has been called OPT or MIN.\nReplace the page that will not be used for the longest period of time. Use the time when a page is to be used.\n \n  \n Least Recently Used (LRU) algorithm \n \nPage which has not been used for the longest time in main memory is the one which will be selected for replacement.\nEasy to implement, keep a list, replace pages by looking back into time.\n \n  \n Page Buffering algorithm \n \nTo get a process start quickly, keep a pool of free frames.\nOn page fault, select a page to be replaced.\nWrite the new page in the frame of free pool, mark the page table and restart the process.\nNow write the dirty page out of disk and place the frame holding replaced page in free pool.\n \n Least frequently Used(LFU) algorithm \n \nThe page with the smallest count is the one which will be selected for replacement.\nThis algorithm suffers from the situation in which a page is used heavily during the initial phase of a process, but then is never used again.\n \n Most frequently Used(MFU) algorithm \n \nThis algorithm is based on the argument that the page with the smallest count was probably just brought in and has yet to be used.\n \n Operating System - I/O Hardware \n One of the important jobs of an Operating System is to manage various I/O devices including mouse, keyboards, touch pad, disk drives, display adapters, USB devices, Bit-mapped screen, LED, Analog-to-digital converter, On/off switch, network connections, audio I/O, printers etc. \n An I/O system is required to take an application I/O request and send it to the physical device, then take whatever response comes back from the device and send it to the application. I/O devices can be divided into two categories \u2212 \n \nBlock devices \u2212 A block device is one with which the driver communicates by sending entire blocks of data. For example, Hard disks, USB cameras, Disk-On-Key etc.\nCharacter devices \u2212 A character device is one with which the driver communicates by sending and receiving single characters (bytes, octets). For example, serial ports, parallel ports, sounds cards etc\n \n Device Controllers \n Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices. \n The Device Controller works like an interface between a device and a device driver. I/O units (Keyboard, mouse, printer, etc.) typically consist of a mechanical component and an electronic component where electronic component is called the device controller. \n There is always a device controller and a device driver for each device to communicate with the Operating Systems. A device controller may be able to handle multiple devices. As an interface its main task is to convert serial bit stream to block of bytes, perform error correction as necessary. \n Any device connected to the computer is connected by a plug and socket, and the socket is connected to a device controller. Following is a model for connecting the CPU, memory, controllers, and I/O devices where CPU and device controllers all use a common bus for communication. \n  \n Synchronous vs asynchronous I/O \n \nSynchronous I/O \u2212 In this scheme CPU execution waits while I/O proceeds\nAsynchronous I/O \u2212 I/O proceeds concurrently with CPU execution\n \n Communication to I/O Devices \n The CPU must have a way to pass information to and from an I/O device. There are three approaches available to communicate with the CPU and Device. \n \nSpecial Instruction I/O\nMemory-mapped I/O\nDirect memory access (DMA)\n \n Special Instruction I/O \n This uses CPU instructions that are specifically made for controlling I/O devices. These instructions typically allow data to be sent to an I/O device or read from an I/O device. \n Memory-mapped I/O \n When using memory-mapped I/O, the same address space is shared by memory and I/O devices. The device is connected directly to certain main memory locations so that I/O device can transfer block of data to/from memory without going through CPU. \n  \n While using memory mapped IO, OS allocates buffer in memory and informs I/O device to use that buffer to send data to the CPU. I/O device operates asynchronously with CPU, interrupts CPU when finished. \n The advantage to this method is that every instruction which can access memory can be used to manipulate an I/O device. Memory mapped IO is used for most high-speed I/O devices like disks, communication interfaces. \n Direct Memory Access (DMA) \n Slow devices like keyboards will generate an interrupt to the main CPU after each byte is transferred. If a fast device such as a disk generated an interrupt for each byte, the operating system would spend most of its time handling these interrupts. So a typical computer uses direct memory access (DMA) hardware to reduce this overhead. \n Direct Memory Access (DMA) means CPU grants I/O module authority to read from or write to memory without involvement. DMA module itself controls exchange of data between main memory and the I/O device. CPU is only involved at the beginning and end of the transfer and interrupted only after entire block has been transferred. \n Direct Memory Access needs a special hardware called DMA controller (DMAC) that manages the data transfers and arbitrates access to the system bus. The controllers are programmed with source and destination pointers (where to read/write the data), counters to track the number of transferred bytes, and settings, which includes I/O and memory types, interrupts and states for the CPU cycles. \n  \n The operating system uses the DMA hardware as follows \u2212 \n \n\nStep\nDescription\n\n\n1\nDevice driver is instructed to transfer disk data to a buffer address X.\n\n\n2\nDevice driver then instruct disk controller to transfer data to buffer.\n\n\n3\nDisk controller starts DMA transfer.\n\n\n4\nDisk controller sends each byte to DMA controller.\n\n\n5\nDMA controller transfers bytes to buffer, increases the memory address, decreases the counter C until C becomes zero.\n\n\n6\nWhen C becomes zero, DMA interrupts CPU to signal transfer completion.\n\n \n Polling vs Interrupts I/O \n A computer must have a way of detecting the arrival of any type of input. There are two ways that this can happen, known as polling and interrupts. Both of these techniques allow the processor to deal with events that can happen at any time and that are not related to the process it is currently running. \n Polling I/O \n Polling is the simplest way for an I/O device to communicate with the processor. The process of periodically checking status of the device to see if it is time for the next I/O operation, is called polling. The I/O device simply puts the information in a Status register, and the processor must come and get the information. \n Most of the time, devices will not require attention and when one does it will have to wait until it is next interrogated by the polling program. This is an inefficient method and much of the processors time is wasted on unnecessary polls. \n Compare this method to a teacher continually asking every student in a class, one after another, if they need help. Obviously the more efficient method would be for a student to inform the teacher whenever they require assistance. \n Interrupts I/O \n An alternative scheme for dealing with I/O is the interrupt-driven method. An interrupt is a signal to the microprocessor from a device that requires attention. \n A device controller puts an interrupt signal on the bus when it needs CPU\u2019s attention when CPU receives an interrupt, It saves its current state and invokes the appropriate interrupt handler using the interrupt vector (addresses of OS routines to handle various events). When the interrupting device has been dealt with, the CPU continues with its original task as if it had never been interrupted. \n Operating System - I/O Softwares \n I/O software is often organized in the following layers \u2212 \n \nUser Level Libraries \u2212 This provides simple interface to the user program to perform input and output. For example, stdio is a library provided by C and C++ programming languages.\nKernel Level Modules \u2212 This provides device driver to interact with the device controller and device independent I/O modules used by the device drivers.\nHardware \u2212 This layer includes actual hardware and hardware controller which interact with the device drivers and makes hardware alive.\n \n A key concept in the design of I/O software is that it should be device independent where it should be possible to write programs that can access any I/O device without having to specify the device in advance. For example, a program that reads a file as input should be able to read a file on a floppy disk, on a hard disk, or on a CD-ROM, without having to modify the program for each different device. \n  \n Device Drivers \n Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices. Device drivers encapsulate device-dependent code and implement a standard interface in such a way that code contains device-specific register reads/writes. Device driver, is generally written by the device's manufacturer and delivered along with the device on a CD-ROM. \n A device driver performs the following jobs \u2212 \n \nTo accept request from the device independent software above to it.\nInteract with the device controller to take and give I/O and perform required error handling\nMaking sure that the request is executed successfully\n \n How a device driver handles a request is as follows: Suppose a request comes to read a block N. If the driver is idle at the time a request arrives, it starts carrying out the request immediately. Otherwise, if the driver is already busy with some other request, it places the new request in the queue of pending requests. \n Interrupt handlers \n An interrupt handler, also known as an interrupt service routine or ISR, is a piece of software or more specifically a callback function in an operating system or more specifically in a device driver, whose execution is triggered by the reception of an interrupt. \n When the interrupt happens, the interrupt procedure does whatever it has to in order to handle the interrupt, updates data structures and wakes up process that was waiting for an interrupt to happen. \n The interrupt mechanism accepts an address \u2500 a number that selects a specific interrupt handling routine/function from a small set. In most architectures, this address is an offset stored in a table called the interrupt vector table. This vector contains the memory addresses of specialized interrupt handlers. \n Device-Independent I/O Software \n The basic function of the device-independent software is to perform the I/O functions that are common to all devices and to provide a uniform interface to the user-level software. Though it is difficult to write completely device independent software but we can write some modules which are common among all the devices. Following is a list of functions of device-independent I/O Software \u2212 \n \nUniform interfacing for device drivers\nDevice naming - Mnemonic names mapped to Major and Minor device numbers\nDevice protection\nProviding a device-independent block size\nBuffering because data coming off a device cannot be stored in final destination.\nStorage allocation on block devices\nAllocation and releasing dedicated devices\nError Reporting\n \n User-Space I/O Software \n These are the libraries which provide richer and simplified interface to access the functionality of the kernel or ultimately interactive with the device drivers. Most of the user-level I/O software consists of library procedures with some exception like spooling system which is a way of dealing with dedicated I/O devices in a multiprogramming system. \n I/O Libraries (e.g., stdio) are in user-space to provide an interface to the OS resident device-independent I/O SW. For example putchar(), getchar(), printf() and scanf() are example of user level I/O library stdio available in C programming. \n Kernel I/O Subsystem \n Kernel I/O Subsystem is responsible to provide many services related to I/O. Following are some of the services provided. \n \nScheduling \u2212 Kernel schedules a set of I/O requests to determine a good order in which to execute them. When an application issues a blocking I/O system call, the request is placed on the queue for that device. The Kernel I/O scheduler rearranges the order of the queue to improve the overall system efficiency and the average response time experienced by the applications.\nBuffering \u2212 Kernel I/O Subsystem maintains a memory area known as buffer that stores data while they are transferred between two devices or between a device with an application operation. Buffering is done to cope with a speed mismatch between the producer and consumer of a data stream or to adapt between devices that have different data transfer sizes.\nCaching \u2212 Kernel maintains cache memory which is region of fast memory that holds copies of data. Access to the cached copy is more efficient than access to the original.\nSpooling and Device Reservation \u2212 A spool is a buffer that holds output for a device, such as a printer, that cannot accept interleaved data streams. The spooling system copies the queued spool files to the printer one at a time. In some operating systems, spooling is managed by a system daemon process. In other operating systems, it is handled by an in kernel thread.\nError Handling \u2212 An operating system that uses protected memory can guard against many kinds of hardware and application errors.\n \n Operating System - File System \n File \n A file is a named collection of related information that is recorded on secondary storage such as magnetic disks, magnetic tapes and optical disks. In general, a file is a sequence of bits, bytes, lines or records whose meaning is defined by the files creator and user. \n File Structure \n A File Structure should be according to a required format that the operating system can understand. \n \nA file has a certain defined structure according to its type.\nA text file is a sequence of characters organized into lines.\nA source file is a sequence of procedures and functions.\nAn object file is a sequence of bytes organized into blocks that are understandable by the machine.\nWhen operating system defines different file structures, it also contains the code to support these file structure. Unix, MS-DOS support minimum number of file structure.\n \n File Type \n File type refers to the ability of the operating system to distinguish different types of file such as text files source files and binary files etc. Many operating systems support many types of files. Operating system like MS-DOS and UNIX have the following types of files \u2212 \n Ordinary files \n \nThese are the files that contain user information.\nThese may have text, databases or executable program.\nThe user can apply various operations on such files like add, modify, delete or even remove the entire file.\n \n Directory files \n \nThese files contain list of file names and other information related to these files.\n \n Special files \n \nThese files are also known as device files.\nThese files represent physical device like disks, terminals, printers, networks, tape drive etc.\n \n These files are of two types \u2212 \n \nCharacter special files \u2212 data is handled character by character as in case of terminals or printers.\nBlock special files \u2212 data is handled in blocks as in the  case of disks and tapes.\n \n File Access Mechanisms \n File access mechanism refers to the manner in which the records of a file may be accessed. There are several ways to access files \u2212 \n \nSequential access\nDirect/Random access\nIndexed sequential access\n \n Sequential access \n A sequential access is that in which the records are accessed in some sequence, i.e., the information in the file is processed in order, one record after the other. This access method is the most primitive one. Example: Compilers usually access files in this fashion. \n Direct/Random access \n \nRandom access file organization provides, accessing the records directly.\nEach record has its own address on the file with by the help of which it can be directly accessed for reading or writing.\nThe records need not be in any sequence within the file and they need not be in adjacent locations on the storage medium.\n \n Indexed sequential access \n \nThis mechanism is built up on base of sequential access.\nAn index is created for each file which contains pointers to various blocks.\nIndex is searched sequentially and its pointer is used to access the file directly.\n \n Space Allocation \n Files are allocated disk spaces by operating system. Operating systems deploy following three main ways to allocate disk space to files. \n \nContiguous Allocation\nLinked Allocation\nIndexed Allocation\n \n Contiguous Allocation \n \nEach file occupies a contiguous address space on disk.\nAssigned disk address is in linear order.\nEasy to implement.\nExternal fragmentation is a major issue with this type of allocation technique.\n \n Linked Allocation \n \nEach file carries a list of links to disk blocks.\nDirectory contains link / pointer to first block of a file.\nNo external fragmentation\nEffectively used in sequential access file.\nInefficient in case of  direct access file.\n \n Indexed Allocation \n \nProvides solutions to problems of contiguous and linked allocation.\nA index block is created having all pointers to files.\nEach file has its own index block which stores the addresses of disk space occupied by the file.\nDirectory contains the addresses of index blocks of files.\n \n Operating System - Security \n Security refers to providing a protection system to computer system resources such as CPU, memory, disk, software programs and most importantly data/information stored in the computer system. If a computer program is run by an unauthorized user, then he/she may cause severe damage to computer or data stored in it. So a computer system must be protected against unauthorized access, malicious access to system memory, viruses, worms etc. We're going to discuss following topics in this chapter. \n \nAuthentication\nOne Time passwords\nProgram Threats\nSystem Threats\nComputer Security Classifications\n \n Authentication \n Authentication refers to identifying each user of the system and associating the executing programs with those users. It is the responsibility of the Operating System to create a protection system which ensures that a user who is running a particular program is authentic. Operating Systems generally identifies/authenticates users using following three ways \u2212 \n \nUsername / Password \u2212 User need to enter a registered username and password with Operating system to login into the system.\nUser card/key \u2212 User need to punch card in card slot, or enter key generated by key generator in option provided by operating system to login into the system.\nUser attribute - fingerprint/ eye retina pattern/ signature \u2212 User need to pass his/her attribute via designated input device used by operating system to login into the system.\n \n One Time passwords \n One-time passwords provide additional security along with normal authentication. In One-Time Password system, a unique password is required every time user tries to login into the system. Once a one-time password is used, then it cannot be used again. One-time password are implemented in various ways. \n \nRandom numbers \u2212 Users are provided cards having numbers printed along with corresponding alphabets. System asks for numbers corresponding to few alphabets randomly chosen.\nSecret key \u2212 User are provided a hardware device which can create a secret id mapped with user id. System asks for such secret id which is to be generated every time prior to login.\nNetwork password \u2212 Some commercial applications send one-time passwords to user on registered mobile/ email which is required to be entered prior to login.\n \n Program Threats \n Operating system's processes and kernel do the designated task as instructed. If a user program made these process do malicious tasks, then it is known as Program Threats. One of the common example of program threat is a program installed in a computer which can store and send user credentials via network to some hacker. Following is the list of some well-known program threats. \n \nTrojan Horse \u2212 Such program traps user login credentials and stores them to send to malicious user who can later on login to computer and can access system resources.\nTrap Door \u2212 If a program which is designed to work as required, have a security hole in its code and perform illegal action without knowledge of user then it is called to have a trap door.\nLogic Bomb \u2212 Logic bomb is a situation when a program misbehaves only when certain conditions met otherwise it works as a genuine program. It is harder to detect.\nVirus \u2212 Virus as name suggest can replicate themselves on computer system. They are highly dangerous and can modify/delete user files, crash systems. A virus is generatlly a small code embedded in a program. As user accesses the program, the virus starts getting embedded in other files/ programs and can make system unusable for user\n \n System Threats \n System threats refers to misuse of system services and network connections to put user in trouble. System threats can be used to launch program threats on a complete network called as program attack. System threats creates such an environment that operating system resources/ user files are misused. Following is the list of some well-known system threats. \n \nWorm \u2212 Worm is a process which can choked down a system performance by using system resources to extreme levels. A Worm process generates its multiple copies where each copy uses system resources, prevents all other processes to get required resources. Worms processes can even shut down an entire network.\nPort Scanning \u2212 Port scanning is a mechanism or means by which a hacker can detects system vulnerabilities to make an attack on the system.\nDenial of Service \u2212 Denial of service attacks normally prevents user to make legitimate use of the system. For example, a user may not be able to use internet if denial of service attacks browser's content settings.\n \n Computer Security Classifications \n As per the U.S. Department of Defense Trusted Computer System's Evaluation Criteria there are four security classifications in computer systems: A, B, C, and D. This is widely used specifications to determine and model the security of systems and of security solutions. Following is the brief description of each classification. \n \n\nS.N.\nClassification Type & Description\n\n\n1\nType A\nHighest Level. Uses formal design specifications and verification techniques. Grants a high degree of assurance of process security.\n\n\n2\nType B\nProvides mandatory protection system. Have all the properties of a class C2 system. Attaches a sensitivity label to each object. It is of three types.\n\nB1 \u2212 Maintains the security label of each object in the system. Label is used for making decisions to access control.\nB2 \u2212 Extends the sensitivity labels to each system resource, such as storage objects, supports covert channels and auditing of events.\nB3 \u2212 Allows creating lists or user groups for access-control to grant access or revoke access to a given named object.\n\n\n\n\n3\nType C\nProvides protection and user accountability using audit capabilities. It is of two types.\n\nC1 \u2212 Incorporates controls so that users can protect their private information and keep other users from accidentally reading / deleting their data. UNIX versions are mostly Cl class.\nC2 \u2212 Adds an individual-level access control to the capabilities of a Cl level system.\n\n\n\n\n4\nType D\nLowest level. Minimum protection. MS-DOS, Window 3.1 fall in this category.\n\n \n Operating System - Linux \n Linux is one of popular version of UNIX operating System. It is open source as its source code is freely available. It is free to use. Linux was designed considering UNIX compatibility. Its functionality list is quite similar to that of UNIX. \n Components of Linux System \n Linux Operating System has primarily three components \n \nKernel \u2212 Kernel is the core part of Linux. It is responsible for all major activities of this operating system. It consists of various modules and it interacts directly with the underlying hardware. Kernel provides the required abstraction to hide low level hardware details to system or application programs.\nSystem Library \u2212 System libraries are special functions or programs using which application programs or system utilities accesses Kernel's features. These libraries implement most of the functionalities of the operating system and do not requires kernel module's code access rights.\nSystem Utility \u2212 System Utility programs are responsible to do specialized, individual level tasks.\n \n  \n Kernel Mode vs User Mode \n Kernel component code executes in a special privileged mode called kernel mode with full access to all resources of the computer. This code represents a single process, executes in single address space and do not require any context switch and hence is very efficient and fast. Kernel runs each processes and provides system services to processes, provides protected access to hardware to processes. \n Support code which is not required to run in kernel mode is in System Library. User programs and other system programs works in User Mode which has no access to system hardware and kernel code. User programs/ utilities use System libraries to access Kernel functions to get system's low level tasks. \n Basic Features \n Following are some of the important features of Linux Operating System. \n \nPortable \u2212 Portability means software can works on different types of hardware in same way. Linux kernel and application programs supports their installation on any kind of hardware platform.\nOpen Source \u2212 Linux source code is freely available and it is community based development project. Multiple teams work in collaboration to enhance the capability of Linux operating system and it is continuously evolving.\nMulti-User \u2212 Linux is a multiuser system means multiple users can access system resources like memory/ ram/ application programs at same time.\nMultiprogramming \u2212 Linux is a multiprogramming system means multiple applications can run at same time.\nHierarchical File System \u2212 Linux provides a standard file structure in which system files/ user files are arranged.\nShell \u2212 Linux provides a special interpreter program which can be used to execute commands of the operating system. It can be used to do various types of operations, call application programs. etc.\nSecurity \u2212 Linux provides user security using authentication features like password protection/ controlled access to specific files/ encryption of data.\n \n Architecture \n The following illustration shows the architecture of a Linux system \u2212 \n  \n The architecture of a Linux System consists of the following layers \u2212 \n \nHardware layer \u2212 Hardware consists of all peripheral devices (RAM/ HDD/ CPU etc).\nKernel \u2212 It is the core component of Operating System, interacts directly with hardware, provides low level services to upper layer components.\nShell \u2212 An interface to kernel, hiding complexity of kernel's functions from users. The shell takes commands from the user and executes kernel's functions.\nUtilities \u2212 Utility programs that provide the user most of the functionalities of an operating systems.\n \n  \n \n Previous Page\n \n \n Print\n \n \nNext Page \u00a0\n \n  \n  PRINTING ENDS HERE  \n \nAdvertisements\n<!--\nvar width = 580;\nvar height = 400;\nvar format = \"580x400_as\";\nif( window.innerWidth < 468 ){\n   width = 300;\n   height = 250;\n   format = \"300x250_as\";\n}\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = width;\ngoogle_ad_height = height;\ngoogle_ad_format = format;\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//-->\n\n\n \n", "title": "Operating System - Quick Guide", "content_html": "<div class=\"col-md-7 middle-col\">\n<h1>Operating System - Quick Guide</h1>\n<hr/>\n<div style=\"padding-bottom:5px;padding-left:10px;text-align: center;\">Advertisements</div>\n<div style=\"text-align: center;\">\n<script type=\"text/javascript\"><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\" type=\"text/javascript\">\n</script>\n</div>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/operating_system/os_exams_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/operating_system/os_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<div class=\"clearer\"></div>\n<hr/>\n<h1>Operating System - Overview</h1>\n<p>An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers.</p>\n<p>Some popular Operating Systems include Linux Operating System, Windows Operating System, VMS, OS/400, AIX, z/OS, etc.</p>\n<h2>Definition</h2>\n<p>An operating system is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs.</p>\n<img alt=\"Conceptual view of an Operating System\" src=\"/operating_system/images/conceptual_view.jpg\"/>\n<p>Following are some of important functions of an operating System.</p>\n<ul class=\"list\">\n<li>Memory Management</li>\n<li>Processor Management</li>\n<li>Device Management</li>\n<li>File Management</li>\n<li>Security</li>\n<li>Control over system performance</li>\n<li>Job accounting</li>\n<li>Error detecting aids</li>\n<li>Coordination between other software and users</li>\n</ul>\n<h2>Memory Management</h2>\n<p>Memory management refers to management of Primary Memory or Main Memory. Main memory is a large array of words or bytes where each word or byte has its own address.</p>\n<p>Main memory provides a fast storage that can be accessed directly by the CPU. For a program to be executed, it must in the main memory. An Operating System does the following activities for memory management \u2212</p>\n<ul class=\"list\">\n<li><p>Keeps tracks of primary memory, i.e., what part of it are in use by whom, what part are not in use.</p></li>\n<li><p>In multiprogramming, the OS decides which process will get memory when and how much.</p></li>\n<li><p>Allocates the memory when a process requests it to do so.</p></li>\n<li><p>De-allocates the memory when a process no longer needs it or has been terminated.</p></li>\n</ul>\n<h2>Processor Management</h2>\n<p>In multiprogramming environment, the OS decides which process gets the processor when and for how much time. This function is called <b>process  scheduling</b>. An Operating System does the following activities for processor management \u2212</p>\n<ul class=\"list\">\n<li><p>Keeps tracks of processor and status of process. The program responsible for this task is known as <b>traffic controller</b>.</p></li>\n<li><p>Allocates the processor (CPU) to a process.</p></li>\n<li><p>De-allocates processor when a process is no longer required.</p></li>\n</ul>\n<h2>Device Management</h2>\n<p>An Operating System manages device communication via their respective drivers. It does the following activities for device management \u2212</p>\n<ul class=\"list\">\n<li><p>Keeps tracks of all devices. Program responsible for this task is known as the <b>I/O controller</b>.</p></li>\n<li><p>Decides which process gets the device when and for how much time.</p></li>\n<li><p>Allocates the device in the efficient way.</p></li>\n<li><p>De-allocates devices.</p></li>\n</ul>\n<h2>File Management</h2>\n<p>A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions.</p>\n<p>An Operating System does the following activities for file management \u2212</p>\n<ul class=\"list\">\n<li><p>Keeps track of information, location, uses, status etc. The collective facilities are often known as <b>file system</b>.</p></li>\n<li><p>Decides who gets the resources.</p></li>\n<li><p>Allocates the resources.</p></li>\n<li><p>De-allocates the resources.</p></li>\n</ul>\n<h2>Other Important Activities</h2>\n<p>Following are some of the important activities that an Operating System performs \u2212</p>\n<ul class=\"list\">\n<li><p><b>Security</b> \u2212  By means of password and similar other techniques, it prevents unauthorized access to programs and data.</p></li>\n<li><p><b>Control over system performance</b> \u2212 Recording delays between request for a service and response from the system.</p></li>\n<li><p><b>Job accounting</b> \u2212 Keeping track of time and resources used by various jobs and users.</p></li>\n<li><p><b>Error detecting aids</b> \u2212 Production of dumps, traces, error messages, and other debugging and error detecting aids.</p></li>\n<li><p><b>Coordination between other softwares and users</b> \u2212 Coordination and assignment of compilers, interpreters, assemblers and other software to the various users of the computer systems.</p></li>\n</ul>\n<h1>Types of Operating System</h1>\n<p>Operating systems are there from the very first computer generation and they keep evolving with time. In this chapter, we will discuss some of the important types of operating systems which are most commonly used.</p>\n<h2>Batch operating system</h2>\n<p>The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator. To speed up processing, jobs with similar needs are batched together and run as a group. The programmers leave their programs with the operator and the operator then sorts the programs with similar requirements into batches.</p>\n<p>The problems with Batch Systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>Lack of interaction between the user and the job.</li>\n<li>CPU is often idle, because the speed of the mechanical I/O devices is slower than the CPU.</li>\n<li>Difficult to provide the desired priority.</li>\n</ul>\n<h2>Time-sharing operating systems</h2>\n<p>Time-sharing is a technique which enables many people, located at various terminals, to use a particular computer system at the same time. Time-sharing or multitasking is a logical extension of multiprogramming. Processor's time which is shared among multiple users simultaneously is termed as time-sharing.</p>\n<p>The main difference between Multiprogrammed Batch Systems and Time-Sharing Systems is that in case of Multiprogrammed batch systems, the objective is to maximize processor use, whereas in Time-Sharing Systems, the objective is to minimize response time.</p>\n<p>Multiple jobs are executed by the CPU by switching between them, but the switches occur so frequently. Thus, the user can receive an immediate response. For example, in a transaction processing, the processor executes each user program in a short burst or quantum of computation. That is, if <b>n</b> users are present, then each user can get a time quantum. When the user submits the command, the response time is in few seconds at most.</p>\n<p>The operating system uses CPU scheduling and multiprogramming to provide each user with a small portion of a time. Computer systems that were designed primarily as batch systems have been modified to time-sharing systems.</p>\n<p>Advantages of Timesharing operating systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>Provides the advantage of quick response.</li>\n<li>Avoids duplication of software.</li>\n<li>Reduces CPU idle time.</li>\n</ul>\n<p>Disadvantages of Time-sharing operating systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>Problem of reliability.</li>\n<li>Question of security and integrity of user programs and data.</li>\n<li>Problem of data communication.</li>\n</ul>\n<h2>Distributed operating System</h2>\n<p>Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly.</p>\n<p>The processors communicate with one another through various communication lines (such as high-speed buses or telephone lines). These are referred as <b>loosely coupled systems</b> or distributed systems. Processors in a distributed system may vary in size and function. These processors are referred as sites, nodes, computers, and so on.</p>\n<p>The advantages of distributed systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>With resource sharing facility, a user at one site may be able to use the resources available at another.</li>\n<li>Speedup the exchange of data with one another via electronic mail.</li>\n<li>If one site fails in a distributed system, the remaining sites can potentially continue operating.</li>\n<li>Better service to the customers.</li>\n<li>Reduction of the load on the host computer.</li>\n<li>Reduction of delays in data processing.</li>\n</ul>\n<h2>Network operating System</h2>\n<p>A Network Operating System runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a local area network (LAN), a private network or to other networks.</p>\n<p>Examples of network operating systems include Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD.</p>\n<p>The advantages of network operating systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>Centralized servers are highly stable.</li>\n<li>Security is server managed.</li>\n<li>Upgrades to new technologies and hardware can be easily integrated into the system.</li>\n<li>Remote access to servers is possible from different locations and types of systems.</li>\n</ul>\n<p>The disadvantages of network operating systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>High cost of buying and running a server.</li>\n<li>Dependency on a central location for most operations.</li>\n<li>Regular maintenance and updates are required.</li>\n</ul>\n<h2>Real Time operating System</h2>\n<p>A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment. The time taken by the system to respond to an input and display of required updated information is termed as the <b>response time</b>. So in this method, the response time is very less as compared to online processing.</p>\n<p>Real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application. A real-time operating system must have well-defined, fixed time constraints, otherwise the system will fail. For example, Scientific experiments, medical imaging systems, industrial control systems, weapon systems, robots, air traffic control systems, etc.</p>\n<p>There are two types of real-time operating systems.</p>\n<h3>Hard real-time systems</h3>\n<p>Hard real-time systems guarantee that critical tasks complete on time. In hard real-time systems, secondary storage is limited or missing and the data is stored in ROM. In these systems, virtual memory is almost never found.</p>\n<h3>Soft real-time systems</h3>\n<p>Soft real-time systems are less restrictive. A critical real-time task gets priority over other tasks and retains the priority until it completes. Soft real-time systems have limited utility than hard real-time systems. For example, multimedia, virtual reality, Advanced Scientific Projects like undersea exploration and planetary rovers, etc.</p>\n<h1>Operating System - Services</h1>\n<p>An Operating System provides services to both the users and to the programs.</p>\n<ul class=\"list\">\n<li>It provides programs an environment to execute.</li>\n<li>It provides users the services to execute the programs in a convenient manner.</li>\n</ul>\n<p>Following are a few common services provided by an operating system \u2212</p>\n<ul class=\"list\">\n<li>Program execution</li>\n<li>I/O operations</li>\n<li>File System manipulation</li>\n<li>Communication</li>\n<li>Error Detection</li>\n<li>Resource Allocation</li>\n<li>Protection</li>\n</ul>\n<h2>Program execution</h2>\n<p>Operating systems handle many kinds of activities from user programs to system programs like printer spooler, name servers, file server, etc. Each of these activities is encapsulated as a process.</p>\n<p>A process includes the complete execution context (code to execute, data to manipulate, registers, OS resources in use). Following are the major activities of an operating system with respect to program management \u2212</p>\n<ul class=\"list\">\n<li>Loads a program into memory.</li>\n<li>Executes the program.</li>\n<li>Handles program's execution.</li>\n<li>Provides a mechanism for process synchronization.</li>\n<li>Provides a mechanism for process communication.</li>\n<li>Provides a mechanism for deadlock handling.</li>\n</ul>\n<h2>I/O Operation</h2>\n<p>An I/O subsystem comprises of I/O devices and their corresponding driver software. Drivers hide the peculiarities of specific hardware devices from the users.</p>\n<p>An Operating System manages the communication between user and device drivers.</p>\n<ul class=\"list\">\n<li>I/O operation means read or write operation with any file or any specific I/O device.</li>\n<li>Operating system provides the access to the required I/O device when required.</li>\n</ul>\n<h2>File system manipulation</h2>\n<p>A file represents a collection of related information. Computers can store files on the disk (secondary storage), for long-term storage purpose. Examples of storage media include magnetic tape, magnetic disk and optical disk drives like CD, DVD. Each of these media has its own properties like speed, capacity, data transfer rate and data access methods.</p>\n<p>A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. Following are the major activities of an operating system with respect to file management \u2212</p>\n<ul class=\"list\">\n<li>Program needs to read a file or write a file.</li>\n<li>The operating system gives the permission to the program for operation on file.</li>\n<li>Permission varies from read-only, read-write, denied and so on.</li>\n<li>Operating System provides an interface to the user to create/delete files.</li>\n<li>Operating System provides an interface to the user to create/delete directories.</li>\n<li>Operating System provides an interface to create the backup of file system.</li>\n</ul>\n<h2>Communication</h2>\n<p>In case of distributed systems which are a collection of processors that do not share memory, peripheral devices, or a clock, the operating system manages communications between all the processes. Multiple processes communicate with one another through communication lines in the network.</p>\n<p>The OS handles routing and connection strategies, and the problems of contention and security. Following are the major activities of an operating system with respect to communication \u2212</p>\n<ul class=\"list\">\n<li>Two processes often require data to be transferred between them</li>\n<li>Both the processes can be on one computer or on different computers, but are connected through a computer network.</li>\n<li>Communication may be implemented by two methods, either by Shared Memory or by Message Passing.</li>\n</ul>\n<h2>Error handling</h2>\n<p>Errors can occur anytime and anywhere. An error may occur in CPU, in I/O devices or in the memory hardware. Following are the major activities of an operating system with respect to error handling \u2212</p>\n<ul class=\"list\">\n<li>The OS constantly checks for possible errors.</li>\n<li>The OS takes an appropriate action to ensure correct and consistent computing.</li>\n</ul>\n<h2>Resource Management</h2>\n<p>In case of multi-user or multi-tasking environment, resources such as main memory, CPU cycles and files storage are to be allocated to each user or job. Following are the major activities of an operating system with respect to resource management \u2212</p>\n<ul class=\"list\">\n<li>The OS manages all kinds of resources using schedulers.</li>\n<li>CPU scheduling algorithms are used for better utilization of CPU.</li>\n</ul>\n<h2>Protection</h2>\n<p>Considering a computer system having multiple users and concurrent execution of multiple processes, the various processes must be protected from each other's activities.</p>\n<p>Protection refers to a mechanism or a way to control the access of programs, processes, or users to the resources defined by a computer system. Following are the major activities of an operating system with respect to protection \u2212</p>\n<ul class=\"list\">\n<li>The OS ensures that all access to system resources is controlled.</li>\n<li>The OS ensures that external I/O devices are protected from invalid access attempts.</li>\n<li>The OS provides authentication features for each user by means of passwords.</li>\n</ul>\n<h1>Operating System - Properties</h1>\n<h2>Batch processing</h2>\n<p>Batch processing is a technique in which an Operating System collects the programs and data together in a batch before processing starts. An operating system does the following activities related to batch processing \u2212</p>\n<ul class=\"list\">\n<li><p>The OS defines a job which has predefined sequence of commands, programs and data as a single unit.</p></li>\n<li><p>The OS keeps a number a jobs in memory and executes them without any manual information.</p></li>\n<li><p>Jobs are processed in the order of submission, i.e., first come first served fashion.</p></li>\n<li><p>When a job completes its execution, its memory is released and the output for the job gets copied into an output spool for later printing or processing.</p></li>\n</ul>\n<img alt=\"Batch Processing\" src=\"/operating_system/images/batch_processing.jpg\"/>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li><p>Batch processing takes much of the work of the operator to the computer.</p></li>\n<li><p>Increased performance as a new job get started as soon as the previous job is finished, without any manual intervention.</p></li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li>Difficult to debug program.</li>\n<li>A job could enter an infinite loop.</li>\n<li>Due to lack of protection scheme, one batch job can affect pending jobs.</li>\n</ul>\n<h2>Multitasking</h2>\n<p>Multitasking is when multiple jobs are executed by the CPU simultaneously by switching between them. Switches occur so frequently that the users may interact with each program while it is running. An OS does the following activities related to multitasking \u2212</p>\n<ul class=\"list\">\n<li><p>The user gives instructions to the operating system or to a program directly, and receives an immediate response.</p></li>\n<li><p>The OS handles multitasking in the way that it can handle multiple operations/executes multiple programs at a time.</p></li>\n<li><p>Multitasking Operating Systems are also known as Time-sharing systems.</p></li>\n<li><p>These Operating Systems were developed to provide interactive use of a computer system at a reasonable cost.</p></li>\n<li><p>A time-shared operating system uses the concept of CPU scheduling and multiprogramming to provide each user with a small portion of a time-shared CPU.</p></li>\n<li><p>Each user has at least one separate program in memory.</p></li>\n</ul>\n<img alt=\"Multitasking\" src=\"/operating_system/images/multitasking.jpg\"/>\n<ul class=\"list\">\n<li><p>A program that is loaded into memory and is executing is commonly referred to as a <b>process</b>.</p></li>\n<li><p>When a process executes, it typically executes for only a very short time before it either finishes or needs to perform I/O.</p></li>\n<li><p>Since interactive I/O typically runs at slower speeds, it may take a long time to complete. During this time, a CPU can be utilized by another process.</p></li>\n<li><p>The operating system allows the users to share the computer simultaneously. Since each action or command in a time-shared system tends to be short, only a little CPU time is needed for each user.</p></li>\n<li><p>As the system switches CPU rapidly from one user/program to the next, each user is given the impression that he/she has his/her own CPU, whereas actually one CPU is being shared among many users.</p></li>\n</ul>\n<h2>Multiprogramming</h2>\n<p>Sharing the processor, when two or more programs reside in memory at the same time, is referred as <b> multiprogramming</b>. Multiprogramming assumes a single shared processor. Multiprogramming increases CPU utilization by organizing jobs so that the CPU always has one to execute.</p>\n<p>The following figure shows the memory layout for a multiprogramming system.</p>\n<img alt=\"Memory layout\" src=\"/operating_system/images/memory_layout.jpg\"/>\n<p>An OS does the following activities related to multiprogramming.</p>\n<ul class=\"list\">\n<li><p>The operating system keeps several jobs in memory at a time.</p></li>\n<li><p>This set of jobs is a subset of the jobs kept in the job pool.</p></li>\n<li><p>The operating system picks and begins to execute one of the jobs in the memory.</p></li>\n<li><p>Multiprogramming operating systems monitor the state of all active programs and system resources using memory management programs to ensures that the CPU is never idle, unless there are no jobs to process.</p></li>\n</ul>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li>High and efficient CPU utilization.</li>\n<li>User feels that many programs are allotted CPU almost simultaneously.</li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li>CPU scheduling is required.</li>\n<li>To accommodate many jobs in memory, memory management is required.</li>\n</ul>\n<h2>Interactivity</h2>\n<p>Interactivity refers to the ability of users to interact with a computer system. An Operating system does the following activities related to interactivity \u2212</p>\n<ul class=\"list\">\n<li>Provides the user an interface to interact with the system.</li>\n<li>Manages input devices to take inputs from the user. For example, keyboard.</li>\n<li>Manages output devices to show outputs to the user. For example, Monitor.</li>\n</ul>\n<p>The response time of the OS needs to be short, since the user submits and waits for the result.</p>\n<h2>Real Time System</h2>\n<p>Real-time systems are usually dedicated, embedded systems. An operating system does the following activities related to real-time system activity.</p>\n<ul class=\"list\">\n<li>In such systems, Operating Systems typically read from and react to sensor data.</li>\n<li>The Operating system must guarantee response to events within fixed periods of time to ensure correct performance.</li>\n</ul>\n<h2>Distributed Environment </h2>\n<p>A distributed environment refers to multiple independent CPUs or processors in a computer system. An operating system does the following activities related to distributed environment \u2212</p>\n<ul class=\"list\">\n<li><p>The OS distributes computation logics among several physical processors.</p></li>\n<li><p>The processors do not share memory or a clock. Instead, each processor has its own local memory.</p></li>\n<li><p>The OS manages the communications between the processors. They communicate with each other through various communication lines.</p></li>\n</ul>\n<h2>Spooling</h2>\n<p>Spooling is an acronym for simultaneous peripheral operations on line. Spooling refers to putting data of various I/O jobs in a buffer. This buffer is a special area in memory or hard disk which is accessible to I/O devices.</p>\n<p>An operating system does the following activities related to distributed environment \u2212</p>\n<ul class=\"list\">\n<li><p>Handles I/O device data spooling as devices have different data access rates.</p></li>\n<li><p>Maintains the spooling buffer which provides a waiting station where data can rest while the slower device catches up.</p></li>\n<li><p>Maintains parallel computation because of spooling process as a computer can perform I/O in parallel fashion. It becomes possible to have the computer read data from a tape, write data to disk and to write out to a tape printer while it is doing its computing task.</p></li>\n</ul>\n<img alt=\"Spooling\" src=\"/operating_system/images/spooling.jpg\"/>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li>The spooling operation uses a disk as a very large buffer.</li>\n<li>Spooling is capable of overlapping I/O operation for one job with processor operations for another job.</li>\n</ul>\n<h1>Operating System - Processes</h1>\n<h2>Process</h2>\n<p>A process is basically a program in execution. The execution of a process must progress in a sequential fashion.</p>\n<blockquote>A process is defined as an entity which represents the basic unit of work to be implemented in the system.</blockquote>\n<p>To put it in simple terms, we write our computer programs in a text file and when we execute this program, it becomes a process which performs all the tasks mentioned in the program.</p>\n<p>When a program is loaded into the memory and it becomes a process, it can be divided into four sections \u2500 stack, heap, text and data. The following image shows a simplified layout of a process inside main memory \u2212</p>\n<img alt=\"Process Components\" src=\"/operating_system/images/process_components.jpg\"/>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">Component &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Stack</b></p>\n<p>The process Stack contains the temporary data such as method/function parameters, return address and local variables.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Heap</b></p>\n<p>This is dynamically allocated memory to a process during its run time.</p>\n</td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Text</b></p>\n<p>This includes the current activity represented by the value of Program Counter and the contents of the processor's registers.</p>\n</td>\n</tr>\n<tr>\n<td>4</td>\n<td><p><b>Data</b></p>\n<p>This section contains the global and static variables.</p>\n</td>\n</tr>\n</table>\n<h2>Program</h2>\n<p>A program is a piece of code which may be a single line or millions of lines. A computer program is usually written by a computer programmer in a programming language. For example, here is a simple program written in C programming language \u2212</p>\n<pre class=\"prettyprint notranslate\">\n#include &lt;stdio.h&gt;\n\nint main() {\n   printf(\"Hello, World! \\n\");\n   return 0;\n}\n</pre>\n<p>A computer program is a collection of instructions that performs a specific task when executed by a computer. When we compare a program with a process, we can conclude that a process is a dynamic instance of a computer program.</p>\n<p>A part of a computer program that performs a well-defined task is known as an <b>algorithm</b>. A collection of computer programs, libraries and related data are referred to as a <b>software</b>.</p>\n<h2>Process Life Cycle</h2>\n<p> When a process executes, it passes through different states. These stages may differ in different operating systems, and the names of these states are also not standardized.</p>\n<p>In general, a process can have one of the following five states at a time.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">State &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td>\n<p><b>Start</b></p>\n<p>This is the initial state when a process is first started/created.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td>\n<p><b>Ready</b></p>\n<p>The process is waiting to be assigned to a processor. Ready processes are waiting to have the processor allocated to them by the operating system so that they can run. Process may come into this state after <b>Start</b> state or while running it by but interrupted by the scheduler to assign CPU to some other process.</p>\n</td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Running</b></p>\n<p>Once the process has been assigned to a processor by the OS scheduler, the process state is set to running and the processor executes its instructions.</p></td>\n</tr>\n<tr>\n<td>4</td>\n<td><p><b>Waiting</b></p>\n<p>Process moves into the waiting state if it needs to wait for a resource, such as waiting for user input, or waiting for a file to become available.</p></td>\n</tr>\n<tr>\n<td>5</td>\n<td><p><b>Terminated or Exit</b></p>\n<p>Once the process finishes its execution, or it is terminated by the operating system, it is moved to the terminated state where it waits to be removed from main memory.</p></td>\n</tr>\n</table>\n<img alt=\"Process States\" src=\"/operating_system/images/process_state.jpg\"/>\n<h2>Process Control Block (PCB)</h2>\n<p>A Process Control Block is a data structure maintained by the Operating System for every process. The PCB is identified by an integer process ID (PID). A PCB keeps all the information needed to keep track of a process as listed below in the table \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">Information &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Process State</b></p>\n<p>The current state of the process i.e., whether it is ready, running, waiting, or whatever.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Process privileges</b></p>\n<p>This is required to allow/disallow access to system resources.</p></td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Process ID</b></p>\n<p>Unique identification for each of the process in the operating system.</p></td>\n</tr>\n<tr>\n<td>4</td>\n<td><p><b>Pointer</b></p>\n<p>A pointer to parent process.</p></td>\n</tr>\n<tr>\n<td>5</td>\n<td><p><b>Program Counter</b></p>\n<p>Program Counter is a pointer to the address of the next instruction to be executed for this process.</p></td>\n</tr>\n<tr>\n<td>6</td>\n<td><p><b>CPU registers</b></p>\n<p>Various CPU registers where process need to be stored for execution for running state.</p></td>\n</tr>\n<tr>\n<td>7</td>\n<td><p><b>CPU Scheduling Information</b></p>\n<p>Process priority and other scheduling information  which is required to schedule the process.</p></td>\n</tr>\n<tr>\n<td>8</td>\n<td><p><b>Memory management information</b></p>\n<p>This includes the information of page table, memory limits, Segment table depending on memory used by the operating system.</p></td>\n</tr>\n<tr>\n<td>9</td>\n<td><p><b>Accounting information</b></p>\n<p>This  includes the amount of CPU used for process execution, time limits, execution ID etc.</p></td>\n</tr>\n<tr>\n<td>10</td>\n<td><p><b>IO status information</b></p>\n<p>This includes a list of I/O devices allocated to the process.</p></td>\n</tr>\n</table>\n<p>The architecture of a PCB is completely dependent on Operating System and may contain different information in different operating systems. Here is a simplified diagram of a PCB \u2212</p>\n<img alt=\"Process Control Block\" src=\"/operating_system/images/pcb.jpg\"/>\n<p>The PCB is maintained for a process throughout its lifetime, and is deleted once the process terminates.</p>\n<h1>Operating System - Process Scheduling</h1>\n<h2>Definition</h2>\n<p>The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.</p>\n<p>Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing.</p>\n<h2>Process Scheduling Queues</h2>\n<p>The OS maintains all PCBs in Process Scheduling Queues. The OS maintains a separate queue for each of the process states and PCBs of all processes in the same execution state are placed in the same queue. When the state of a process is changed, its PCB is unlinked from its current queue and moved to its new state queue.</p>\n<p>The Operating System maintains the following important process scheduling queues \u2212</p>\n<ul class=\"list\">\n<li><p><b>Job queue</b> \u2212 This queue keeps all the processes in the system.</p></li>\n<li><p><b>Ready queue</b> \u2212 This queue keeps a set of all processes residing in main memory, ready and waiting to execute. A new process is always put in this queue.</p></li>\n<li><p><b>Device queues</b> \u2212 The processes which are blocked due to unavailability of an I/O device constitute this queue.</p></li>\n</ul>\n<img alt=\"Process Scheduling Queuing\" src=\"/operating_system/images/queuing_diagram.jpg\"/>\n<p>The OS can use different policies to manage each queue (FIFO, Round Robin, Priority, etc.). The OS scheduler determines how to move processes between the ready and run queues which can only have one entry per processor core on the system; in the above diagram, it has been merged with the CPU.</p>\n<h2>Two-State Process Model</h2>\n<p>Two-state process model refers to running and non-running states which are described below \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">State &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Running</b></p>\n<p>When a new process is created, it enters into the system as in the running state.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Not Running</b></p>\n<p>Processes that are not running are kept in queue, waiting for their turn to execute. Each entry in the queue is a pointer to a particular process. Queue is implemented by using linked list. Use of dispatcher is as follows. When a process is interrupted, that process is transferred in the waiting queue. If the process has completed or aborted, the process is discarded. In either case, the dispatcher then selects a process from the queue to execute.</p>\n</td>\n</tr>\n</table>\n<h2>Schedulers</h2>\n<p>Schedulers are special system software which handle process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run. Schedulers are of three types \u2212</p>\n<ul class=\"list\">\n<li>Long-Term Scheduler</li>\n<li>Short-Term Scheduler</li>\n<li>Medium-Term Scheduler</li>\n</ul>\n<h2>Long Term Scheduler</h2>\n<p>It is also called a <b>job scheduler</b>. A long-term scheduler determines which programs are admitted to the system for processing. It selects processes from the queue and loads them into memory for execution. Process loads into the memory for CPU scheduling.</p>\n<p>The primary objective of the job scheduler is to provide a balanced mix of jobs, such as I/O bound and processor bound. It also controls the degree of multiprogramming. If the degree of multiprogramming is stable, then the average rate of process creation must be equal to the average departure rate of processes leaving the system.</p>\n<p>On some systems, the long-term scheduler may not be available or minimal. Time-sharing operating systems have no long term scheduler. When a process changes the state from new to ready, then there is use of long-term scheduler.</p>\n<h2>Short Term Scheduler</h2>\n<p>It is also called as <b>CPU scheduler</b>. Its main objective is to increase system performance in accordance with the chosen set of criteria. It is the change of ready state to running state of the process. CPU scheduler selects a process among the processes that are ready to execute and allocates CPU to one of them.</p>\n<p>Short-term schedulers, also known as dispatchers, make the decision of which process to execute next. Short-term schedulers are faster than long-term schedulers.</p>\n<h2>Medium Term Scheduler</h2>\n<p>Medium-term scheduling is a part of <b>swapping</b>. It removes the processes from the memory. It reduces the degree of multiprogramming. The medium-term scheduler is in-charge of handling the swapped out-processes.</p>\n<p>A running process may become suspended if it makes an I/O request. A suspended processes cannot make any progress towards completion. In this condition, to remove the process from memory and make space for other processes, the suspended process is moved to the secondary storage. This process is called <b>swapping</b>, and the process is said to be swapped out or rolled out. Swapping may be necessary to improve the process mix.</p>\n<h2>Comparison among Scheduler</h2>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">Long-Term Scheduler</th>\n<th style=\"text-align:center\">Short-Term Scheduler</th>\n<th style=\"text-align:center\">Medium-Term Scheduler</th>\n</tr>\n<tr>\n<td>1</td>\n<td>It is a job scheduler</td>\n<td>It is a CPU scheduler</td>\n<td>It is a process swapping scheduler.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Speed is lesser than short term scheduler</td>\n<td>Speed is fastest among other two</td>\n<td>Speed is in between both short and long term scheduler.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>It controls the degree of multiprogramming</td>\n<td>It provides lesser control over degree of multiprogramming</td>\n<td>It reduces the degree of multiprogramming.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>It is almost absent or minimal in time sharing system</td>\n<td>It is also minimal in time sharing system</td>\n<td>It is a part of Time sharing systems.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>It selects processes from pool and loads them into memory for execution</td>\n<td>It selects those processes which are ready to execute</td>\n<td>It can re-introduce the process into memory and execution can be continued.</td>\n</tr>\n</table>\n<h2>Context Switch</h2>\n<p>A context switch is the mechanism to store and restore the state or context of a CPU in Process Control block so that a process execution can be resumed from the same point at a later time. Using this technique, a context switcher enables multiple processes to share a single CPU. Context switching is an essential part of a multitasking operating system features.</p>\n<p>When the scheduler switches the CPU from executing one process to execute another, the state from the current running process is stored into the process control block. After this, the state for the process to run next is loaded from its own PCB and used to set the PC, registers, etc. At that point, the second process can start executing.</p>\n<img alt=\"Process Context Switch\" src=\"/operating_system/images/context_switch.jpg\"/>\n<p>Context switches are computationally intensive since register and memory state must be saved and restored. To avoid the amount of context switching time, some hardware systems employ two or more sets of processor registers. When the process is switched, the following information is stored for later use.</p>\n<ul class=\"list\">\n<li>Program Counter</li>\n<li>Scheduling information</li>\n<li>Base and limit register value</li>\n<li>Currently used register</li>\n<li>Changed State</li>\n<li>I/O State information</li>\n<li>Accounting information</li>\n</ul>\n<h1>Operating System Scheduling algorithms</h1>\n<p>A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are six popular process scheduling algorithms which we are going to discuss in this chapter \u2212</p>\n<ul class=\"list\">\n<li>First-Come, First-Served (FCFS) Scheduling</li>\n<li>Shortest-Job-Next (SJN) Scheduling</li>\n<li>Priority Scheduling</li>\n<li>Shortest Remaining Time</li>\n<li>Round Robin(RR) Scheduling</li>\n<li>Multiple-Level Queues Scheduling</li>\n</ul>\n<p>These algorithms are either <b>non-preemptive or preemptive</b>. Non-preemptive\nalgorithms are designed so that once a process enters the running state, it cannot be preempted until it completes its allotted time, whereas the preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state.</p>\n<h2>First Come First Serve (FCFS)</h2>\n<ul class=\"list\">\n<li>Jobs are executed on first come, first serve basis.</li>\n<li>It is a non-preemptive, pre-emptive scheduling algorithm.</li>\n<li>Easy to understand and implement.</li>\n<li>Its implementation is based on FIFO queue.</li>\n<li>Poor in performance as average wait time is high.</li>\n</ul>\n<img alt=\"First Come First Serve Scheduling Algorithm\" src=\"/operating_system/images/fcfs.jpg\"/>\n<p><b>Wait time</b> of each process is as follows \u2212</p>\n<table class=\"table table-bordered\" style=\"text-align:center\">\n<tr>\n<th style=\"width:10%;\">Process</th>\n<th style=\"text-align:center\">Wait Time : Service Time - Arrival Time</th>\n</tr>\n<tr>\n<td>P0</td>\n<td>0 - 0 = 0</td>\n</tr>\n<tr>\n<td>P1</td>\n<td>5 - 1 = 4</td>\n</tr>\n<tr>\n<td>P2</td>\n<td>8 - 2 = 6</td>\n</tr>\n<tr>\n<td>P3</td>\n<td>16 - 3 = 13</td>\n</tr>\n</table>\n<p>Average Wait Time: (0+4+6+13) / 4 = 5.75</p>\n<h2>Shortest Job Next (SJN)</h2>\n<ul class=\"list\">\n<li><p>This is also known as <b>shortest job first</b>, or SJF</p></li>\n<li><p>This is a non-preemptive, pre-emptive scheduling algorithm.</p></li>\n<li><p>Best approach to minimize waiting time.</p></li>\n<li><p>Easy to implement in Batch systems where required CPU time is known in advance.</p></li>\n<li><p>Impossible to implement in interactive systems where required CPU time is not known.</p></li>\n<li><p>The processer should know in advance how much time process will take.</p></li>\n</ul>\n<img alt=\"Shortest Job First Scheduling Algorithm\" src=\"/operating_system/images/sjf.jpg\"/>\n<p><b>Wait time</b> of each process is as follows \u2212</p>\n<table class=\"table table-bordered\" style=\"text-align:center\">\n<tr>\n<th style=\"width:10%; text-align:center\">Process</th>\n<th style=\"text-align:center\">Wait Time : Service Time - Arrival Time</th>\n</tr>\n<tr>\n<td>P0</td>\n<td>3 - 0 = 3</td>\n</tr>\n<tr>\n<td>P1</td>\n<td>0 - 0 = 0</td>\n</tr>\n<tr>\n<td>P2</td>\n<td>16 - 2 = 14</td>\n</tr>\n<tr>\n<td>P3</td>\n<td>8 - 3 = 5</td>\n</tr>\n</table>\n<p>Average Wait Time: (3+0+14+5) / 4 = 5.50</p>\n<h2>Priority Based Scheduling</h2>\n<ul class=\"list\">\n<li><p>Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems.</p></li>\n<li><p>Each process is assigned a priority. Process with highest priority is to be executed first and so on.</p></li>\n<li><p>Processes with same priority are executed on first come first served basis.</p></li>\n<li><p>Priority can be decided based on memory requirements, time requirements or any other resource requirement.</p></li>\n</ul>\n<img alt=\"Priority Scheduling Algorithm\" src=\"/operating_system/images/priority_scheduling.jpg\"/>\n<p><b>Wait time</b> of each process is as follows \u2212</p>\n<table class=\"table table-bordered\" style=\"text-align:center\">\n<tr>\n<th style=\"width:10%; text-align:center\">Process</th>\n<th style=\"text-align:center\">Wait Time : Service Time - Arrival Time</th>\n</tr>\n<tr>\n<td>P0</td>\n<td>9 - 0 = 9</td>\n</tr>\n<tr>\n<td>P1</td>\n<td>6 - 1 = 5</td>\n</tr>\n<tr>\n<td>P2</td>\n<td>14 - 2 = 12</td>\n</tr>\n<tr>\n<td>P3</td>\n<td>0 - 0 = 0</td>\n</tr>\n</table>\n<p>Average Wait Time: (9+5+12+0) / 4 = 6.5</p>\n<h2>Shortest Remaining Time</h2>\n<ul class=\"list\">\n<li><p>Shortest remaining time (SRT) is the preemptive version of the SJN algorithm.</p></li>\n<li><p>The processor is allocated to the job closest to completion but it can be preempted by a newer ready job with shorter time to completion.</p></li>\n<li><p>Impossible to implement in interactive systems where required CPU time is not known.</p></li>\n<li><p>It is often used in batch environments where short jobs need to give preference.</p></li>\n</ul>\n<h2>Round Robin Scheduling</h2>\n<ul class=\"list\">\n<li><p>Round Robin is the preemptive process scheduling algorithm.</p></li>\n<li><p>Each process is provided a fix time to execute, it is called a <b>quantum</b>.</p></li>\n<li><p>Once a process is executed for a given time period, it is preempted and other process executes for a given time period.</p></li>\n<li><p>Context switching is used to save states of preempted processes.</p></li>\n</ul>\n<img alt=\"Round Robin Scheduling Algorithm\" src=\"/operating_system/images/round_robin.jpg\"/>\n<p><b>Wait time</b> of each process is as follows \u2212</p>\n<table class=\"table table-bordered\" style=\"text-align:center\">\n<tr>\n<th style=\"width:10%; text-align:center\">Process</th>\n<th style=\"text-align:center\">Wait Time : Service Time - Arrival Time</th>\n</tr>\n<tr>\n<td>P0</td>\n<td>(0 - 0) + (12 - 3) = 9</td>\n</tr>\n<tr>\n<td>P1</td>\n<td>(3 - 1) = 2</td>\n</tr>\n<tr>\n<td>P2</td>\n<td>(6 - 2) + (14 - 9) + (20 - 17) = 12</td>\n</tr>\n<tr>\n<td>P3</td>\n<td>(9 - 3) + (17 - 12) = 11</td>\n</tr>\n</table>\n<p>Average Wait Time: (9+2+12+11) / 4 = 8.5</p>\n<h2>Multiple-Level Queues Scheduling</h2>\n<p>Multiple-level queues are not an independent scheduling algorithm. They make use of other existing algorithms to group and schedule jobs with common characteristics.</p>\n<ul class=\"list\">\n<li>Multiple queues are maintained for processes with common characteristics.</li>\n<li>Each queue can have its own scheduling algorithms.</li>\n<li>Priorities are assigned to each queue.</li>\n</ul>\n<p>For example, CPU-bound jobs can be scheduled in one queue and all I/O-bound jobs in another queue. The Process Scheduler then alternately selects jobs from each queue and assigns them to the CPU based on the algorithm assigned to the queue.</p>\n<h1>Operating System - Multi-Threading</h1>\n<h2>What is Thread?</h2>\n<p>A thread is a flow of execution through the process code, with its own program counter that keeps track of which instruction to execute next, system registers which hold its current working variables, and a stack which contains the execution history.</p>\n<p>A thread shares with its peer threads few information like code segment, data segment and open files. When one thread alters a code segment memory item, all other threads see that.</p>\n<p>A thread is also called a <b>lightweight process</b>. Threads provide a way to improve application performance through parallelism. Threads represent a software approach to improving performance of operating system by reducing the overhead thread is equivalent to a classical process.</p>\n<p>Each thread belongs to exactly one process and no thread can exist outside a process. Each thread represents a separate flow of control. Threads have been successfully used in implementing network servers and web server. They also provide a suitable foundation for parallel execution of applications on shared memory multiprocessors. The following figure shows the working of a single-threaded and a multithreaded process.</p>\n<img alt=\"Single vs Multithreaded Process\" src=\"/operating_system/images/thread_processes.jpg\"/>\n<h2>Difference between Process and Thread</h2>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"width:45%;\">Process</th>\n<th>Thread</th>\n</tr>\n<tr>\n<td>1</td>\n<td>Process is heavy weight or resource intensive.</td>\n<td>Thread is light weight, taking lesser resources than a process.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Process switching needs interaction with operating system.</td>\n<td>Thread switching does not need to interact with operating system.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>In multiple processing environments, each process executes the same code but has its own memory and file resources.</td>\n<td>All threads can share same set of open files, child processes.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>If one process is blocked, then no other process can execute until the first process is unblocked.</td>\n<td>While one thread is blocked and waiting, a second thread in the same task can run.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Multiple processes without using threads use more resources.</td>\n<td>Multiple threaded processes use fewer resources.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>In multiple processes each process operates independently of the others.</td>\n<td>One thread can read, write or change another thread's data.</td>\n</tr>\n</table>\n<h2>Advantages of Thread</h2>\n<ul class=\"list\">\n<li>Threads minimize the context switching time.</li>\n<li>Use of threads provides concurrency within a process.</li>\n<li>Efficient communication.</li>\n<li>It is more economical to create and context switch threads.</li>\n<li>Threads allow utilization of multiprocessor architectures to a greater scale and efficiency.</li>\n</ul>\n<h2>Types of Thread</h2>\n<p>Threads are implemented in following two ways \u2212</p>\n<ul class=\"list\">\n<li><p><b>User Level Threads</b> \u2212 User managed threads.</p></li>\n<li><p><b>Kernel Level Threads</b> \u2212 Operating System managed threads acting on kernel, an operating system core.</p></li>\n</ul>\n<h2>User Level Threads</h2>\n<p>In this case, the thread management kernel is not aware of the existence of threads. The thread library contains code for creating and destroying threads, for passing message and data between threads, for scheduling thread execution and for saving and restoring thread contexts. The application starts with a single thread.</p>\n<img alt=\"User level thread\" src=\"/operating_system/images/user_threads.jpg\"/>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li>Thread switching does not require Kernel mode privileges.</li>\n<li>User level thread can run on any operating system.</li>\n<li>Scheduling can be application specific in the user level thread.</li>\n<li>User level threads are fast to create and manage.</li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li>In a typical operating system, most system calls are blocking.</li>\n<li>Multithreaded application cannot take advantage of multiprocessing.</li>\n</ul>\n<h2>Kernel Level Threads</h2>\n<p>In this case, thread management is done by the Kernel. There is no thread management code in the application area. Kernel threads are supported directly by the operating system. Any application can be programmed to be multithreaded. All of the threads within an application are supported within a single process.</p>\n<p>The Kernel maintains context information for the process as a whole and for individuals threads within the process. Scheduling by the Kernel is done on a thread basis. The Kernel performs thread creation, scheduling and management in Kernel space. Kernel threads are generally slower to create and manage than the user threads.</p>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li>Kernel can simultaneously schedule multiple threads from the same process on multiple processes.</li>\n<li>If one thread in a process is blocked, the Kernel can schedule another thread of the same process.</li>\n<li>Kernel routines themselves can be multithreaded.</li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li>Kernel threads are generally slower to create and manage than the user threads.</li>\n<li>Transfer of control from one thread to another within the same process requires a mode switch to the Kernel.</li>\n</ul>\n<h2>Multithreading Models</h2>\n<p>Some operating system provide a combined user level thread and Kernel level thread facility. Solaris is a good example of this combined approach. In a combined system, multiple threads within the same application can run in parallel on multiple processors and a blocking system call need not block the entire process. Multithreading models are three types</p>\n<ul class=\"list\">\n<li>Many to many relationship.</li>\n<li>Many to one relationship.</li>\n<li>One to one relationship.</li>\n</ul>\n<h2>Many to Many Model</h2>\n<p>The many-to-many model multiplexes any number of user threads onto an equal or smaller number of kernel threads.</p>\n<p>The following diagram shows the many-to-many threading model where 6 user level threads are multiplexing with 6 kernel level threads. In this model, developers can create as many user threads as necessary and the corresponding Kernel threads can run in parallel on a multiprocessor machine. This model provides the best accuracy on concurrency and when a thread performs a blocking system call, the kernel can schedule another thread for execution.</p>\n<img alt=\"Many to many thread model\" src=\"/operating_system/images/many_to_many.jpg\"/>\n<h2>Many to One Model</h2>\n<p>Many-to-one model maps many user level threads to one Kernel-level thread. Thread management is done in user space by the thread library. When thread makes a blocking system call, the entire process will be blocked. Only one thread can access the Kernel at a time, so multiple threads are unable to run in parallel on multiprocessors.</p>\n<p>If the user-level thread libraries are implemented in the operating system in such a way that the system does not support them, then the Kernel threads use the many-to-one relationship modes.</p>\n<img alt=\"Many to one thread model\" src=\"/operating_system/images/many_to_one.jpg\"/>\n<h2>One to One Model</h2>\n<p>There is one-to-one relationship of user-level thread to the kernel-level thread. This model provides more concurrency than the many-to-one model. It also allows another thread to run when a thread makes a blocking system call. It supports multiple threads to execute in parallel on microprocessors.</p>\n<p>Disadvantage of this model is that creating user thread requires the corresponding Kernel thread. OS/2, windows NT and windows 2000 use one to one relationship model.</p>\n<img alt=\"One to one thread model\" src=\"/operating_system/images/one_to_one.jpg\"/>\n<h2>Difference between User-Level &amp; Kernel-Level Thread</h2>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%; text-align:center\">S.N.</th>\n<th style=\"width:45%; text-align:center\">User-Level Threads</th>\n<th style=\"width:45%; text-align:center\">Kernel-Level Thread</th>\n</tr>\n<tr>\n<td>1</td>\n<td>User-level threads are faster to create and manage.</td>\n<td>Kernel-level threads are slower to create and manage.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Implementation is by a thread library at the user level.</td>\n<td>Operating system supports creation of Kernel threads.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>User-level thread is generic and can run on any operating system.</td>\n<td>Kernel-level thread is specific to the operating system.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Multi-threaded applications cannot take advantage of multiprocessing.</td>\n<td>Kernel routines themselves can be multithreaded.</td>\n</tr>\n</table>\n<h1>Operating System - Memory Management</h1>\n<p>Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or unallocated and correspondingly it updates the status.</p>\n<p>This tutorial will teach you basic concepts related to Memory Management.</p>\n<h2>Process Address Space</h2>\n<p>The process address space is the set of logical addresses that a process references in its code. For example, when 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes.</p>\n<p>The operating system takes care of mapping the logical addresses to physical addresses at the time of memory allocation to the program. There are three types of addresses used in a program before and after memory is allocated \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th>S.N.</th>\n<th style=\"text-align:center\">Memory Addresses &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td>\n<p><b>Symbolic addresses</b></p>\n<p>The addresses used in a source code. The variable names, constants, and instruction labels are the basic elements of the symbolic address space.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td>\n<p><b>Relative addresses</b></p>\n<p>At the time of compilation, a compiler converts symbolic addresses into relative\naddresses.</p>\n</td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Physical addresses</b></p>\n<p>The loader generates these addresses at the time when a program is loaded into main memory.</p>\n</td>\n</tr>\n</table>\n<p>Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. Virtual and physical addresses differ in execution-time address-binding scheme.</p>\n<p>The set of all logical addresses generated by a program is referred to as a <b>logical address space</b>. The set of all physical addresses corresponding to these logical addresses is referred to as a <b>physical address space.</b></p>\n<p>The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device. MMU uses following mechanism to convert virtual address to physical address.</p>\n<ul class=\"list\">\n<li><p>The value in the base register is added to every address generated by a user process, which is treated as offset at the time it is sent to memory. For example, if the base register value is 10000, then an attempt by the user to use address location 100 will be dynamically reallocated to location 10100.</p></li>\n<li><p>The user program deals with virtual addresses; it never sees the real physical addresses.</p></li>\n</ul>\n<h2>Static vs Dynamic Loading</h2>\n<p>The choice between Static or Dynamic Loading is to be made at the time of computer program being developed. If you have to load your program statically, then at the time of compilation, the complete programs will be compiled and linked without leaving any external program or module dependency. The linker combines the object program with other necessary object modules into an absolute program, which also includes logical addresses.</p>\n<p>If you are writing a Dynamically loaded program, then your compiler will compile the program and for all the modules which you want to include dynamically, only references will be provided and rest of the work will be done at the time of execution.</p>\n<p>At the time of loading, with <b>static loading</b>, the absolute program (and data) is loaded into memory in order for execution to start.</p>\n<p>If you are using <b>dynamic loading</b>, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program.</p>\n<h2>Static vs Dynamic Linking</h2>\n<p>As explained above, when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.</p>\n<p>When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking. Dynamic Link Libraries (DLL) in Windows and Shared Objects in Unix are good examples of dynamic libraries.</p>\n<h2>Swapping</h2>\n<p>Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory.</p>\n<p>Though performance is usually affected by swapping process but it helps in running multiple and big processes in parallel and that's the reason <b>Swapping is also known as a technique for memory compaction</b>.</p>\n<img alt=\"Process Swapping\" src=\"/operating_system/images/process_swapping.jpg\"/>\n<p>The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, as well as the time the process takes to regain main memory.</p>\n<p>Let us assume that the user process is of size 2048KB and on a standard hard disk where swapping will take place has a data transfer rate around 1 MB per second. The actual transfer of the 1000K process to or from memory will take</p>\n<pre class=\"result notranslate\">\n2048KB / 1024KB per second\n= 2 seconds\n= 2000 milliseconds\n</pre>\n<p>Now considering in and out time, it will take complete 4000 milliseconds plus other overhead where the process competes to regain main memory.</p>\n<h2>Memory Allocation</h2>\n<p>Main memory usually has two partitions \u2212</p>\n<ul class=\"list\">\n<li><p><b>Low Memory</b> \u2212 Operating system resides in this memory.</p></li>\n<li><p><b>High Memory</b> \u2212 User processes are held in high memory.</p></li>\n</ul>\n<p>Operating system uses the following memory allocation mechanism.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th>S.N.</th>\n<th style=\"text-align:center\">Memory Allocation &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Single-partition allocation</b></p>\n<p>In this type of allocation, relocation-register scheme is used to protect user processes from each other, and from changing operating-system code and data. Relocation register contains value of smallest physical address whereas limit register contains range of logical addresses. Each logical address must be less than the limit register.</p></td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Multiple-partition allocation</b></p>\n<p>In this type of allocation, main memory is divided into a number of fixed-sized\npartitions where each partition should contain only one process. When a partition\nis free, a process is selected from the input queue and is loaded into the free\npartition. When the process terminates, the partition becomes available for\nanother process.</p></td>\n</tr>\n</table>\n<h2>Fragmentation</h2>\n<p>As processes are loaded and removed from memory, the free memory space is broken into little pieces. It happens after sometimes that processes cannot be allocated to memory blocks considering their small size and memory blocks remains unused. This problem is known as Fragmentation.</p>\n<p>Fragmentation is of two types \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th>S.N.</th>\n<th style=\"text-align:center\">Fragmentation &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>External fragmentation</b></p>\n<p>Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used.</p></td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Internal fragmentation</b></p>\n<p>Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.</p></td>\n</tr>\n</table>\n<p>The following diagram shows how fragmentation can cause waste of memory and a compaction technique can be used to create more free memory out of fragmented memory \u2212</p>\n<img alt=\"Memory Fragmentation\" src=\"/operating_system/images/memory_fragmentation.jpg\"/>\n<p>External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction feasible, relocation should be dynamic.</p>\n<p>The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.</p>\n<h2>Paging</h2>\n<p>A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard that's set up to emulate the computer's RAM. Paging technique plays an important role in implementing virtual memory.</p>\n<p>Paging is a memory management technique in which process address space is broken into blocks of the same size called <b>pages</b> (size is power of 2, between 512 bytes and 8192 bytes). The size of the process is measured in the number of pages.</p>\n<p>Similarly, main memory is divided into small fixed-sized blocks of (physical) memory called <b>frames</b> and the size of a frame is kept the same as that of a page to have optimum utilization of the main memory and to avoid external fragmentation.</p>\n<img alt=\"Paging\" src=\"/operating_system/images/paging.jpg\"/>\n<h3>Address Translation</h3>\n<p>Page address is called <b>logical address</b> and represented by <b>page number</b> and the <b>offset</b>.</p>\n<pre class=\"result notranslate\">\nLogical Address = Page number + page offset\n</pre>\n<p>Frame address is called <b>physical address</b> and represented by a <b>frame number</b> and the <b>offset</b>.</p>\n<pre class=\"result notranslate\">\nPhysical Address = Frame number + page offset\n</pre>\n<p>A data structure called <b>page map table</b> is used to keep track of the relation between a page of a process to a frame in physical memory.</p>\n<img alt=\"Page Map Table\" src=\"/operating_system/images/page_map_table.jpg\"/>\n<p>When the system allocates a frame to any page, it translates this logical address into a physical address and create entry into the page table to be used throughout execution of the program.</p>\n<p>When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program.</p>\n<p>This process continues during the whole execution of the program where the OS keeps removing idle pages from the main memory and write them onto the secondary memory and bring them back when required by the program.</p>\n<h3>Advantages and Disadvantages of Paging</h3>\n<p>Here is a list of advantages and disadvantages of paging \u2212</p>\n<ul class=\"list\">\n<li><p>Paging reduces external fragmentation, but still suffer from internal fragmentation.</p></li>\n<li><p>Paging is simple to implement and assumed as an efficient memory management technique.</p></li>\n<li><p>Due to equal size of the pages and frames, swapping becomes very easy.</p></li>\n<li><p>Page table requires extra memory space, so may not be good for a system having small RAM.</p></li>\n</ul>\n<h2>Segmentation</h2>\n<p>Segmentation is a memory management technique in which each job is divided into several segments of different sizes, one for each module that contains pieces that perform related functions. Each segment is actually a different logical address space of the program.</p>\n<p>When a process is to be executed, its corresponding segmentation are loaded into non-contiguous memory though every segment is loaded into a contiguous block of available memory.</p>\n<p>Segmentation memory management works very similar to paging but here segments are of variable-length where as in paging pages are of fixed size.</p>\n<p>A program segment contains the program's main function, utility functions, data structures, and so on. The operating system maintains a <b>segment map table</b> for every process and a list of free memory blocks along with segment numbers, their size and corresponding memory locations in main memory. For each segment, the table stores the starting address of the segment and the length of the segment. A reference to a memory location includes a value that identifies a segment and an offset.</p>\n<img alt=\"Segment Map Table\" src=\"/operating_system/images/segment_map_table.jpg\"/>\n<h1>Operating System - Virtual Memory</h1>\n<p>A computer can address more memory than the amount physically installed on the system. This extra memory is actually called <b>virtual memory</b> and it is a section of a hard disk that's set up to emulate the computer's RAM.</p>\n<p>The main visible advantage of this scheme is that programs can be larger than physical memory. Virtual memory serves two purposes. First, it allows us to extend the use of physical memory by using disk. Second, it allows us to have memory protection, because each virtual address is translated to a physical address.</p>\n<p>Following are the situations, when entire program is not required to be loaded fully in main memory.</p>\n<ul class=\"list\">\n<li><p>User written error handling routines are used only when an error occurred in the data or computation.</p></li>\n<li><p>Certain options and features of a program may be used rarely.</p></li>\n<li><p>Many tables are assigned a fixed amount of address space even though only a small amount of the table is actually used.</p></li>\n<li><p>The ability to execute a program that is only partially in memory would counter many benefits.</p></li>\n<li><p>Less number of I/O would be needed to load or swap each user program into memory.</p></li>\n<li><p>A program would no longer be constrained by the amount of physical memory that is available.</p></li>\n<li><p>Each user program could take less physical memory, more programs could be run the same time, with a corresponding increase in CPU utilization and throughput.</p></li>\n</ul>\n<p>Modern microprocessors intended for general-purpose use, a memory management unit, or MMU, is built into the hardware. The MMU's job is to translate virtual addresses into physical addresses. A basic example is given below \u2212</p>\n<img alt=\"Virtual Memory\" src=\"/operating_system/images/virtual_memory.jpg\"/>\n<p>Virtual memory is commonly implemented by demand paging. It can also be implemented in a segmentation system. Demand segmentation can also be used to provide virtual memory.</p>\n<h2>Demand Paging</h2>\n<p>A demand paging system is quite similar to a paging system with swapping where processes reside in secondary memory and pages are loaded only on demand, not in advance. When a context switch occurs, the operating system does not copy any of the old program\u2019s pages out to the disk or any of the new program\u2019s pages into the main memory Instead, it just begins executing the new program after loading the first page and fetches that program\u2019s pages as they are referenced.</p>\n<img alt=\"Demand Paging\" src=\"/operating_system/images/demand_paging.jpg\"/>\n<p>While executing a program, if the program references a page which is not available in the main memory because it was swapped out a little ago, the processor treats this invalid memory reference as a <b>page fault</b> and transfers control from the program to the operating system to demand the page back into the memory.</p>\n<h3>Advantages</h3>\n<p>Following are the advantages of Demand Paging \u2212</p>\n<ul class=\"list\">\n<li>Large virtual memory.</li>\n<li>More efficient use of memory.</li>\n<li>There is no limit on degree of multiprogramming.</li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li><p>Number of tables and the amount of processor overhead for handling page interrupts are greater than in the case of the simple paged management techniques.</p></li>\n</ul>\n<h2>Page Replacement Algorithm</h2>\n<p>Page replacement algorithms are the techniques using which an Operating System decides which memory pages to swap out, write to disk when a page of memory needs to be allocated. Paging happens whenever a page fault occurs and a free page cannot be used for allocation purpose accounting to reason that pages are not available or the number of free pages is lower than required pages.</p>\n<p>When the page that was selected for replacement and was paged out, is referenced again, it has to read in from disk, and this requires for I/O completion. This process determines the quality of the page replacement algorithm: the lesser the time waiting for page-ins, the better is the algorithm.</p>\n<p>A page replacement algorithm looks at the limited information about accessing the pages provided by hardware, and tries to select which pages should be replaced to minimize the total number of page misses, while balancing it with the costs of primary storage and processor time of the algorithm itself. There are many different page replacement algorithms. We evaluate an algorithm by running it on a particular string of memory reference and computing the number of page faults,</p>\n<h2>Reference String</h2>\n<p>The string of memory references is called reference string. Reference strings are generated artificially or by tracing a given system and recording the address of each memory reference. The latter choice produces a large number of data, where we note two things.</p>\n<ul class=\"list\">\n<li><p>For a given page size, we need to consider only the page number, not the entire address.</p></li>\n<li><p>If we have a reference to a page <b>p</b>, then any immediately following references to page <b>p</b> will never cause a page fault. Page p will be in memory after the first reference; the immediately following references will not fault.</p></li>\n<li><p>For example, consider the following sequence of addresses \u2212 123,215,600,1234,76,96</p></li>\n<li><p>If page size is 100, then the reference string is 1,2,6,12,0,0</p></li>\n</ul>\n<h2>First In First Out (FIFO) algorithm</h2>\n<ul class=\"list\">\n<li><p>Oldest page in main memory is the one which will be selected for replacement.</p></li>\n<li><p>Easy to implement, keep a list, replace pages from the tail and add new pages at the head.</p></li>\n</ul>\n<img alt=\"First In First Out\" src=\"/operating_system/images/fifo.jpg\"/>\n<h2>Optimal Page algorithm</h2>\n<ul class=\"list\">\n<li><p>An optimal page-replacement algorithm has the lowest page-fault rate of all algorithms. An optimal page-replacement algorithm exists, and has been called OPT or MIN.</p></li>\n<li><p>Replace the page that will not be used for the longest period of time. Use the time when a page is to be used.</p></li>\n</ul>\n<img alt=\"Optimal page replacement\" src=\"/operating_system/images/opr.jpg\"/>\n<h2>Least Recently Used (LRU) algorithm</h2>\n<ul class=\"list\">\n<li><p>Page which has not been used for the longest time in main memory is the one which will be selected for replacement.</p></li>\n<li><p>Easy to implement, keep a list, replace pages by looking back into time.</p></li>\n</ul>\n<img alt=\"Least Recently Used\" src=\"/operating_system/images/lru.jpg\"/>\n<h2>Page Buffering algorithm</h2>\n<ul class=\"list\">\n<li>To get a process start quickly, keep a pool of free frames.</li>\n<li>On page fault, select a page to be replaced.</li>\n<li>Write the new page in the frame of free pool, mark the page table and restart the process.</li>\n<li>Now write the dirty page out of disk and place the frame holding replaced page in free pool.</li>\n</ul>\n<h2>Least frequently Used(LFU) algorithm</h2>\n<ul class=\"list\">\n<li><p>The page with the smallest count is the one which will be selected for replacement.</p></li>\n<li><p>This algorithm suffers from the situation in which a page is used heavily during the initial phase of a process, but then is never used again.</p></li>\n</ul>\n<h2>Most frequently Used(MFU) algorithm</h2>\n<ul class=\"list\">\n<li><p>This algorithm is based on the argument that the page with the smallest count was probably just brought in and has yet to be used.</p></li>\n</ul>\n<h1>Operating System - I/O Hardware</h1>\n<p>One of the important jobs of an Operating System is to manage various I/O devices including mouse, keyboards, touch pad, disk drives, display adapters, USB devices, Bit-mapped screen, LED, Analog-to-digital converter, On/off switch, network connections, audio I/O, printers etc.</p>\n<p>An I/O system is required to take an application I/O request and send it to the physical device, then take whatever response comes back from the device and send it to the application. I/O devices can be divided into two categories \u2212</p>\n<ul class=\"list\">\n<li><p><b>Block devices</b> \u2212 A block device is one with which the driver communicates by sending entire blocks of data. For example, Hard disks, USB cameras, Disk-On-Key etc.</p></li>\n<li><p><b>Character devices</b> \u2212 A character device is one with which the driver communicates by sending and receiving single characters (bytes, octets). For example, serial ports, parallel ports, sounds cards etc</p></li>\n</ul>\n<h2>Device Controllers</h2>\n<p>Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices.</p>\n<p>The Device Controller works like an interface between a device and a device driver. I/O units (Keyboard, mouse, printer, etc.) typically consist of a mechanical component and an electronic component where electronic component is called the device controller.</p>\n<p>There is always a device controller and a device driver for each device to communicate with the Operating Systems. A device controller may be able to handle multiple devices. As an interface its main task is to convert serial bit stream to block of bytes, perform error correction as necessary.</p>\n<p>Any device connected to the computer is connected by a plug and socket, and the socket is connected to a device controller. Following is a model for connecting the CPU, memory, controllers, and I/O devices where CPU and device controllers all use a common bus for communication.</p>\n<img alt=\"Device Controllers\" src=\"/operating_system/images/device_controllers.jpg\"/>\n<h2>Synchronous vs asynchronous I/O</h2>\n<ul class=\"list\">\n<li><p><b>Synchronous I/O</b> \u2212 In this scheme CPU execution waits while I/O proceeds</p></li>\n<li><p><b>Asynchronous I/O</b> \u2212 I/O proceeds concurrently with CPU execution</p></li>\n</ul>\n<h2>Communication to I/O Devices</h2>\n<p>The CPU must have a way to pass information to and from an I/O device. There are three approaches available to communicate with the CPU and Device.</p>\n<ul class=\"list\">\n<li>Special Instruction I/O</li>\n<li>Memory-mapped I/O</li>\n<li>Direct memory access (DMA)</li>\n</ul>\n<h3>Special Instruction I/O</h3>\n<p>This uses CPU instructions that are specifically made for controlling I/O devices. These instructions typically allow data to be sent to an I/O device or read from an I/O device.</p>\n<h3>Memory-mapped I/O</h3>\n<p>When using memory-mapped I/O, the same address space is shared by memory and I/O devices. The device is connected directly to certain main memory locations so that I/O device can transfer block of data to/from memory without going through CPU.</p>\n<img alt=\"Memory-mapped I/O\" src=\"/operating_system/images/memory_mapped_io.jpg\"/>\n<p>While using memory mapped IO, OS allocates buffer in memory and informs I/O device to use that buffer to send data to the CPU. I/O device operates asynchronously with CPU, interrupts CPU when finished.</p>\n<p>The advantage to this method is that every instruction which can access memory can be used to manipulate an I/O device. Memory mapped IO is used for most high-speed I/O devices like disks, communication interfaces.</p>\n<h2>Direct Memory Access (DMA)</h2>\n<p>Slow devices like keyboards will generate an interrupt to the main CPU after each byte is transferred. If a fast device such as a disk generated an interrupt for each byte, the operating system would spend most of its time handling these interrupts. So a typical computer uses direct memory access (DMA) hardware to reduce this overhead.</p>\n<p>Direct Memory Access (DMA) means CPU grants I/O module authority to read from or write to memory without involvement. DMA module itself controls exchange of data between main memory and the I/O device. CPU is only involved at the beginning and end of the transfer and interrupted only after entire block has been transferred.</p>\n<p>Direct Memory Access needs a special hardware called DMA controller (DMAC) that manages the data transfers and arbitrates access to the system bus. The controllers are programmed with source and destination pointers (where to read/write the data), counters to track the number of transferred bytes, and settings, which includes I/O and memory types, interrupts and states for the CPU cycles.</p>\n<img alt=\"DMA\" src=\"/operating_system/images/dma.jpg\"/>\n<p>The operating system uses the DMA hardware as follows \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">Step</th>\n<th style=\"text-align:center\">Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td>Device driver is instructed to transfer disk data to a buffer address X.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Device driver then instruct disk controller to transfer data to buffer.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Disk controller starts DMA transfer.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Disk controller sends each byte to DMA controller.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DMA controller transfers bytes to buffer, increases the memory address, decreases the counter C until C becomes zero.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>When C becomes zero, DMA interrupts CPU to signal transfer completion.</td>\n</tr>\n</table>\n<h2>Polling vs Interrupts I/O</h2>\n<p>A computer must have a way of detecting the arrival of any type of input. There are two ways that this can happen, known as <b>polling</b> and <b>interrupts</b>. Both of these techniques allow the processor to deal with events that can happen at any time and that are not related to the process it is currently running.</p>\n<h3>Polling I/O</h3>\n<p>Polling is the simplest way for an I/O device to communicate with the processor. The process of periodically checking status of the device to see if it is time for the next I/O operation, is called polling. The I/O device simply puts the information in a Status register, and the processor must come and get the information.</p>\n<p>Most of the time, devices will not require attention and when one does it will have to wait until it is next interrogated by the polling program. This is an inefficient method and much of the processors time is wasted on unnecessary polls.</p>\n<p>Compare this method to a teacher continually asking every student in a class, one after another, if they need help. Obviously the more efficient method would be for a student to inform the teacher whenever they require assistance.</p>\n<h3>Interrupts I/O</h3>\n<p>An alternative scheme for dealing with I/O is the interrupt-driven method. An interrupt is a signal to the microprocessor from a device that requires attention.</p>\n<p>A device controller puts an interrupt signal on the bus when it needs CPU\u2019s attention when CPU receives an interrupt, It saves its current state and invokes the appropriate interrupt handler using the interrupt vector (addresses of OS routines to handle various events). When the interrupting device has been dealt with, the CPU continues with its original task as if it had never been interrupted.</p>\n<h1>Operating System - I/O Softwares</h1>\n<p>I/O software is often organized in the following layers \u2212</p>\n<ul class=\"list\">\n<li><p><b>User Level Libraries</b> \u2212 This provides simple interface to the user program to perform input and output. For example, <b>stdio</b> is a library provided by C and C++ programming languages.</p></li>\n<li><p><b>Kernel Level Modules</b> \u2212 This provides device driver to interact with the device controller and device independent I/O modules used by the device drivers.</p></li>\n<li><p><b>Hardware</b> \u2212 This layer includes actual hardware and hardware controller which interact with the device drivers and makes hardware alive.</p></li>\n</ul>\n<p>A key concept in the design of I/O software is that it should be device independent where it should be possible to write programs that can access any I/O device without having to specify the device in advance. For example, a program that reads a file as input should be able to read a file on a floppy disk, on a hard disk, or on a CD-ROM, without having to modify the program for each different device.</p>\n<img alt=\"I/O Softwares\" src=\"/operating_system/images/io_software.jpg\"/>\n<h2>Device Drivers</h2>\n<p>Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices. Device drivers encapsulate device-dependent code and implement a standard interface in such a way that code contains device-specific register reads/writes. Device driver, is generally written by the device's manufacturer and delivered along with the device on a CD-ROM.</p>\n<p>A device driver performs the following jobs \u2212</p>\n<ul class=\"list\">\n<li>To accept request from the device independent software above to it.</li>\n<li>Interact with the device controller to take and give I/O and perform required error handling</li>\n<li>Making sure that the request is executed successfully</li>\n</ul>\n<p>How a device driver handles a request is as follows: Suppose a request comes to read a block N. If the driver is idle at the time a request arrives, it starts carrying out the request immediately. Otherwise, if the driver is already busy with some other request, it places the new request in the queue of pending requests.</p>\n<h2>Interrupt handlers</h2>\n<p>An interrupt handler, also known as an interrupt service routine or ISR, is a piece of software or more specifically a callback function in an operating system or more specifically in a device driver, whose execution is triggered by the reception of an interrupt.</p>\n<p>When the interrupt happens, the interrupt procedure does whatever it has to in order to handle the interrupt, updates data structures and wakes up process that was waiting for an interrupt to happen.</p>\n<p>The interrupt mechanism accepts an address \u2500 a number that selects a specific interrupt handling routine/function from a small set. In most architectures, this address is an offset stored in a table called the interrupt vector table. This vector contains the memory addresses of specialized interrupt handlers.</p>\n<h2>Device-Independent I/O Software</h2>\n<p>The basic function of the device-independent software is to perform the I/O functions that are common to all devices and to provide a uniform interface to the user-level software. Though it is difficult to write completely device independent software but we can write some modules which are common among all the devices. Following is a list of functions of device-independent I/O Software \u2212</p>\n<ul class=\"list\">\n<li>Uniform interfacing for device drivers</li>\n<li>Device naming - Mnemonic names mapped to Major and Minor device numbers</li>\n<li>Device protection</li>\n<li>Providing a device-independent block size</li>\n<li>Buffering because data coming off a device cannot be stored in final destination.</li>\n<li>Storage allocation on block devices</li>\n<li>Allocation and releasing dedicated devices</li>\n<li>Error Reporting</li>\n</ul>\n<h2>User-Space I/O Software</h2>\n<p>These are the libraries which provide richer and simplified interface to access the functionality of the kernel or ultimately interactive with the device drivers. Most of the user-level I/O software consists of library procedures with some exception like spooling system which is a way of dealing with dedicated I/O devices in a multiprogramming system.</p>\n<p>I/O Libraries (e.g., stdio) are in user-space to provide an interface to the OS resident device-independent I/O SW. For example putchar(), getchar(), printf() and scanf() are example of user level I/O library stdio available in C programming.</p>\n<h2>Kernel I/O Subsystem</h2>\n<p>Kernel I/O Subsystem is responsible to provide many services related to I/O. Following are some of the services provided.</p>\n<ul class=\"list\">\n<li><p><b>Scheduling</b> \u2212 Kernel schedules a set of I/O requests to determine a good order in which to execute them. When an application issues a blocking I/O system call, the request is placed on the queue for that device. The Kernel I/O scheduler rearranges the order of the queue to improve the overall system efficiency and the average response time experienced by the applications.</p></li>\n<li><p><b>Buffering</b> \u2212 Kernel I/O Subsystem maintains a memory area known as <b>buffer</b> that stores data while they are transferred between two devices or between a device with an application operation. Buffering is done to cope with a speed mismatch between the producer and consumer of a data stream or to adapt between devices that have different data transfer sizes.</p></li>\n<li><p><b>Caching</b> \u2212 Kernel maintains cache memory which is region of fast memory that holds copies of data. Access to the cached copy is more efficient than access to the original.</p></li>\n<li><p><b>Spooling and Device Reservation</b> \u2212 A spool is a buffer that holds output for a device, such as a printer, that cannot accept interleaved data streams. The spooling system copies the queued spool files to the printer one at a time. In some operating systems, spooling is managed by a system daemon process. In other operating systems, it is handled by an in kernel thread.</p></li>\n<li><p><b>Error Handling</b> \u2212 An operating system that uses protected memory can guard against many kinds of hardware and application errors.</p></li>\n</ul>\n<h1>Operating System - File System</h1>\n<h2>File</h2>\n<p>A file is a named collection of related information that is recorded on secondary storage such as magnetic disks, magnetic tapes and optical disks. In general, a file is a sequence of bits, bytes, lines or records whose meaning is defined by the files creator and user.</p>\n<h2>File Structure</h2>\n<p>A File Structure should be according to a required format that the operating system can understand.</p>\n<ul class=\"list\">\n<li><p>A file has a certain defined structure according to its type.</p></li>\n<li><p>A text file is a sequence of characters organized into lines.</p></li>\n<li><p>A source file is a sequence of procedures and functions.</p></li>\n<li><p>An object file is a sequence of bytes organized into blocks that are understandable by the machine.</p></li>\n<li><p>When operating system defines different file structures, it also contains the code to support these file structure. Unix, MS-DOS support minimum number of file structure.</p></li>\n</ul>\n<h2>File Type</h2>\n<p>File type refers to the ability of the operating system to distinguish different types of file such as text files source files and binary files etc. Many operating systems support many types of files. Operating system like MS-DOS and UNIX have the following types of files \u2212</p>\n<h3>Ordinary files</h3>\n<ul class=\"list\">\n<li>These are the files that contain user information.</li>\n<li>These may have text, databases or executable program.</li>\n<li>The user can apply various operations on such files like add, modify, delete or even remove the entire file.</li>\n</ul>\n<h3>Directory files</h3>\n<ul class=\"list\">\n<li>These files contain list of file names and other information related to these files.</li>\n</ul>\n<h3>Special files</h3>\n<ul class=\"list\">\n<li>These files are also known as device files.</li>\n<li>These files represent physical device like disks, terminals, printers, networks, tape drive etc.</li>\n</ul>\n<p>These files are of two types \u2212</p>\n<ul class=\"list\">\n<li><p><b>Character special files</b> \u2212 data is handled character by character as in case of terminals or printers.</p></li>\n<li><p><b>Block special files</b> \u2212 data is handled in blocks as in the  case of disks and tapes.</p></li>\n</ul>\n<h2>File Access Mechanisms</h2>\n<p>File access mechanism refers to the manner in which the records of a file may be accessed. There are several ways to access files \u2212</p>\n<ul class=\"list\">\n<li>Sequential access</li>\n<li>Direct/Random access</li>\n<li>Indexed sequential access</li>\n</ul>\n<h3>Sequential access</h3>\n<p>A sequential access is that in which the records are accessed in some sequence, i.e., the information in the file is processed in order, one record after the other. This access method is the most primitive one. Example: Compilers usually access files in this fashion.</p>\n<h3>Direct/Random access</h3>\n<ul class=\"list\">\n<li><p>Random access file organization provides, accessing the records directly.</p></li>\n<li><p>Each record has its own address on the file with by the help of which it can be directly accessed for reading or writing.</p></li>\n<li><p>The records need not be in any sequence within the file and they need not be in adjacent locations on the storage medium.</p></li>\n</ul>\n<h3>Indexed sequential access</h3>\n<ul class=\"list\">\n<li>This mechanism is built up on base of sequential access.</li>\n<li>An index is created for each file which contains pointers to various blocks.</li>\n<li>Index is searched sequentially and its pointer is used to access the file directly.</li>\n</ul>\n<h2>Space Allocation</h2>\n<p>Files are allocated disk spaces by operating system. Operating systems deploy following three main ways to allocate disk space to files.</p>\n<ul class=\"list\">\n<li>Contiguous Allocation</li>\n<li>Linked Allocation</li>\n<li>Indexed Allocation</li>\n</ul>\n<h3>Contiguous Allocation</h3>\n<ul class=\"list\">\n<li>Each file occupies a contiguous address space on disk.</li>\n<li>Assigned disk address is in linear order.</li>\n<li>Easy to implement.</li>\n<li>External fragmentation is a major issue with this type of allocation technique.</li>\n</ul>\n<h3>Linked Allocation</h3>\n<ul class=\"list\">\n<li>Each file carries a list of links to disk blocks.</li>\n<li>Directory contains link / pointer to first block of a file.</li>\n<li>No external fragmentation</li>\n<li>Effectively used in sequential access file.</li>\n<li>Inefficient in case of  direct access file.</li>\n</ul>\n<h3>Indexed Allocation</h3>\n<ul class=\"list\">\n<li>Provides solutions to problems of contiguous and linked allocation.</li>\n<li>A index block is created having all pointers to files.</li>\n<li>Each file has its own index block which stores the addresses of disk space occupied by the file.</li>\n<li>Directory contains the addresses of index blocks of files.</li>\n</ul>\n<h1>Operating System - Security</h1>\n<p>Security refers to providing a protection system to computer system resources such as CPU, memory, disk, software programs and most importantly data/information stored in the computer system. If a computer program is run by an unauthorized user, then he/she may cause severe damage to computer or data stored in it. So a computer system must be protected against unauthorized access, malicious access to system memory, viruses, worms etc. We're going to discuss following topics in this chapter.</p>\n<ul class=\"list\">\n<li>Authentication</li>\n<li>One Time passwords</li>\n<li>Program Threats</li>\n<li>System Threats</li>\n<li>Computer Security Classifications</li>\n</ul>\n<h2>Authentication</h2>\n<p>Authentication refers to identifying each user of the system and associating the executing programs with those users. It is the responsibility of the Operating System to create a protection system which ensures that a user who is running a particular program is authentic. Operating Systems generally identifies/authenticates users using following three ways \u2212</p>\n<ul class=\"list\">\n<li><p><b>Username / Password</b> \u2212 User need to enter a registered username and password with Operating system to login into the system.</p></li>\n<li><p><b>User card/key</b> \u2212 User need to punch card in card slot, or enter key generated by key generator in option provided by operating system to login into the system.</p></li>\n<li><p><b>User attribute - fingerprint/ eye retina pattern/ signature</b> \u2212 User need to pass his/her attribute via designated input device used by operating system to login into the system.</p></li>\n</ul>\n<h2>One Time passwords</h2>\n<p>One-time passwords provide additional security along with normal authentication. In One-Time Password system, a unique password is required every time user tries to login into the system. Once a one-time password is used, then it cannot be used again. One-time password are implemented in various ways.</p>\n<ul class=\"list\">\n<li><p><b>Random numbers</b> \u2212 Users are provided cards having numbers printed along with corresponding alphabets. System asks for numbers corresponding to few alphabets randomly chosen.</p></li>\n<li><p><b>Secret key</b> \u2212 User are provided a hardware device which can create a secret id mapped with user id. System asks for such secret id which is to be generated every time prior to login.</p></li>\n<li><p><b>Network password</b> \u2212 Some commercial applications send one-time passwords to user on registered mobile/ email which is required to be entered prior to login.</p></li>\n</ul>\n<h2>Program Threats</h2>\n<p>Operating system's processes and kernel do the designated task as instructed. If a user program made these process do malicious tasks, then it is known as <b>Program Threats</b>. One of the common example of program threat is a program installed in a computer which can store and send user credentials via network to some hacker. Following is the list of some well-known program threats.</p>\n<ul class=\"list\">\n<li><p><b>Trojan Horse</b> \u2212 Such program traps user login credentials and stores them to send to malicious user who can later on login to computer and can access system resources.</p></li>\n<li><p><b>Trap Door</b> \u2212 If a program which is designed to work as required, have a security hole in its code and perform illegal action without knowledge of user then it is called to have a trap door.</p></li>\n<li><p><b>Logic Bomb</b> \u2212 Logic bomb is a situation when a program misbehaves only when certain conditions met otherwise it works as a genuine program. It is harder to detect.</p></li>\n<li><p><b>Virus</b> \u2212 Virus as name suggest can replicate themselves on computer system. They are highly dangerous and can modify/delete user files, crash systems. A virus is generatlly a small code embedded in a program. As user accesses the program, the virus starts getting embedded in other files/ programs and can make system unusable for user</p></li>\n</ul>\n<h2>System Threats</h2>\n<p>System threats refers to misuse of system services and network connections to put user in trouble. System threats can be used to launch program threats on a complete network called as program attack. System threats creates such an environment that operating system resources/ user files are misused. Following is the list of some well-known system threats.</p>\n<ul class=\"list\">\n<li><p><b>Worm</b> \u2212 Worm is a process which can choked down a system performance by using system resources to extreme levels. A Worm process generates its multiple copies where each copy uses system resources, prevents all other processes to get required resources. Worms processes can even shut down an entire network.</p></li>\n<li><p><b>Port Scanning</b> \u2212 Port scanning is a mechanism or means by which a hacker can detects system vulnerabilities to make an attack on the system.</p></li>\n<li><p><b>Denial of Service</b> \u2212 Denial of service attacks normally prevents user to make legitimate use of the system. For example, a user may not be able to use internet if denial of service attacks browser's content settings.</p></li>\n</ul>\n<h2>Computer Security Classifications</h2>\n<p>As per the U.S. Department of Defense Trusted Computer System's Evaluation Criteria there are four security classifications in computer systems: A, B, C, and D. This is widely used specifications to determine and model the security of systems and of security solutions. Following is the brief description of each classification.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">Classification Type &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Type A</b></p>\n<p>Highest Level. Uses formal design specifications and verification techniques. Grants a high degree of assurance of process security.</p></td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Type B</b></p>\n<p>Provides mandatory protection system. Have all the properties of a class C2 system. Attaches a sensitivity label to each object. It is of three types.</p>\n<ul class=\"list\">\n<li><p><b>B1</b> \u2212 Maintains the security label of each object in the system. Label is used for making decisions to access control.</p></li>\n<li><p><b>B2</b> \u2212 Extends the sensitivity labels to each system resource, such as storage objects, supports covert channels and auditing of events.</p></li>\n<li><p><b>B3</b> \u2212 Allows creating lists or user groups for access-control to grant access or revoke access to a given named object.</p></li>\n</ul>\n</td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Type C</b></p>\n<p>Provides protection and user accountability using audit capabilities. It is of two types.</p>\n<ul class=\"list\">\n<li><p><b>C1</b> \u2212 Incorporates controls so that users can protect their private information and keep other users from accidentally reading / deleting their data. UNIX versions are mostly Cl class.</p></li>\n<li><p><b>C2</b> \u2212 Adds an individual-level access control to the capabilities of a Cl level system.</p></li>\n</ul>\n</td>\n</tr>\n<tr>\n<td>4</td>\n<td><p><b>Type D</b></p>\n<p>Lowest level. Minimum protection. MS-DOS, Window 3.1 fall in this category.</p></td>\n</tr>\n</table>\n<h1>Operating System - Linux</h1>\n<p>Linux is one of popular version of UNIX operating System. It is open source as its source code is freely available. It is free to use. Linux was designed considering UNIX compatibility. Its functionality list is quite similar to that of UNIX.</p>\n<h2>Components of Linux System</h2>\n<p>Linux Operating System has primarily three components</p>\n<ul class=\"list\">\n<li><p><b>Kernel</b> \u2212 Kernel is the core part of Linux. It is responsible for all major activities of this operating system. It consists of various modules and it interacts directly with the underlying hardware. Kernel provides the required abstraction to hide low level hardware details to system or application programs.</p></li>\n<li><p><b>System Library</b> \u2212 System libraries are special functions or programs using which application programs or system utilities accesses Kernel's features. These libraries implement most of the functionalities of the operating system and do not requires kernel module's code access rights.</p></li>\n<li><p><b>System Utility</b> \u2212 System Utility programs are responsible to do specialized, individual level tasks.</p></li>\n</ul>\n<img alt=\"Linux Operating System\" src=\"/operating_system/images/linux_os.jpg\"/>\n<h2>Kernel Mode vs User Mode</h2>\n<p>Kernel component code executes in a special privileged mode called <b>kernel mode</b> with full access to all resources of the computer. This code represents a single process, executes in single address space and do not require any context switch and hence is very efficient and fast. Kernel runs each processes and provides system services to processes, provides protected access to hardware to processes.</p>\n<p>Support code which is not required to run in kernel mode is in System Library. User programs and other system programs works in <b>User Mode</b> which has no access to system hardware and kernel code. User programs/ utilities use System libraries to access Kernel functions to get system's low level tasks.</p>\n<h2>Basic Features</h2>\n<p>Following are some of the important features of Linux Operating System.</p>\n<ul class=\"list\">\n<li><p><b>Portable</b> \u2212 Portability means software can works on different types of hardware in same way. Linux kernel and application programs supports their installation on any kind of hardware platform.</p></li>\n<li><p><b>Open Source</b> \u2212 Linux source code is freely available and it is community based development project. Multiple teams work in collaboration to enhance the capability of Linux operating system and it is continuously evolving.</p></li>\n<li><p><b>Multi-User</b> \u2212 Linux is a multiuser system means multiple users can access system resources like memory/ ram/ application programs at same time.</p></li>\n<li><p><b>Multiprogramming</b> \u2212 Linux is a multiprogramming system means multiple applications can run at same time.</p></li>\n<li><p><b>Hierarchical File System</b> \u2212 Linux provides a standard file structure in which system files/ user files are arranged.</p></li>\n<li><p><b>Shell</b> \u2212 Linux provides a special interpreter program which can be used to execute commands of the operating system. It can be used to do various types of operations, call application programs. etc.</p></li>\n<li><p><b>Security</b> \u2212 Linux provides user security using authentication features like password protection/ controlled access to specific files/ encryption of data.</p></li>\n</ul>\n<h2>Architecture</h2>\n<p>The following illustration shows the architecture of a Linux system \u2212</p>\n<img alt=\"Linux Operating System Architecture\" src=\"/operating_system/images/linux_architecture.jpg\"/>\n<p>The architecture of a Linux System consists of the following layers \u2212</p>\n<ul class=\"list\">\n<li><p><b>Hardware layer</b> \u2212 Hardware consists of all peripheral devices (RAM/ HDD/ CPU etc).</p></li>\n<li><p><b>Kernel</b> \u2212 It is the core component of Operating System, interacts directly with hardware, provides low level services to upper layer components.</p></li>\n<li><p><b>Shell</b> \u2212 An interface to kernel, hiding complexity of kernel's functions from users. The shell takes commands from the user and executes kernel's functions.</p></li>\n<li><p><b>Utilities</b> \u2212 Utility programs that provide the user most of the functionalities of an operating systems.</p></li>\n</ul>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/operating_system/os_exams_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"print-btn center\">\n<a href=\"/cgi-bin/printpage.cgi\" target=\"_blank\"><i class=\"icon icon-print big-font\"></i> Print</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/operating_system/os_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<hr/>\n<!-- PRINTING ENDS HERE -->\n<div class=\"bottomgooglead\">\n<div class=\"bottomadtag\">Advertisements</div>\n<script><!--\nvar width = 580;\nvar height = 400;\nvar format = \"580x400_as\";\nif( window.innerWidth < 468 ){\n   width = 300;\n   height = 250;\n   format = \"300x250_as\";\n}\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = width;\ngoogle_ad_height = height;\ngoogle_ad_format = format;\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n</div>", "html": "<!DOCTYPE html>\n\n<!--[if IE 8]><html class=\"ie ie8\"> <![endif]-->\n<!--[if IE 9]><html class=\"ie ie9\"> <![endif]-->\n<!--[if gt IE 9]><!--> <html> <!--<![endif]-->\n<head>\n<!-- Basic -->\n<meta charset=\"utf-8\"/>\n<title>Operating System - Quick Guide</title>\n<meta content=\"Operating System Quick Guide - Learning operating system in simple and easy steps starting from basic to advanced concepts with examples including Definition, Functions, Conceptual View, Program Execution, Program Execution, Communication, Error Handling, User Account Management, Multitasking, Real Time System, Process, Program, Memory Management, and Security.\" name=\"description\">\n<meta content=\"Operating System, Tutorials, Learning, Beginners, Basics, Definition, Functions, Conceptual View, Program Execution, Program Execution, Communication, Error Handling, User Account Management, Multitasking, Real Time System, Process, Program, Memory Management, Security.\" name=\"Keywords\"/>\n<base href=\"https://www.tutorialspoint.com/\"/>\n<link href=\"/favicon.ico\" rel=\"shortcut icon\" type=\"image/x-icon\"/>\n<meta content=\"width=device-width,initial-scale=1.0,user-scalable=yes\" name=\"viewport\"/>\n<meta content=\"en_US\" property=\"og:locale\">\n<meta content=\"website\" property=\"og:type\"/>\n<meta content=\"471319149685276\" property=\"fb:app_id\"/>\n<meta content=\"www.tutorialspoint.com\" property=\"og:site_name\"/>\n<meta content=\"yes\" name=\"apple-mobile-web-app-capable\"/>\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"/>\n<meta content=\"tutorialspoint.com\" name=\"author\"/>\n<script src=\"https://www.tutorialspoint.com/theme/js/script-min-v4.js?v=2\" type=\"text/javascript\"></script>\n<link href=\"https://www.tutorialspoint.com/theme/css/style-min.css?v=3.1\" rel=\"stylesheet\"/>\n<script>\r\nfunction openNav() {\t\r\n  document.getElementById(\"mySidenav\").style.width = \"250px\";\r\n  document.getElementById(\"right_obs\").style.display = \"block\";\r\n}\r\nfunction closeNav() {\r\n  document.getElementById(\"mySidenav\").style.width = \"0\";\r\n  document.getElementById(\"right_obs\").style.display = \"none\";\r\n}\r\nfunction close_obs_sidenav(){\r\n  document.getElementById(\"mySidenav\").style.width = \"0\";\r\n  document.getElementById(\"right_obs\").style.display = \"none\";\r\n}\r\n</script>\n<!-- Head Libs -->\n<!--[if IE 8]>\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/theme/css/ie8.css\">\r\n<![endif]-->\n<style>\r\n#privacy-banner {\r\n    position: fixed;\r\n    bottom: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    max-width: 100%;\r\n    padding: 1rem .5rem;\r\n    background: #fff;\r\n    z-index: 1030;\r\n    color: #000;\r\n    font-size: 14px;\r\n    margin: 0;\r\n    display: none;\r\n    border-top: 2px solid rgb(130, 130, 130);\r\n  }\r\n  #privacy-banner p {\r\n    margin: 0;\r\n    color: #000;\r\n    text-align: center;\r\n  }\r\n  #privacy-banner a {\r\n    text-decoration: none;\r\n    margin: 20px auto 0 auto;\r\n    display: block;\r\n    max-width: 150px;\r\n  }\r\n  #privacy-banner a:hover {\r\n    text-decoration: underline;\r\n  }\r\n  #banner-learn {\r\n    color: #000;\r\n  }\r\n  #banner-accept {\r\n    padding: 7px 15px;\r\n    color: #fff;\r\n    border-radius: 5px;\r\n    background:#737373 !important;\r\n  }\r\n  @media (min-width: 768px) {\r\n    #privacy-banner {\r\n      padding: 1.5rem .5rem;\r\n    }\r\n    #privacy-banner a {\r\n      display: inline-block;\r\n      margin: 0 10px;\r\n    }\r\n}\r\nselect{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }\r\n.btnsbmt{ background: #3896c2 !important;}\r\nul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}\r\ndiv.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #3896c2 url(/images/pattern.png) repeat center center !important;}\r\n.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #3896c2 !important;}\r\n.submenu-item{ border-bottom: 2px solid #3896c2 !important; border-top: 2px solid #3896c2 !important }\r\n.ace_scroller{overflow: auto!important;}\r\na.demo{font-family: \"Open Sans\",Arial,sans-serif; background:#3896c2; color:#fff; font-size:13px; padding:3px 10px; border:1px solid #d6d6d6; position:absolute; right:5px; margin:-6px 17px 0px 0px;}\r\na.demo:hover{opacity:.8}\r\n</style>\n<script>\r\n$(document).ready(function() {\r\n  $('input[name=\"q\"]').keydown(function(event){\r\n    if(event.keyCode == 13) {\r\n      event.preventDefault();\r\n      return false;\r\n    }\r\n  });\r\n});\r\n</script>\n</meta></meta></head>\n<body onload=\"prettyPrint()\">\n<div class=\"wrapLoader\">\n<div class=\"imgLoader\">\n<img alt=\"\" height=\"70\" src=\"/images/loading-cg.gif\" width=\"70\"/>\n</div>\n</div>\n<div class=\"display-none\" id=\"right_obs\" onclick=\"close_obs_sidenav()\"></div>\n<header>\n<div class=\"container\">\n<h1 class=\"logo\">\n<a href=\"index.htm\" title=\"tutorialspoint\">\n<img alt=\"tutorialspoint\" src=\"/operating_system/images/logo.png\"/>\n</a>\n</h1>\n<ul class=\"tp-inline-block pull-right\" id=\"tp-head-icons\">\n<li>\n<div class=\"tp-second-nav tp-display-none tp-pointer\" onclick=\"openNav()\">\n<i class=\"fa fa-th-large fa-lg\"></i>\n</div>\n</li>\n</ul>\n<button class=\"btn btn-responsive-nav btn-inverse\" data-target=\".nav-main-collapse\" data-toggle=\"collapse\" id=\"pull\" style=\"top: 24px!important\"> <i class=\"icon icon-bars\"></i> </button>\n<nav>\n<ul class=\"nav nav-pills nav-top\">\n<li><a href=\"/about/about_careers.htm\" style=\"background: #fffb09; font-weight: bold;\"><i class=\"icon icon-suitcase\"></i> Jobs</a></li>\n<li> <a href=\"/programming_examples/\" target=\"_blank\"><i class=\"fa fa-cubes\"></i> \u00a0Examples</a> </li>\n<li> <a href=\"https://www.tutorialspoint.com/whiteboard.htm\"><img alt=\"Whiteboard\" src=\"theme/css/icons/image-editor.png\" title=\"Whiteboard\"/> \u00a0Whiteboard</a> </li>\n<li> <a href=\"https://www.tutorialspoint.com/netmeeting.php\"><i class=\"fa-camera\"></i> \u00a0Net Meeting</a> </li>\n<li> <a href=\"/online_dev_tools.htm\"> <i class=\"dev-tools-menu\" style=\"opacity:.5\"></i> Tools </a> </li>\n<li> <a href=\"/articles/index.php\"><i class=\"icon icon-file-text-o\"></i> \u00a0Articles</a> </li>\n<li class=\"top-icons\">\n<ul class=\"social-icons\">\n<li class=\"facebook\"><a data-placement=\"bottom\" href=\"https://www.facebook.com/tutorialspointindia\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Facebook\">Facebook</a></li>\n<li class=\"googleplus\"><a data-placement=\"bottom\" href=\"https://plus.google.com/u/0/116678774017490391259/posts\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Google+\">Google+</a></li>\n<li class=\"twitter\"><a data-placement=\"bottom\" href=\"https://www.twitter.com/tutorialspoint\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Twitter\">Twitter</a></li>\n<li class=\"linkedin\"><a data-placement=\"bottom\" href=\"https://www.linkedin.com/company/tutorialspoint\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint @ Linkedin\">Linkedin</a></li>\n<li class=\"youtube\"><a data-placement=\"bottom\" href=\"https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg\" rel=\"nofollow\" target=\"_blank\" title=\"tutorialspoint YouTube\">YouTube</a></li>\n</ul>\n</li>\n</ul>\n</nav>\n</div>\n<div class=\"sidenav\" id=\"mySidenav\">\n<div class=\"navbar nav-main\">\n<div class=\"container\">\n<nav class=\"nav-main mega-menu\">\n<ul class=\"nav nav-pills nav-main\" id=\"mainMenu\">\n<li class=\"dropdown no-sub-menu\"> <a class=\"dropdown\" href=\"index.htm\"><i class=\"icon icon-home\"></i> Home</a> </li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"/questions/index.php\"><i class=\"fa fa-send\"></i> Q/A </a> </li>\n<li class=\"dropdown\"><a class=\"dropdown\" href=\"tutorialslibrary.htm\"><span class=\"tut-lib\"> Library </span></a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"videotutorials/index.htm\"><i class=\"fa-toggle-right\"></i> Videos </a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"tutor_connect/index.php\"><i class=\"fa-user\"> </i> Tutors</a></li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"codingground.htm\"><i class=\"fa-code\"></i> Coding Ground </a> </li>\n<li class=\"dropdown no-sub-menu\"><a class=\"dropdown\" href=\"https://store.tutorialspoint.com/\"><i class=\"fa-usd\"></i> Store </a> </li>\n<li class=\"dropdown no-sub-menu\">\n<div class=\"searchform-popup\">\n<input autocomplete=\"off\" class=\"header-search-box\" id=\"search-string\" name=\"q\" onblur=\"if (this.value == '') {this.value = 'Search your favorite tutorials...';}\" onfocus=\"if (this.value == 'Search your favorite tutorials...') {this.value = '';}\" placeholder=\"Search your favorite tutorials...\" type=\"text\"/>\n<div class=\"magnifying-glass\"><i class=\"icon-search\"></i> Search </div>\n</div>\n</li>\n</ul>\n</nav>\n</div>\n</div>\n</div>\n</header></body></html>\n\n<div style=\"clear:both;\"></div>\n<div class=\"main\" role=\"main\">\n<div class=\"container\">\n<div class=\"row\">\n<div class=\"col-md-2\">\n<aside class=\"sidebar\">\n<div class=\"mini-logo\">\n<img alt=\"Operating System Tutorial\" src=\"/operating_system/images/os-mini-logo.jpg\">\n</img></div>\n<ul class=\"nav nav-list primary left-menu\">\n<li><a class=\"videolink\" href=\"/operating_system/index.asp\" target=\"_blank\"><img alt=\"Operating System Video Tutorials\" src=\"/operating_system/images/operating-system-video-tutorials.jpg\"/></a></li>\n</ul>\n<ul class=\"nav nav-list primary left-menu\">\n<li class=\"heading\">Operating System Tutorial</li>\n<li><a href=\"/operating_system/index.htm\">OS - Home</a></li>\n<li><a href=\"/operating_system/os_overview.htm\">OS - Overview</a></li>\n<li><a href=\"/operating_system/os_types.htm\">OS - Types</a></li>\n<li><a href=\"/operating_system/os_services.htm\">OS - Services</a></li>\n<li><a href=\"/operating_system/os_properties.htm\">OS - Properties</a></li>\n<li><a href=\"/operating_system/os_processes.htm\">OS - Processes</a></li>\n<li><a href=\"/operating_system/os_process_scheduling.htm\">OS - Process Scheduling</a></li>\n<li><a href=\"/operating_system/os_process_scheduling_algorithms.htm\">OS - Scheduling algorithms</a></li>\n<li><a href=\"/operating_system/os_multi_threading.htm\">OS -  Multi-threading</a></li>\n<li><a href=\"/operating_system/os_memory_management.htm\">OS - Memory Management</a></li>\n<li><a href=\"/operating_system/os_virtual_memory.htm\">OS -  Virtual Memory</a></li>\n<li><a href=\"/operating_system/os_io_hardware.htm\">OS -  I/O Hardware</a></li>\n<li><a href=\"/operating_system/os_io_software.htm\">OS - I/O Software</a></li>\n<li><a href=\"/operating_system/os_file_system.htm\">OS -  File System</a></li>\n<li><a href=\"/operating_system/os_security.htm\">OS - Security</a></li>\n<li><a href=\"/operating_system/os_linux.htm\">OS - Linux</a></li>\n</ul>\n<ul class=\"nav nav-list primary left-menu\">\n<li class=\"heading\">OS - Exams Questions with Answers</li>\n<li><a class=\"left\" href=\"/operating_system/os_exams_questions_answers.htm\">OS - Exams Questions with Answers</a></li>\n</ul>\n<ul class=\"nav nav-list primary left-menu\">\n<li class=\"heading\">Operating System Useful Resources</li>\n<li><a class=\"left\" href=\"/operating_system/os_quick_guide.htm\">OS - Quick Guide</a></li>\n<li><a class=\"left\" href=\"/operating_system/os_useful_resources.htm\">OS - Useful Resources</a></li>\n<li><a class=\"left\" href=\"/operating_system/os_discussion.htm\">OS - Discussion</a></li>\n</ul>\n<ul class=\"nav nav-list primary push-bottom left-menu special\">\n<li class=\"sreading\">Selected Reading</li>\n<li><a href=\"/upsc_ias_exams.htm\" target=\"_top\">UPSC IAS Exams Notes</a></li>\n<li><a href=\"/developers_best_practices/index.htm\" target=\"_top\">Developer's Best Practices</a></li>\n<li><a href=\"/questions_and_answers.htm\" target=\"_top\">Questions and Answers</a></li>\n<li><a href=\"/effective_resume_writing.htm\" target=\"_top\">Effective Resume Writing</a></li>\n<li><a href=\"/hr_interview_questions/index.htm\" target=\"_top\">HR Interview Questions</a></li>\n<li><a href=\"/computer_glossary.htm\" target=\"_top\">Computer Glossary</a></li>\n<li><a href=\"/computer_whoiswho.htm\" target=\"_top\">Who is Who</a></li>\n</ul>\n</aside>\n</div>\n<!-- PRINTING STARTS HERE -->\n<div class=\"row\">\n<div class=\"content\">\n<div class=\"col-md-7 middle-col\">\n<h1>Operating System - Quick Guide</h1>\n<hr/>\n<div style=\"padding-bottom:5px;padding-left:10px;text-align: center;\">Advertisements</div>\n<div style=\"text-align: center;\">\n<script type=\"text/javascript\"><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 468;\ngoogle_ad_height = 60;\ngoogle_ad_format = \"468x60_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel = \"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\" type=\"text/javascript\">\n</script>\n</div>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/operating_system/os_exams_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/operating_system/os_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<div class=\"clearer\"></div>\n<hr/>\n<h1>Operating System - Overview</h1>\n<p>An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers.</p>\n<p>Some popular Operating Systems include Linux Operating System, Windows Operating System, VMS, OS/400, AIX, z/OS, etc.</p>\n<h2>Definition</h2>\n<p>An operating system is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs.</p>\n<img alt=\"Conceptual view of an Operating System\" src=\"/operating_system/images/conceptual_view.jpg\"/>\n<p>Following are some of important functions of an operating System.</p>\n<ul class=\"list\">\n<li>Memory Management</li>\n<li>Processor Management</li>\n<li>Device Management</li>\n<li>File Management</li>\n<li>Security</li>\n<li>Control over system performance</li>\n<li>Job accounting</li>\n<li>Error detecting aids</li>\n<li>Coordination between other software and users</li>\n</ul>\n<h2>Memory Management</h2>\n<p>Memory management refers to management of Primary Memory or Main Memory. Main memory is a large array of words or bytes where each word or byte has its own address.</p>\n<p>Main memory provides a fast storage that can be accessed directly by the CPU. For a program to be executed, it must in the main memory. An Operating System does the following activities for memory management \u2212</p>\n<ul class=\"list\">\n<li><p>Keeps tracks of primary memory, i.e., what part of it are in use by whom, what part are not in use.</p></li>\n<li><p>In multiprogramming, the OS decides which process will get memory when and how much.</p></li>\n<li><p>Allocates the memory when a process requests it to do so.</p></li>\n<li><p>De-allocates the memory when a process no longer needs it or has been terminated.</p></li>\n</ul>\n<h2>Processor Management</h2>\n<p>In multiprogramming environment, the OS decides which process gets the processor when and for how much time. This function is called <b>process  scheduling</b>. An Operating System does the following activities for processor management \u2212</p>\n<ul class=\"list\">\n<li><p>Keeps tracks of processor and status of process. The program responsible for this task is known as <b>traffic controller</b>.</p></li>\n<li><p>Allocates the processor (CPU) to a process.</p></li>\n<li><p>De-allocates processor when a process is no longer required.</p></li>\n</ul>\n<h2>Device Management</h2>\n<p>An Operating System manages device communication via their respective drivers. It does the following activities for device management \u2212</p>\n<ul class=\"list\">\n<li><p>Keeps tracks of all devices. Program responsible for this task is known as the <b>I/O controller</b>.</p></li>\n<li><p>Decides which process gets the device when and for how much time.</p></li>\n<li><p>Allocates the device in the efficient way.</p></li>\n<li><p>De-allocates devices.</p></li>\n</ul>\n<h2>File Management</h2>\n<p>A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions.</p>\n<p>An Operating System does the following activities for file management \u2212</p>\n<ul class=\"list\">\n<li><p>Keeps track of information, location, uses, status etc. The collective facilities are often known as <b>file system</b>.</p></li>\n<li><p>Decides who gets the resources.</p></li>\n<li><p>Allocates the resources.</p></li>\n<li><p>De-allocates the resources.</p></li>\n</ul>\n<h2>Other Important Activities</h2>\n<p>Following are some of the important activities that an Operating System performs \u2212</p>\n<ul class=\"list\">\n<li><p><b>Security</b> \u2212  By means of password and similar other techniques, it prevents unauthorized access to programs and data.</p></li>\n<li><p><b>Control over system performance</b> \u2212 Recording delays between request for a service and response from the system.</p></li>\n<li><p><b>Job accounting</b> \u2212 Keeping track of time and resources used by various jobs and users.</p></li>\n<li><p><b>Error detecting aids</b> \u2212 Production of dumps, traces, error messages, and other debugging and error detecting aids.</p></li>\n<li><p><b>Coordination between other softwares and users</b> \u2212 Coordination and assignment of compilers, interpreters, assemblers and other software to the various users of the computer systems.</p></li>\n</ul>\n<h1>Types of Operating System</h1>\n<p>Operating systems are there from the very first computer generation and they keep evolving with time. In this chapter, we will discuss some of the important types of operating systems which are most commonly used.</p>\n<h2>Batch operating system</h2>\n<p>The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator. To speed up processing, jobs with similar needs are batched together and run as a group. The programmers leave their programs with the operator and the operator then sorts the programs with similar requirements into batches.</p>\n<p>The problems with Batch Systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>Lack of interaction between the user and the job.</li>\n<li>CPU is often idle, because the speed of the mechanical I/O devices is slower than the CPU.</li>\n<li>Difficult to provide the desired priority.</li>\n</ul>\n<h2>Time-sharing operating systems</h2>\n<p>Time-sharing is a technique which enables many people, located at various terminals, to use a particular computer system at the same time. Time-sharing or multitasking is a logical extension of multiprogramming. Processor's time which is shared among multiple users simultaneously is termed as time-sharing.</p>\n<p>The main difference between Multiprogrammed Batch Systems and Time-Sharing Systems is that in case of Multiprogrammed batch systems, the objective is to maximize processor use, whereas in Time-Sharing Systems, the objective is to minimize response time.</p>\n<p>Multiple jobs are executed by the CPU by switching between them, but the switches occur so frequently. Thus, the user can receive an immediate response. For example, in a transaction processing, the processor executes each user program in a short burst or quantum of computation. That is, if <b>n</b> users are present, then each user can get a time quantum. When the user submits the command, the response time is in few seconds at most.</p>\n<p>The operating system uses CPU scheduling and multiprogramming to provide each user with a small portion of a time. Computer systems that were designed primarily as batch systems have been modified to time-sharing systems.</p>\n<p>Advantages of Timesharing operating systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>Provides the advantage of quick response.</li>\n<li>Avoids duplication of software.</li>\n<li>Reduces CPU idle time.</li>\n</ul>\n<p>Disadvantages of Time-sharing operating systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>Problem of reliability.</li>\n<li>Question of security and integrity of user programs and data.</li>\n<li>Problem of data communication.</li>\n</ul>\n<h2>Distributed operating System</h2>\n<p>Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly.</p>\n<p>The processors communicate with one another through various communication lines (such as high-speed buses or telephone lines). These are referred as <b>loosely coupled systems</b> or distributed systems. Processors in a distributed system may vary in size and function. These processors are referred as sites, nodes, computers, and so on.</p>\n<p>The advantages of distributed systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>With resource sharing facility, a user at one site may be able to use the resources available at another.</li>\n<li>Speedup the exchange of data with one another via electronic mail.</li>\n<li>If one site fails in a distributed system, the remaining sites can potentially continue operating.</li>\n<li>Better service to the customers.</li>\n<li>Reduction of the load on the host computer.</li>\n<li>Reduction of delays in data processing.</li>\n</ul>\n<h2>Network operating System</h2>\n<p>A Network Operating System runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a local area network (LAN), a private network or to other networks.</p>\n<p>Examples of network operating systems include Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD.</p>\n<p>The advantages of network operating systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>Centralized servers are highly stable.</li>\n<li>Security is server managed.</li>\n<li>Upgrades to new technologies and hardware can be easily integrated into the system.</li>\n<li>Remote access to servers is possible from different locations and types of systems.</li>\n</ul>\n<p>The disadvantages of network operating systems are as follows \u2212</p>\n<ul class=\"list\">\n<li>High cost of buying and running a server.</li>\n<li>Dependency on a central location for most operations.</li>\n<li>Regular maintenance and updates are required.</li>\n</ul>\n<h2>Real Time operating System</h2>\n<p>A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment. The time taken by the system to respond to an input and display of required updated information is termed as the <b>response time</b>. So in this method, the response time is very less as compared to online processing.</p>\n<p>Real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application. A real-time operating system must have well-defined, fixed time constraints, otherwise the system will fail. For example, Scientific experiments, medical imaging systems, industrial control systems, weapon systems, robots, air traffic control systems, etc.</p>\n<p>There are two types of real-time operating systems.</p>\n<h3>Hard real-time systems</h3>\n<p>Hard real-time systems guarantee that critical tasks complete on time. In hard real-time systems, secondary storage is limited or missing and the data is stored in ROM. In these systems, virtual memory is almost never found.</p>\n<h3>Soft real-time systems</h3>\n<p>Soft real-time systems are less restrictive. A critical real-time task gets priority over other tasks and retains the priority until it completes. Soft real-time systems have limited utility than hard real-time systems. For example, multimedia, virtual reality, Advanced Scientific Projects like undersea exploration and planetary rovers, etc.</p>\n<h1>Operating System - Services</h1>\n<p>An Operating System provides services to both the users and to the programs.</p>\n<ul class=\"list\">\n<li>It provides programs an environment to execute.</li>\n<li>It provides users the services to execute the programs in a convenient manner.</li>\n</ul>\n<p>Following are a few common services provided by an operating system \u2212</p>\n<ul class=\"list\">\n<li>Program execution</li>\n<li>I/O operations</li>\n<li>File System manipulation</li>\n<li>Communication</li>\n<li>Error Detection</li>\n<li>Resource Allocation</li>\n<li>Protection</li>\n</ul>\n<h2>Program execution</h2>\n<p>Operating systems handle many kinds of activities from user programs to system programs like printer spooler, name servers, file server, etc. Each of these activities is encapsulated as a process.</p>\n<p>A process includes the complete execution context (code to execute, data to manipulate, registers, OS resources in use). Following are the major activities of an operating system with respect to program management \u2212</p>\n<ul class=\"list\">\n<li>Loads a program into memory.</li>\n<li>Executes the program.</li>\n<li>Handles program's execution.</li>\n<li>Provides a mechanism for process synchronization.</li>\n<li>Provides a mechanism for process communication.</li>\n<li>Provides a mechanism for deadlock handling.</li>\n</ul>\n<h2>I/O Operation</h2>\n<p>An I/O subsystem comprises of I/O devices and their corresponding driver software. Drivers hide the peculiarities of specific hardware devices from the users.</p>\n<p>An Operating System manages the communication between user and device drivers.</p>\n<ul class=\"list\">\n<li>I/O operation means read or write operation with any file or any specific I/O device.</li>\n<li>Operating system provides the access to the required I/O device when required.</li>\n</ul>\n<h2>File system manipulation</h2>\n<p>A file represents a collection of related information. Computers can store files on the disk (secondary storage), for long-term storage purpose. Examples of storage media include magnetic tape, magnetic disk and optical disk drives like CD, DVD. Each of these media has its own properties like speed, capacity, data transfer rate and data access methods.</p>\n<p>A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. Following are the major activities of an operating system with respect to file management \u2212</p>\n<ul class=\"list\">\n<li>Program needs to read a file or write a file.</li>\n<li>The operating system gives the permission to the program for operation on file.</li>\n<li>Permission varies from read-only, read-write, denied and so on.</li>\n<li>Operating System provides an interface to the user to create/delete files.</li>\n<li>Operating System provides an interface to the user to create/delete directories.</li>\n<li>Operating System provides an interface to create the backup of file system.</li>\n</ul>\n<h2>Communication</h2>\n<p>In case of distributed systems which are a collection of processors that do not share memory, peripheral devices, or a clock, the operating system manages communications between all the processes. Multiple processes communicate with one another through communication lines in the network.</p>\n<p>The OS handles routing and connection strategies, and the problems of contention and security. Following are the major activities of an operating system with respect to communication \u2212</p>\n<ul class=\"list\">\n<li>Two processes often require data to be transferred between them</li>\n<li>Both the processes can be on one computer or on different computers, but are connected through a computer network.</li>\n<li>Communication may be implemented by two methods, either by Shared Memory or by Message Passing.</li>\n</ul>\n<h2>Error handling</h2>\n<p>Errors can occur anytime and anywhere. An error may occur in CPU, in I/O devices or in the memory hardware. Following are the major activities of an operating system with respect to error handling \u2212</p>\n<ul class=\"list\">\n<li>The OS constantly checks for possible errors.</li>\n<li>The OS takes an appropriate action to ensure correct and consistent computing.</li>\n</ul>\n<h2>Resource Management</h2>\n<p>In case of multi-user or multi-tasking environment, resources such as main memory, CPU cycles and files storage are to be allocated to each user or job. Following are the major activities of an operating system with respect to resource management \u2212</p>\n<ul class=\"list\">\n<li>The OS manages all kinds of resources using schedulers.</li>\n<li>CPU scheduling algorithms are used for better utilization of CPU.</li>\n</ul>\n<h2>Protection</h2>\n<p>Considering a computer system having multiple users and concurrent execution of multiple processes, the various processes must be protected from each other's activities.</p>\n<p>Protection refers to a mechanism or a way to control the access of programs, processes, or users to the resources defined by a computer system. Following are the major activities of an operating system with respect to protection \u2212</p>\n<ul class=\"list\">\n<li>The OS ensures that all access to system resources is controlled.</li>\n<li>The OS ensures that external I/O devices are protected from invalid access attempts.</li>\n<li>The OS provides authentication features for each user by means of passwords.</li>\n</ul>\n<h1>Operating System - Properties</h1>\n<h2>Batch processing</h2>\n<p>Batch processing is a technique in which an Operating System collects the programs and data together in a batch before processing starts. An operating system does the following activities related to batch processing \u2212</p>\n<ul class=\"list\">\n<li><p>The OS defines a job which has predefined sequence of commands, programs and data as a single unit.</p></li>\n<li><p>The OS keeps a number a jobs in memory and executes them without any manual information.</p></li>\n<li><p>Jobs are processed in the order of submission, i.e., first come first served fashion.</p></li>\n<li><p>When a job completes its execution, its memory is released and the output for the job gets copied into an output spool for later printing or processing.</p></li>\n</ul>\n<img alt=\"Batch Processing\" src=\"/operating_system/images/batch_processing.jpg\"/>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li><p>Batch processing takes much of the work of the operator to the computer.</p></li>\n<li><p>Increased performance as a new job get started as soon as the previous job is finished, without any manual intervention.</p></li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li>Difficult to debug program.</li>\n<li>A job could enter an infinite loop.</li>\n<li>Due to lack of protection scheme, one batch job can affect pending jobs.</li>\n</ul>\n<h2>Multitasking</h2>\n<p>Multitasking is when multiple jobs are executed by the CPU simultaneously by switching between them. Switches occur so frequently that the users may interact with each program while it is running. An OS does the following activities related to multitasking \u2212</p>\n<ul class=\"list\">\n<li><p>The user gives instructions to the operating system or to a program directly, and receives an immediate response.</p></li>\n<li><p>The OS handles multitasking in the way that it can handle multiple operations/executes multiple programs at a time.</p></li>\n<li><p>Multitasking Operating Systems are also known as Time-sharing systems.</p></li>\n<li><p>These Operating Systems were developed to provide interactive use of a computer system at a reasonable cost.</p></li>\n<li><p>A time-shared operating system uses the concept of CPU scheduling and multiprogramming to provide each user with a small portion of a time-shared CPU.</p></li>\n<li><p>Each user has at least one separate program in memory.</p></li>\n</ul>\n<img alt=\"Multitasking\" src=\"/operating_system/images/multitasking.jpg\"/>\n<ul class=\"list\">\n<li><p>A program that is loaded into memory and is executing is commonly referred to as a <b>process</b>.</p></li>\n<li><p>When a process executes, it typically executes for only a very short time before it either finishes or needs to perform I/O.</p></li>\n<li><p>Since interactive I/O typically runs at slower speeds, it may take a long time to complete. During this time, a CPU can be utilized by another process.</p></li>\n<li><p>The operating system allows the users to share the computer simultaneously. Since each action or command in a time-shared system tends to be short, only a little CPU time is needed for each user.</p></li>\n<li><p>As the system switches CPU rapidly from one user/program to the next, each user is given the impression that he/she has his/her own CPU, whereas actually one CPU is being shared among many users.</p></li>\n</ul>\n<h2>Multiprogramming</h2>\n<p>Sharing the processor, when two or more programs reside in memory at the same time, is referred as <b> multiprogramming</b>. Multiprogramming assumes a single shared processor. Multiprogramming increases CPU utilization by organizing jobs so that the CPU always has one to execute.</p>\n<p>The following figure shows the memory layout for a multiprogramming system.</p>\n<img alt=\"Memory layout\" src=\"/operating_system/images/memory_layout.jpg\"/>\n<p>An OS does the following activities related to multiprogramming.</p>\n<ul class=\"list\">\n<li><p>The operating system keeps several jobs in memory at a time.</p></li>\n<li><p>This set of jobs is a subset of the jobs kept in the job pool.</p></li>\n<li><p>The operating system picks and begins to execute one of the jobs in the memory.</p></li>\n<li><p>Multiprogramming operating systems monitor the state of all active programs and system resources using memory management programs to ensures that the CPU is never idle, unless there are no jobs to process.</p></li>\n</ul>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li>High and efficient CPU utilization.</li>\n<li>User feels that many programs are allotted CPU almost simultaneously.</li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li>CPU scheduling is required.</li>\n<li>To accommodate many jobs in memory, memory management is required.</li>\n</ul>\n<h2>Interactivity</h2>\n<p>Interactivity refers to the ability of users to interact with a computer system. An Operating system does the following activities related to interactivity \u2212</p>\n<ul class=\"list\">\n<li>Provides the user an interface to interact with the system.</li>\n<li>Manages input devices to take inputs from the user. For example, keyboard.</li>\n<li>Manages output devices to show outputs to the user. For example, Monitor.</li>\n</ul>\n<p>The response time of the OS needs to be short, since the user submits and waits for the result.</p>\n<h2>Real Time System</h2>\n<p>Real-time systems are usually dedicated, embedded systems. An operating system does the following activities related to real-time system activity.</p>\n<ul class=\"list\">\n<li>In such systems, Operating Systems typically read from and react to sensor data.</li>\n<li>The Operating system must guarantee response to events within fixed periods of time to ensure correct performance.</li>\n</ul>\n<h2>Distributed Environment </h2>\n<p>A distributed environment refers to multiple independent CPUs or processors in a computer system. An operating system does the following activities related to distributed environment \u2212</p>\n<ul class=\"list\">\n<li><p>The OS distributes computation logics among several physical processors.</p></li>\n<li><p>The processors do not share memory or a clock. Instead, each processor has its own local memory.</p></li>\n<li><p>The OS manages the communications between the processors. They communicate with each other through various communication lines.</p></li>\n</ul>\n<h2>Spooling</h2>\n<p>Spooling is an acronym for simultaneous peripheral operations on line. Spooling refers to putting data of various I/O jobs in a buffer. This buffer is a special area in memory or hard disk which is accessible to I/O devices.</p>\n<p>An operating system does the following activities related to distributed environment \u2212</p>\n<ul class=\"list\">\n<li><p>Handles I/O device data spooling as devices have different data access rates.</p></li>\n<li><p>Maintains the spooling buffer which provides a waiting station where data can rest while the slower device catches up.</p></li>\n<li><p>Maintains parallel computation because of spooling process as a computer can perform I/O in parallel fashion. It becomes possible to have the computer read data from a tape, write data to disk and to write out to a tape printer while it is doing its computing task.</p></li>\n</ul>\n<img alt=\"Spooling\" src=\"/operating_system/images/spooling.jpg\"/>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li>The spooling operation uses a disk as a very large buffer.</li>\n<li>Spooling is capable of overlapping I/O operation for one job with processor operations for another job.</li>\n</ul>\n<h1>Operating System - Processes</h1>\n<h2>Process</h2>\n<p>A process is basically a program in execution. The execution of a process must progress in a sequential fashion.</p>\n<blockquote>A process is defined as an entity which represents the basic unit of work to be implemented in the system.</blockquote>\n<p>To put it in simple terms, we write our computer programs in a text file and when we execute this program, it becomes a process which performs all the tasks mentioned in the program.</p>\n<p>When a program is loaded into the memory and it becomes a process, it can be divided into four sections \u2500 stack, heap, text and data. The following image shows a simplified layout of a process inside main memory \u2212</p>\n<img alt=\"Process Components\" src=\"/operating_system/images/process_components.jpg\"/>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">Component &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Stack</b></p>\n<p>The process Stack contains the temporary data such as method/function parameters, return address and local variables.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Heap</b></p>\n<p>This is dynamically allocated memory to a process during its run time.</p>\n</td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Text</b></p>\n<p>This includes the current activity represented by the value of Program Counter and the contents of the processor's registers.</p>\n</td>\n</tr>\n<tr>\n<td>4</td>\n<td><p><b>Data</b></p>\n<p>This section contains the global and static variables.</p>\n</td>\n</tr>\n</table>\n<h2>Program</h2>\n<p>A program is a piece of code which may be a single line or millions of lines. A computer program is usually written by a computer programmer in a programming language. For example, here is a simple program written in C programming language \u2212</p>\n<pre class=\"prettyprint notranslate\">\n#include &lt;stdio.h&gt;\n\nint main() {\n   printf(\"Hello, World! \\n\");\n   return 0;\n}\n</pre>\n<p>A computer program is a collection of instructions that performs a specific task when executed by a computer. When we compare a program with a process, we can conclude that a process is a dynamic instance of a computer program.</p>\n<p>A part of a computer program that performs a well-defined task is known as an <b>algorithm</b>. A collection of computer programs, libraries and related data are referred to as a <b>software</b>.</p>\n<h2>Process Life Cycle</h2>\n<p> When a process executes, it passes through different states. These stages may differ in different operating systems, and the names of these states are also not standardized.</p>\n<p>In general, a process can have one of the following five states at a time.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">State &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td>\n<p><b>Start</b></p>\n<p>This is the initial state when a process is first started/created.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td>\n<p><b>Ready</b></p>\n<p>The process is waiting to be assigned to a processor. Ready processes are waiting to have the processor allocated to them by the operating system so that they can run. Process may come into this state after <b>Start</b> state or while running it by but interrupted by the scheduler to assign CPU to some other process.</p>\n</td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Running</b></p>\n<p>Once the process has been assigned to a processor by the OS scheduler, the process state is set to running and the processor executes its instructions.</p></td>\n</tr>\n<tr>\n<td>4</td>\n<td><p><b>Waiting</b></p>\n<p>Process moves into the waiting state if it needs to wait for a resource, such as waiting for user input, or waiting for a file to become available.</p></td>\n</tr>\n<tr>\n<td>5</td>\n<td><p><b>Terminated or Exit</b></p>\n<p>Once the process finishes its execution, or it is terminated by the operating system, it is moved to the terminated state where it waits to be removed from main memory.</p></td>\n</tr>\n</table>\n<img alt=\"Process States\" src=\"/operating_system/images/process_state.jpg\"/>\n<h2>Process Control Block (PCB)</h2>\n<p>A Process Control Block is a data structure maintained by the Operating System for every process. The PCB is identified by an integer process ID (PID). A PCB keeps all the information needed to keep track of a process as listed below in the table \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">Information &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Process State</b></p>\n<p>The current state of the process i.e., whether it is ready, running, waiting, or whatever.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Process privileges</b></p>\n<p>This is required to allow/disallow access to system resources.</p></td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Process ID</b></p>\n<p>Unique identification for each of the process in the operating system.</p></td>\n</tr>\n<tr>\n<td>4</td>\n<td><p><b>Pointer</b></p>\n<p>A pointer to parent process.</p></td>\n</tr>\n<tr>\n<td>5</td>\n<td><p><b>Program Counter</b></p>\n<p>Program Counter is a pointer to the address of the next instruction to be executed for this process.</p></td>\n</tr>\n<tr>\n<td>6</td>\n<td><p><b>CPU registers</b></p>\n<p>Various CPU registers where process need to be stored for execution for running state.</p></td>\n</tr>\n<tr>\n<td>7</td>\n<td><p><b>CPU Scheduling Information</b></p>\n<p>Process priority and other scheduling information  which is required to schedule the process.</p></td>\n</tr>\n<tr>\n<td>8</td>\n<td><p><b>Memory management information</b></p>\n<p>This includes the information of page table, memory limits, Segment table depending on memory used by the operating system.</p></td>\n</tr>\n<tr>\n<td>9</td>\n<td><p><b>Accounting information</b></p>\n<p>This  includes the amount of CPU used for process execution, time limits, execution ID etc.</p></td>\n</tr>\n<tr>\n<td>10</td>\n<td><p><b>IO status information</b></p>\n<p>This includes a list of I/O devices allocated to the process.</p></td>\n</tr>\n</table>\n<p>The architecture of a PCB is completely dependent on Operating System and may contain different information in different operating systems. Here is a simplified diagram of a PCB \u2212</p>\n<img alt=\"Process Control Block\" src=\"/operating_system/images/pcb.jpg\"/>\n<p>The PCB is maintained for a process throughout its lifetime, and is deleted once the process terminates.</p>\n<h1>Operating System - Process Scheduling</h1>\n<h2>Definition</h2>\n<p>The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.</p>\n<p>Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing.</p>\n<h2>Process Scheduling Queues</h2>\n<p>The OS maintains all PCBs in Process Scheduling Queues. The OS maintains a separate queue for each of the process states and PCBs of all processes in the same execution state are placed in the same queue. When the state of a process is changed, its PCB is unlinked from its current queue and moved to its new state queue.</p>\n<p>The Operating System maintains the following important process scheduling queues \u2212</p>\n<ul class=\"list\">\n<li><p><b>Job queue</b> \u2212 This queue keeps all the processes in the system.</p></li>\n<li><p><b>Ready queue</b> \u2212 This queue keeps a set of all processes residing in main memory, ready and waiting to execute. A new process is always put in this queue.</p></li>\n<li><p><b>Device queues</b> \u2212 The processes which are blocked due to unavailability of an I/O device constitute this queue.</p></li>\n</ul>\n<img alt=\"Process Scheduling Queuing\" src=\"/operating_system/images/queuing_diagram.jpg\"/>\n<p>The OS can use different policies to manage each queue (FIFO, Round Robin, Priority, etc.). The OS scheduler determines how to move processes between the ready and run queues which can only have one entry per processor core on the system; in the above diagram, it has been merged with the CPU.</p>\n<h2>Two-State Process Model</h2>\n<p>Two-state process model refers to running and non-running states which are described below \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">State &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Running</b></p>\n<p>When a new process is created, it enters into the system as in the running state.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Not Running</b></p>\n<p>Processes that are not running are kept in queue, waiting for their turn to execute. Each entry in the queue is a pointer to a particular process. Queue is implemented by using linked list. Use of dispatcher is as follows. When a process is interrupted, that process is transferred in the waiting queue. If the process has completed or aborted, the process is discarded. In either case, the dispatcher then selects a process from the queue to execute.</p>\n</td>\n</tr>\n</table>\n<h2>Schedulers</h2>\n<p>Schedulers are special system software which handle process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run. Schedulers are of three types \u2212</p>\n<ul class=\"list\">\n<li>Long-Term Scheduler</li>\n<li>Short-Term Scheduler</li>\n<li>Medium-Term Scheduler</li>\n</ul>\n<h2>Long Term Scheduler</h2>\n<p>It is also called a <b>job scheduler</b>. A long-term scheduler determines which programs are admitted to the system for processing. It selects processes from the queue and loads them into memory for execution. Process loads into the memory for CPU scheduling.</p>\n<p>The primary objective of the job scheduler is to provide a balanced mix of jobs, such as I/O bound and processor bound. It also controls the degree of multiprogramming. If the degree of multiprogramming is stable, then the average rate of process creation must be equal to the average departure rate of processes leaving the system.</p>\n<p>On some systems, the long-term scheduler may not be available or minimal. Time-sharing operating systems have no long term scheduler. When a process changes the state from new to ready, then there is use of long-term scheduler.</p>\n<h2>Short Term Scheduler</h2>\n<p>It is also called as <b>CPU scheduler</b>. Its main objective is to increase system performance in accordance with the chosen set of criteria. It is the change of ready state to running state of the process. CPU scheduler selects a process among the processes that are ready to execute and allocates CPU to one of them.</p>\n<p>Short-term schedulers, also known as dispatchers, make the decision of which process to execute next. Short-term schedulers are faster than long-term schedulers.</p>\n<h2>Medium Term Scheduler</h2>\n<p>Medium-term scheduling is a part of <b>swapping</b>. It removes the processes from the memory. It reduces the degree of multiprogramming. The medium-term scheduler is in-charge of handling the swapped out-processes.</p>\n<p>A running process may become suspended if it makes an I/O request. A suspended processes cannot make any progress towards completion. In this condition, to remove the process from memory and make space for other processes, the suspended process is moved to the secondary storage. This process is called <b>swapping</b>, and the process is said to be swapped out or rolled out. Swapping may be necessary to improve the process mix.</p>\n<h2>Comparison among Scheduler</h2>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">Long-Term Scheduler</th>\n<th style=\"text-align:center\">Short-Term Scheduler</th>\n<th style=\"text-align:center\">Medium-Term Scheduler</th>\n</tr>\n<tr>\n<td>1</td>\n<td>It is a job scheduler</td>\n<td>It is a CPU scheduler</td>\n<td>It is a process swapping scheduler.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Speed is lesser than short term scheduler</td>\n<td>Speed is fastest among other two</td>\n<td>Speed is in between both short and long term scheduler.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>It controls the degree of multiprogramming</td>\n<td>It provides lesser control over degree of multiprogramming</td>\n<td>It reduces the degree of multiprogramming.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>It is almost absent or minimal in time sharing system</td>\n<td>It is also minimal in time sharing system</td>\n<td>It is a part of Time sharing systems.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>It selects processes from pool and loads them into memory for execution</td>\n<td>It selects those processes which are ready to execute</td>\n<td>It can re-introduce the process into memory and execution can be continued.</td>\n</tr>\n</table>\n<h2>Context Switch</h2>\n<p>A context switch is the mechanism to store and restore the state or context of a CPU in Process Control block so that a process execution can be resumed from the same point at a later time. Using this technique, a context switcher enables multiple processes to share a single CPU. Context switching is an essential part of a multitasking operating system features.</p>\n<p>When the scheduler switches the CPU from executing one process to execute another, the state from the current running process is stored into the process control block. After this, the state for the process to run next is loaded from its own PCB and used to set the PC, registers, etc. At that point, the second process can start executing.</p>\n<img alt=\"Process Context Switch\" src=\"/operating_system/images/context_switch.jpg\"/>\n<p>Context switches are computationally intensive since register and memory state must be saved and restored. To avoid the amount of context switching time, some hardware systems employ two or more sets of processor registers. When the process is switched, the following information is stored for later use.</p>\n<ul class=\"list\">\n<li>Program Counter</li>\n<li>Scheduling information</li>\n<li>Base and limit register value</li>\n<li>Currently used register</li>\n<li>Changed State</li>\n<li>I/O State information</li>\n<li>Accounting information</li>\n</ul>\n<h1>Operating System Scheduling algorithms</h1>\n<p>A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are six popular process scheduling algorithms which we are going to discuss in this chapter \u2212</p>\n<ul class=\"list\">\n<li>First-Come, First-Served (FCFS) Scheduling</li>\n<li>Shortest-Job-Next (SJN) Scheduling</li>\n<li>Priority Scheduling</li>\n<li>Shortest Remaining Time</li>\n<li>Round Robin(RR) Scheduling</li>\n<li>Multiple-Level Queues Scheduling</li>\n</ul>\n<p>These algorithms are either <b>non-preemptive or preemptive</b>. Non-preemptive\nalgorithms are designed so that once a process enters the running state, it cannot be preempted until it completes its allotted time, whereas the preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state.</p>\n<h2>First Come First Serve (FCFS)</h2>\n<ul class=\"list\">\n<li>Jobs are executed on first come, first serve basis.</li>\n<li>It is a non-preemptive, pre-emptive scheduling algorithm.</li>\n<li>Easy to understand and implement.</li>\n<li>Its implementation is based on FIFO queue.</li>\n<li>Poor in performance as average wait time is high.</li>\n</ul>\n<img alt=\"First Come First Serve Scheduling Algorithm\" src=\"/operating_system/images/fcfs.jpg\"/>\n<p><b>Wait time</b> of each process is as follows \u2212</p>\n<table class=\"table table-bordered\" style=\"text-align:center\">\n<tr>\n<th style=\"width:10%;\">Process</th>\n<th style=\"text-align:center\">Wait Time : Service Time - Arrival Time</th>\n</tr>\n<tr>\n<td>P0</td>\n<td>0 - 0 = 0</td>\n</tr>\n<tr>\n<td>P1</td>\n<td>5 - 1 = 4</td>\n</tr>\n<tr>\n<td>P2</td>\n<td>8 - 2 = 6</td>\n</tr>\n<tr>\n<td>P3</td>\n<td>16 - 3 = 13</td>\n</tr>\n</table>\n<p>Average Wait Time: (0+4+6+13) / 4 = 5.75</p>\n<h2>Shortest Job Next (SJN)</h2>\n<ul class=\"list\">\n<li><p>This is also known as <b>shortest job first</b>, or SJF</p></li>\n<li><p>This is a non-preemptive, pre-emptive scheduling algorithm.</p></li>\n<li><p>Best approach to minimize waiting time.</p></li>\n<li><p>Easy to implement in Batch systems where required CPU time is known in advance.</p></li>\n<li><p>Impossible to implement in interactive systems where required CPU time is not known.</p></li>\n<li><p>The processer should know in advance how much time process will take.</p></li>\n</ul>\n<img alt=\"Shortest Job First Scheduling Algorithm\" src=\"/operating_system/images/sjf.jpg\"/>\n<p><b>Wait time</b> of each process is as follows \u2212</p>\n<table class=\"table table-bordered\" style=\"text-align:center\">\n<tr>\n<th style=\"width:10%; text-align:center\">Process</th>\n<th style=\"text-align:center\">Wait Time : Service Time - Arrival Time</th>\n</tr>\n<tr>\n<td>P0</td>\n<td>3 - 0 = 3</td>\n</tr>\n<tr>\n<td>P1</td>\n<td>0 - 0 = 0</td>\n</tr>\n<tr>\n<td>P2</td>\n<td>16 - 2 = 14</td>\n</tr>\n<tr>\n<td>P3</td>\n<td>8 - 3 = 5</td>\n</tr>\n</table>\n<p>Average Wait Time: (3+0+14+5) / 4 = 5.50</p>\n<h2>Priority Based Scheduling</h2>\n<ul class=\"list\">\n<li><p>Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems.</p></li>\n<li><p>Each process is assigned a priority. Process with highest priority is to be executed first and so on.</p></li>\n<li><p>Processes with same priority are executed on first come first served basis.</p></li>\n<li><p>Priority can be decided based on memory requirements, time requirements or any other resource requirement.</p></li>\n</ul>\n<img alt=\"Priority Scheduling Algorithm\" src=\"/operating_system/images/priority_scheduling.jpg\"/>\n<p><b>Wait time</b> of each process is as follows \u2212</p>\n<table class=\"table table-bordered\" style=\"text-align:center\">\n<tr>\n<th style=\"width:10%; text-align:center\">Process</th>\n<th style=\"text-align:center\">Wait Time : Service Time - Arrival Time</th>\n</tr>\n<tr>\n<td>P0</td>\n<td>9 - 0 = 9</td>\n</tr>\n<tr>\n<td>P1</td>\n<td>6 - 1 = 5</td>\n</tr>\n<tr>\n<td>P2</td>\n<td>14 - 2 = 12</td>\n</tr>\n<tr>\n<td>P3</td>\n<td>0 - 0 = 0</td>\n</tr>\n</table>\n<p>Average Wait Time: (9+5+12+0) / 4 = 6.5</p>\n<h2>Shortest Remaining Time</h2>\n<ul class=\"list\">\n<li><p>Shortest remaining time (SRT) is the preemptive version of the SJN algorithm.</p></li>\n<li><p>The processor is allocated to the job closest to completion but it can be preempted by a newer ready job with shorter time to completion.</p></li>\n<li><p>Impossible to implement in interactive systems where required CPU time is not known.</p></li>\n<li><p>It is often used in batch environments where short jobs need to give preference.</p></li>\n</ul>\n<h2>Round Robin Scheduling</h2>\n<ul class=\"list\">\n<li><p>Round Robin is the preemptive process scheduling algorithm.</p></li>\n<li><p>Each process is provided a fix time to execute, it is called a <b>quantum</b>.</p></li>\n<li><p>Once a process is executed for a given time period, it is preempted and other process executes for a given time period.</p></li>\n<li><p>Context switching is used to save states of preempted processes.</p></li>\n</ul>\n<img alt=\"Round Robin Scheduling Algorithm\" src=\"/operating_system/images/round_robin.jpg\"/>\n<p><b>Wait time</b> of each process is as follows \u2212</p>\n<table class=\"table table-bordered\" style=\"text-align:center\">\n<tr>\n<th style=\"width:10%; text-align:center\">Process</th>\n<th style=\"text-align:center\">Wait Time : Service Time - Arrival Time</th>\n</tr>\n<tr>\n<td>P0</td>\n<td>(0 - 0) + (12 - 3) = 9</td>\n</tr>\n<tr>\n<td>P1</td>\n<td>(3 - 1) = 2</td>\n</tr>\n<tr>\n<td>P2</td>\n<td>(6 - 2) + (14 - 9) + (20 - 17) = 12</td>\n</tr>\n<tr>\n<td>P3</td>\n<td>(9 - 3) + (17 - 12) = 11</td>\n</tr>\n</table>\n<p>Average Wait Time: (9+2+12+11) / 4 = 8.5</p>\n<h2>Multiple-Level Queues Scheduling</h2>\n<p>Multiple-level queues are not an independent scheduling algorithm. They make use of other existing algorithms to group and schedule jobs with common characteristics.</p>\n<ul class=\"list\">\n<li>Multiple queues are maintained for processes with common characteristics.</li>\n<li>Each queue can have its own scheduling algorithms.</li>\n<li>Priorities are assigned to each queue.</li>\n</ul>\n<p>For example, CPU-bound jobs can be scheduled in one queue and all I/O-bound jobs in another queue. The Process Scheduler then alternately selects jobs from each queue and assigns them to the CPU based on the algorithm assigned to the queue.</p>\n<h1>Operating System - Multi-Threading</h1>\n<h2>What is Thread?</h2>\n<p>A thread is a flow of execution through the process code, with its own program counter that keeps track of which instruction to execute next, system registers which hold its current working variables, and a stack which contains the execution history.</p>\n<p>A thread shares with its peer threads few information like code segment, data segment and open files. When one thread alters a code segment memory item, all other threads see that.</p>\n<p>A thread is also called a <b>lightweight process</b>. Threads provide a way to improve application performance through parallelism. Threads represent a software approach to improving performance of operating system by reducing the overhead thread is equivalent to a classical process.</p>\n<p>Each thread belongs to exactly one process and no thread can exist outside a process. Each thread represents a separate flow of control. Threads have been successfully used in implementing network servers and web server. They also provide a suitable foundation for parallel execution of applications on shared memory multiprocessors. The following figure shows the working of a single-threaded and a multithreaded process.</p>\n<img alt=\"Single vs Multithreaded Process\" src=\"/operating_system/images/thread_processes.jpg\"/>\n<h2>Difference between Process and Thread</h2>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"width:45%;\">Process</th>\n<th>Thread</th>\n</tr>\n<tr>\n<td>1</td>\n<td>Process is heavy weight or resource intensive.</td>\n<td>Thread is light weight, taking lesser resources than a process.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Process switching needs interaction with operating system.</td>\n<td>Thread switching does not need to interact with operating system.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>In multiple processing environments, each process executes the same code but has its own memory and file resources.</td>\n<td>All threads can share same set of open files, child processes.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>If one process is blocked, then no other process can execute until the first process is unblocked.</td>\n<td>While one thread is blocked and waiting, a second thread in the same task can run.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Multiple processes without using threads use more resources.</td>\n<td>Multiple threaded processes use fewer resources.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>In multiple processes each process operates independently of the others.</td>\n<td>One thread can read, write or change another thread's data.</td>\n</tr>\n</table>\n<h2>Advantages of Thread</h2>\n<ul class=\"list\">\n<li>Threads minimize the context switching time.</li>\n<li>Use of threads provides concurrency within a process.</li>\n<li>Efficient communication.</li>\n<li>It is more economical to create and context switch threads.</li>\n<li>Threads allow utilization of multiprocessor architectures to a greater scale and efficiency.</li>\n</ul>\n<h2>Types of Thread</h2>\n<p>Threads are implemented in following two ways \u2212</p>\n<ul class=\"list\">\n<li><p><b>User Level Threads</b> \u2212 User managed threads.</p></li>\n<li><p><b>Kernel Level Threads</b> \u2212 Operating System managed threads acting on kernel, an operating system core.</p></li>\n</ul>\n<h2>User Level Threads</h2>\n<p>In this case, the thread management kernel is not aware of the existence of threads. The thread library contains code for creating and destroying threads, for passing message and data between threads, for scheduling thread execution and for saving and restoring thread contexts. The application starts with a single thread.</p>\n<img alt=\"User level thread\" src=\"/operating_system/images/user_threads.jpg\"/>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li>Thread switching does not require Kernel mode privileges.</li>\n<li>User level thread can run on any operating system.</li>\n<li>Scheduling can be application specific in the user level thread.</li>\n<li>User level threads are fast to create and manage.</li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li>In a typical operating system, most system calls are blocking.</li>\n<li>Multithreaded application cannot take advantage of multiprocessing.</li>\n</ul>\n<h2>Kernel Level Threads</h2>\n<p>In this case, thread management is done by the Kernel. There is no thread management code in the application area. Kernel threads are supported directly by the operating system. Any application can be programmed to be multithreaded. All of the threads within an application are supported within a single process.</p>\n<p>The Kernel maintains context information for the process as a whole and for individuals threads within the process. Scheduling by the Kernel is done on a thread basis. The Kernel performs thread creation, scheduling and management in Kernel space. Kernel threads are generally slower to create and manage than the user threads.</p>\n<h3>Advantages</h3>\n<ul class=\"list\">\n<li>Kernel can simultaneously schedule multiple threads from the same process on multiple processes.</li>\n<li>If one thread in a process is blocked, the Kernel can schedule another thread of the same process.</li>\n<li>Kernel routines themselves can be multithreaded.</li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li>Kernel threads are generally slower to create and manage than the user threads.</li>\n<li>Transfer of control from one thread to another within the same process requires a mode switch to the Kernel.</li>\n</ul>\n<h2>Multithreading Models</h2>\n<p>Some operating system provide a combined user level thread and Kernel level thread facility. Solaris is a good example of this combined approach. In a combined system, multiple threads within the same application can run in parallel on multiple processors and a blocking system call need not block the entire process. Multithreading models are three types</p>\n<ul class=\"list\">\n<li>Many to many relationship.</li>\n<li>Many to one relationship.</li>\n<li>One to one relationship.</li>\n</ul>\n<h2>Many to Many Model</h2>\n<p>The many-to-many model multiplexes any number of user threads onto an equal or smaller number of kernel threads.</p>\n<p>The following diagram shows the many-to-many threading model where 6 user level threads are multiplexing with 6 kernel level threads. In this model, developers can create as many user threads as necessary and the corresponding Kernel threads can run in parallel on a multiprocessor machine. This model provides the best accuracy on concurrency and when a thread performs a blocking system call, the kernel can schedule another thread for execution.</p>\n<img alt=\"Many to many thread model\" src=\"/operating_system/images/many_to_many.jpg\"/>\n<h2>Many to One Model</h2>\n<p>Many-to-one model maps many user level threads to one Kernel-level thread. Thread management is done in user space by the thread library. When thread makes a blocking system call, the entire process will be blocked. Only one thread can access the Kernel at a time, so multiple threads are unable to run in parallel on multiprocessors.</p>\n<p>If the user-level thread libraries are implemented in the operating system in such a way that the system does not support them, then the Kernel threads use the many-to-one relationship modes.</p>\n<img alt=\"Many to one thread model\" src=\"/operating_system/images/many_to_one.jpg\"/>\n<h2>One to One Model</h2>\n<p>There is one-to-one relationship of user-level thread to the kernel-level thread. This model provides more concurrency than the many-to-one model. It also allows another thread to run when a thread makes a blocking system call. It supports multiple threads to execute in parallel on microprocessors.</p>\n<p>Disadvantage of this model is that creating user thread requires the corresponding Kernel thread. OS/2, windows NT and windows 2000 use one to one relationship model.</p>\n<img alt=\"One to one thread model\" src=\"/operating_system/images/one_to_one.jpg\"/>\n<h2>Difference between User-Level &amp; Kernel-Level Thread</h2>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%; text-align:center\">S.N.</th>\n<th style=\"width:45%; text-align:center\">User-Level Threads</th>\n<th style=\"width:45%; text-align:center\">Kernel-Level Thread</th>\n</tr>\n<tr>\n<td>1</td>\n<td>User-level threads are faster to create and manage.</td>\n<td>Kernel-level threads are slower to create and manage.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Implementation is by a thread library at the user level.</td>\n<td>Operating system supports creation of Kernel threads.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>User-level thread is generic and can run on any operating system.</td>\n<td>Kernel-level thread is specific to the operating system.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Multi-threaded applications cannot take advantage of multiprocessing.</td>\n<td>Kernel routines themselves can be multithreaded.</td>\n</tr>\n</table>\n<h1>Operating System - Memory Management</h1>\n<p>Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or unallocated and correspondingly it updates the status.</p>\n<p>This tutorial will teach you basic concepts related to Memory Management.</p>\n<h2>Process Address Space</h2>\n<p>The process address space is the set of logical addresses that a process references in its code. For example, when 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes.</p>\n<p>The operating system takes care of mapping the logical addresses to physical addresses at the time of memory allocation to the program. There are three types of addresses used in a program before and after memory is allocated \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th>S.N.</th>\n<th style=\"text-align:center\">Memory Addresses &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td>\n<p><b>Symbolic addresses</b></p>\n<p>The addresses used in a source code. The variable names, constants, and instruction labels are the basic elements of the symbolic address space.</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td>\n<p><b>Relative addresses</b></p>\n<p>At the time of compilation, a compiler converts symbolic addresses into relative\naddresses.</p>\n</td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Physical addresses</b></p>\n<p>The loader generates these addresses at the time when a program is loaded into main memory.</p>\n</td>\n</tr>\n</table>\n<p>Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. Virtual and physical addresses differ in execution-time address-binding scheme.</p>\n<p>The set of all logical addresses generated by a program is referred to as a <b>logical address space</b>. The set of all physical addresses corresponding to these logical addresses is referred to as a <b>physical address space.</b></p>\n<p>The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device. MMU uses following mechanism to convert virtual address to physical address.</p>\n<ul class=\"list\">\n<li><p>The value in the base register is added to every address generated by a user process, which is treated as offset at the time it is sent to memory. For example, if the base register value is 10000, then an attempt by the user to use address location 100 will be dynamically reallocated to location 10100.</p></li>\n<li><p>The user program deals with virtual addresses; it never sees the real physical addresses.</p></li>\n</ul>\n<h2>Static vs Dynamic Loading</h2>\n<p>The choice between Static or Dynamic Loading is to be made at the time of computer program being developed. If you have to load your program statically, then at the time of compilation, the complete programs will be compiled and linked without leaving any external program or module dependency. The linker combines the object program with other necessary object modules into an absolute program, which also includes logical addresses.</p>\n<p>If you are writing a Dynamically loaded program, then your compiler will compile the program and for all the modules which you want to include dynamically, only references will be provided and rest of the work will be done at the time of execution.</p>\n<p>At the time of loading, with <b>static loading</b>, the absolute program (and data) is loaded into memory in order for execution to start.</p>\n<p>If you are using <b>dynamic loading</b>, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program.</p>\n<h2>Static vs Dynamic Linking</h2>\n<p>As explained above, when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.</p>\n<p>When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking. Dynamic Link Libraries (DLL) in Windows and Shared Objects in Unix are good examples of dynamic libraries.</p>\n<h2>Swapping</h2>\n<p>Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory.</p>\n<p>Though performance is usually affected by swapping process but it helps in running multiple and big processes in parallel and that's the reason <b>Swapping is also known as a technique for memory compaction</b>.</p>\n<img alt=\"Process Swapping\" src=\"/operating_system/images/process_swapping.jpg\"/>\n<p>The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, as well as the time the process takes to regain main memory.</p>\n<p>Let us assume that the user process is of size 2048KB and on a standard hard disk where swapping will take place has a data transfer rate around 1 MB per second. The actual transfer of the 1000K process to or from memory will take</p>\n<pre class=\"result notranslate\">\n2048KB / 1024KB per second\n= 2 seconds\n= 2000 milliseconds\n</pre>\n<p>Now considering in and out time, it will take complete 4000 milliseconds plus other overhead where the process competes to regain main memory.</p>\n<h2>Memory Allocation</h2>\n<p>Main memory usually has two partitions \u2212</p>\n<ul class=\"list\">\n<li><p><b>Low Memory</b> \u2212 Operating system resides in this memory.</p></li>\n<li><p><b>High Memory</b> \u2212 User processes are held in high memory.</p></li>\n</ul>\n<p>Operating system uses the following memory allocation mechanism.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th>S.N.</th>\n<th style=\"text-align:center\">Memory Allocation &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Single-partition allocation</b></p>\n<p>In this type of allocation, relocation-register scheme is used to protect user processes from each other, and from changing operating-system code and data. Relocation register contains value of smallest physical address whereas limit register contains range of logical addresses. Each logical address must be less than the limit register.</p></td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Multiple-partition allocation</b></p>\n<p>In this type of allocation, main memory is divided into a number of fixed-sized\npartitions where each partition should contain only one process. When a partition\nis free, a process is selected from the input queue and is loaded into the free\npartition. When the process terminates, the partition becomes available for\nanother process.</p></td>\n</tr>\n</table>\n<h2>Fragmentation</h2>\n<p>As processes are loaded and removed from memory, the free memory space is broken into little pieces. It happens after sometimes that processes cannot be allocated to memory blocks considering their small size and memory blocks remains unused. This problem is known as Fragmentation.</p>\n<p>Fragmentation is of two types \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th>S.N.</th>\n<th style=\"text-align:center\">Fragmentation &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>External fragmentation</b></p>\n<p>Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used.</p></td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Internal fragmentation</b></p>\n<p>Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.</p></td>\n</tr>\n</table>\n<p>The following diagram shows how fragmentation can cause waste of memory and a compaction technique can be used to create more free memory out of fragmented memory \u2212</p>\n<img alt=\"Memory Fragmentation\" src=\"/operating_system/images/memory_fragmentation.jpg\"/>\n<p>External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction feasible, relocation should be dynamic.</p>\n<p>The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.</p>\n<h2>Paging</h2>\n<p>A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard that's set up to emulate the computer's RAM. Paging technique plays an important role in implementing virtual memory.</p>\n<p>Paging is a memory management technique in which process address space is broken into blocks of the same size called <b>pages</b> (size is power of 2, between 512 bytes and 8192 bytes). The size of the process is measured in the number of pages.</p>\n<p>Similarly, main memory is divided into small fixed-sized blocks of (physical) memory called <b>frames</b> and the size of a frame is kept the same as that of a page to have optimum utilization of the main memory and to avoid external fragmentation.</p>\n<img alt=\"Paging\" src=\"/operating_system/images/paging.jpg\"/>\n<h3>Address Translation</h3>\n<p>Page address is called <b>logical address</b> and represented by <b>page number</b> and the <b>offset</b>.</p>\n<pre class=\"result notranslate\">\nLogical Address = Page number + page offset\n</pre>\n<p>Frame address is called <b>physical address</b> and represented by a <b>frame number</b> and the <b>offset</b>.</p>\n<pre class=\"result notranslate\">\nPhysical Address = Frame number + page offset\n</pre>\n<p>A data structure called <b>page map table</b> is used to keep track of the relation between a page of a process to a frame in physical memory.</p>\n<img alt=\"Page Map Table\" src=\"/operating_system/images/page_map_table.jpg\"/>\n<p>When the system allocates a frame to any page, it translates this logical address into a physical address and create entry into the page table to be used throughout execution of the program.</p>\n<p>When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program.</p>\n<p>This process continues during the whole execution of the program where the OS keeps removing idle pages from the main memory and write them onto the secondary memory and bring them back when required by the program.</p>\n<h3>Advantages and Disadvantages of Paging</h3>\n<p>Here is a list of advantages and disadvantages of paging \u2212</p>\n<ul class=\"list\">\n<li><p>Paging reduces external fragmentation, but still suffer from internal fragmentation.</p></li>\n<li><p>Paging is simple to implement and assumed as an efficient memory management technique.</p></li>\n<li><p>Due to equal size of the pages and frames, swapping becomes very easy.</p></li>\n<li><p>Page table requires extra memory space, so may not be good for a system having small RAM.</p></li>\n</ul>\n<h2>Segmentation</h2>\n<p>Segmentation is a memory management technique in which each job is divided into several segments of different sizes, one for each module that contains pieces that perform related functions. Each segment is actually a different logical address space of the program.</p>\n<p>When a process is to be executed, its corresponding segmentation are loaded into non-contiguous memory though every segment is loaded into a contiguous block of available memory.</p>\n<p>Segmentation memory management works very similar to paging but here segments are of variable-length where as in paging pages are of fixed size.</p>\n<p>A program segment contains the program's main function, utility functions, data structures, and so on. The operating system maintains a <b>segment map table</b> for every process and a list of free memory blocks along with segment numbers, their size and corresponding memory locations in main memory. For each segment, the table stores the starting address of the segment and the length of the segment. A reference to a memory location includes a value that identifies a segment and an offset.</p>\n<img alt=\"Segment Map Table\" src=\"/operating_system/images/segment_map_table.jpg\"/>\n<h1>Operating System - Virtual Memory</h1>\n<p>A computer can address more memory than the amount physically installed on the system. This extra memory is actually called <b>virtual memory</b> and it is a section of a hard disk that's set up to emulate the computer's RAM.</p>\n<p>The main visible advantage of this scheme is that programs can be larger than physical memory. Virtual memory serves two purposes. First, it allows us to extend the use of physical memory by using disk. Second, it allows us to have memory protection, because each virtual address is translated to a physical address.</p>\n<p>Following are the situations, when entire program is not required to be loaded fully in main memory.</p>\n<ul class=\"list\">\n<li><p>User written error handling routines are used only when an error occurred in the data or computation.</p></li>\n<li><p>Certain options and features of a program may be used rarely.</p></li>\n<li><p>Many tables are assigned a fixed amount of address space even though only a small amount of the table is actually used.</p></li>\n<li><p>The ability to execute a program that is only partially in memory would counter many benefits.</p></li>\n<li><p>Less number of I/O would be needed to load or swap each user program into memory.</p></li>\n<li><p>A program would no longer be constrained by the amount of physical memory that is available.</p></li>\n<li><p>Each user program could take less physical memory, more programs could be run the same time, with a corresponding increase in CPU utilization and throughput.</p></li>\n</ul>\n<p>Modern microprocessors intended for general-purpose use, a memory management unit, or MMU, is built into the hardware. The MMU's job is to translate virtual addresses into physical addresses. A basic example is given below \u2212</p>\n<img alt=\"Virtual Memory\" src=\"/operating_system/images/virtual_memory.jpg\"/>\n<p>Virtual memory is commonly implemented by demand paging. It can also be implemented in a segmentation system. Demand segmentation can also be used to provide virtual memory.</p>\n<h2>Demand Paging</h2>\n<p>A demand paging system is quite similar to a paging system with swapping where processes reside in secondary memory and pages are loaded only on demand, not in advance. When a context switch occurs, the operating system does not copy any of the old program\u2019s pages out to the disk or any of the new program\u2019s pages into the main memory Instead, it just begins executing the new program after loading the first page and fetches that program\u2019s pages as they are referenced.</p>\n<img alt=\"Demand Paging\" src=\"/operating_system/images/demand_paging.jpg\"/>\n<p>While executing a program, if the program references a page which is not available in the main memory because it was swapped out a little ago, the processor treats this invalid memory reference as a <b>page fault</b> and transfers control from the program to the operating system to demand the page back into the memory.</p>\n<h3>Advantages</h3>\n<p>Following are the advantages of Demand Paging \u2212</p>\n<ul class=\"list\">\n<li>Large virtual memory.</li>\n<li>More efficient use of memory.</li>\n<li>There is no limit on degree of multiprogramming.</li>\n</ul>\n<h3>Disadvantages</h3>\n<ul class=\"list\">\n<li><p>Number of tables and the amount of processor overhead for handling page interrupts are greater than in the case of the simple paged management techniques.</p></li>\n</ul>\n<h2>Page Replacement Algorithm</h2>\n<p>Page replacement algorithms are the techniques using which an Operating System decides which memory pages to swap out, write to disk when a page of memory needs to be allocated. Paging happens whenever a page fault occurs and a free page cannot be used for allocation purpose accounting to reason that pages are not available or the number of free pages is lower than required pages.</p>\n<p>When the page that was selected for replacement and was paged out, is referenced again, it has to read in from disk, and this requires for I/O completion. This process determines the quality of the page replacement algorithm: the lesser the time waiting for page-ins, the better is the algorithm.</p>\n<p>A page replacement algorithm looks at the limited information about accessing the pages provided by hardware, and tries to select which pages should be replaced to minimize the total number of page misses, while balancing it with the costs of primary storage and processor time of the algorithm itself. There are many different page replacement algorithms. We evaluate an algorithm by running it on a particular string of memory reference and computing the number of page faults,</p>\n<h2>Reference String</h2>\n<p>The string of memory references is called reference string. Reference strings are generated artificially or by tracing a given system and recording the address of each memory reference. The latter choice produces a large number of data, where we note two things.</p>\n<ul class=\"list\">\n<li><p>For a given page size, we need to consider only the page number, not the entire address.</p></li>\n<li><p>If we have a reference to a page <b>p</b>, then any immediately following references to page <b>p</b> will never cause a page fault. Page p will be in memory after the first reference; the immediately following references will not fault.</p></li>\n<li><p>For example, consider the following sequence of addresses \u2212 123,215,600,1234,76,96</p></li>\n<li><p>If page size is 100, then the reference string is 1,2,6,12,0,0</p></li>\n</ul>\n<h2>First In First Out (FIFO) algorithm</h2>\n<ul class=\"list\">\n<li><p>Oldest page in main memory is the one which will be selected for replacement.</p></li>\n<li><p>Easy to implement, keep a list, replace pages from the tail and add new pages at the head.</p></li>\n</ul>\n<img alt=\"First In First Out\" src=\"/operating_system/images/fifo.jpg\"/>\n<h2>Optimal Page algorithm</h2>\n<ul class=\"list\">\n<li><p>An optimal page-replacement algorithm has the lowest page-fault rate of all algorithms. An optimal page-replacement algorithm exists, and has been called OPT or MIN.</p></li>\n<li><p>Replace the page that will not be used for the longest period of time. Use the time when a page is to be used.</p></li>\n</ul>\n<img alt=\"Optimal page replacement\" src=\"/operating_system/images/opr.jpg\"/>\n<h2>Least Recently Used (LRU) algorithm</h2>\n<ul class=\"list\">\n<li><p>Page which has not been used for the longest time in main memory is the one which will be selected for replacement.</p></li>\n<li><p>Easy to implement, keep a list, replace pages by looking back into time.</p></li>\n</ul>\n<img alt=\"Least Recently Used\" src=\"/operating_system/images/lru.jpg\"/>\n<h2>Page Buffering algorithm</h2>\n<ul class=\"list\">\n<li>To get a process start quickly, keep a pool of free frames.</li>\n<li>On page fault, select a page to be replaced.</li>\n<li>Write the new page in the frame of free pool, mark the page table and restart the process.</li>\n<li>Now write the dirty page out of disk and place the frame holding replaced page in free pool.</li>\n</ul>\n<h2>Least frequently Used(LFU) algorithm</h2>\n<ul class=\"list\">\n<li><p>The page with the smallest count is the one which will be selected for replacement.</p></li>\n<li><p>This algorithm suffers from the situation in which a page is used heavily during the initial phase of a process, but then is never used again.</p></li>\n</ul>\n<h2>Most frequently Used(MFU) algorithm</h2>\n<ul class=\"list\">\n<li><p>This algorithm is based on the argument that the page with the smallest count was probably just brought in and has yet to be used.</p></li>\n</ul>\n<h1>Operating System - I/O Hardware</h1>\n<p>One of the important jobs of an Operating System is to manage various I/O devices including mouse, keyboards, touch pad, disk drives, display adapters, USB devices, Bit-mapped screen, LED, Analog-to-digital converter, On/off switch, network connections, audio I/O, printers etc.</p>\n<p>An I/O system is required to take an application I/O request and send it to the physical device, then take whatever response comes back from the device and send it to the application. I/O devices can be divided into two categories \u2212</p>\n<ul class=\"list\">\n<li><p><b>Block devices</b> \u2212 A block device is one with which the driver communicates by sending entire blocks of data. For example, Hard disks, USB cameras, Disk-On-Key etc.</p></li>\n<li><p><b>Character devices</b> \u2212 A character device is one with which the driver communicates by sending and receiving single characters (bytes, octets). For example, serial ports, parallel ports, sounds cards etc</p></li>\n</ul>\n<h2>Device Controllers</h2>\n<p>Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices.</p>\n<p>The Device Controller works like an interface between a device and a device driver. I/O units (Keyboard, mouse, printer, etc.) typically consist of a mechanical component and an electronic component where electronic component is called the device controller.</p>\n<p>There is always a device controller and a device driver for each device to communicate with the Operating Systems. A device controller may be able to handle multiple devices. As an interface its main task is to convert serial bit stream to block of bytes, perform error correction as necessary.</p>\n<p>Any device connected to the computer is connected by a plug and socket, and the socket is connected to a device controller. Following is a model for connecting the CPU, memory, controllers, and I/O devices where CPU and device controllers all use a common bus for communication.</p>\n<img alt=\"Device Controllers\" src=\"/operating_system/images/device_controllers.jpg\"/>\n<h2>Synchronous vs asynchronous I/O</h2>\n<ul class=\"list\">\n<li><p><b>Synchronous I/O</b> \u2212 In this scheme CPU execution waits while I/O proceeds</p></li>\n<li><p><b>Asynchronous I/O</b> \u2212 I/O proceeds concurrently with CPU execution</p></li>\n</ul>\n<h2>Communication to I/O Devices</h2>\n<p>The CPU must have a way to pass information to and from an I/O device. There are three approaches available to communicate with the CPU and Device.</p>\n<ul class=\"list\">\n<li>Special Instruction I/O</li>\n<li>Memory-mapped I/O</li>\n<li>Direct memory access (DMA)</li>\n</ul>\n<h3>Special Instruction I/O</h3>\n<p>This uses CPU instructions that are specifically made for controlling I/O devices. These instructions typically allow data to be sent to an I/O device or read from an I/O device.</p>\n<h3>Memory-mapped I/O</h3>\n<p>When using memory-mapped I/O, the same address space is shared by memory and I/O devices. The device is connected directly to certain main memory locations so that I/O device can transfer block of data to/from memory without going through CPU.</p>\n<img alt=\"Memory-mapped I/O\" src=\"/operating_system/images/memory_mapped_io.jpg\"/>\n<p>While using memory mapped IO, OS allocates buffer in memory and informs I/O device to use that buffer to send data to the CPU. I/O device operates asynchronously with CPU, interrupts CPU when finished.</p>\n<p>The advantage to this method is that every instruction which can access memory can be used to manipulate an I/O device. Memory mapped IO is used for most high-speed I/O devices like disks, communication interfaces.</p>\n<h2>Direct Memory Access (DMA)</h2>\n<p>Slow devices like keyboards will generate an interrupt to the main CPU after each byte is transferred. If a fast device such as a disk generated an interrupt for each byte, the operating system would spend most of its time handling these interrupts. So a typical computer uses direct memory access (DMA) hardware to reduce this overhead.</p>\n<p>Direct Memory Access (DMA) means CPU grants I/O module authority to read from or write to memory without involvement. DMA module itself controls exchange of data between main memory and the I/O device. CPU is only involved at the beginning and end of the transfer and interrupted only after entire block has been transferred.</p>\n<p>Direct Memory Access needs a special hardware called DMA controller (DMAC) that manages the data transfers and arbitrates access to the system bus. The controllers are programmed with source and destination pointers (where to read/write the data), counters to track the number of transferred bytes, and settings, which includes I/O and memory types, interrupts and states for the CPU cycles.</p>\n<img alt=\"DMA\" src=\"/operating_system/images/dma.jpg\"/>\n<p>The operating system uses the DMA hardware as follows \u2212</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">Step</th>\n<th style=\"text-align:center\">Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td>Device driver is instructed to transfer disk data to a buffer address X.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Device driver then instruct disk controller to transfer data to buffer.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Disk controller starts DMA transfer.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Disk controller sends each byte to DMA controller.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DMA controller transfers bytes to buffer, increases the memory address, decreases the counter C until C becomes zero.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>When C becomes zero, DMA interrupts CPU to signal transfer completion.</td>\n</tr>\n</table>\n<h2>Polling vs Interrupts I/O</h2>\n<p>A computer must have a way of detecting the arrival of any type of input. There are two ways that this can happen, known as <b>polling</b> and <b>interrupts</b>. Both of these techniques allow the processor to deal with events that can happen at any time and that are not related to the process it is currently running.</p>\n<h3>Polling I/O</h3>\n<p>Polling is the simplest way for an I/O device to communicate with the processor. The process of periodically checking status of the device to see if it is time for the next I/O operation, is called polling. The I/O device simply puts the information in a Status register, and the processor must come and get the information.</p>\n<p>Most of the time, devices will not require attention and when one does it will have to wait until it is next interrogated by the polling program. This is an inefficient method and much of the processors time is wasted on unnecessary polls.</p>\n<p>Compare this method to a teacher continually asking every student in a class, one after another, if they need help. Obviously the more efficient method would be for a student to inform the teacher whenever they require assistance.</p>\n<h3>Interrupts I/O</h3>\n<p>An alternative scheme for dealing with I/O is the interrupt-driven method. An interrupt is a signal to the microprocessor from a device that requires attention.</p>\n<p>A device controller puts an interrupt signal on the bus when it needs CPU\u2019s attention when CPU receives an interrupt, It saves its current state and invokes the appropriate interrupt handler using the interrupt vector (addresses of OS routines to handle various events). When the interrupting device has been dealt with, the CPU continues with its original task as if it had never been interrupted.</p>\n<h1>Operating System - I/O Softwares</h1>\n<p>I/O software is often organized in the following layers \u2212</p>\n<ul class=\"list\">\n<li><p><b>User Level Libraries</b> \u2212 This provides simple interface to the user program to perform input and output. For example, <b>stdio</b> is a library provided by C and C++ programming languages.</p></li>\n<li><p><b>Kernel Level Modules</b> \u2212 This provides device driver to interact with the device controller and device independent I/O modules used by the device drivers.</p></li>\n<li><p><b>Hardware</b> \u2212 This layer includes actual hardware and hardware controller which interact with the device drivers and makes hardware alive.</p></li>\n</ul>\n<p>A key concept in the design of I/O software is that it should be device independent where it should be possible to write programs that can access any I/O device without having to specify the device in advance. For example, a program that reads a file as input should be able to read a file on a floppy disk, on a hard disk, or on a CD-ROM, without having to modify the program for each different device.</p>\n<img alt=\"I/O Softwares\" src=\"/operating_system/images/io_software.jpg\"/>\n<h2>Device Drivers</h2>\n<p>Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices. Device drivers encapsulate device-dependent code and implement a standard interface in such a way that code contains device-specific register reads/writes. Device driver, is generally written by the device's manufacturer and delivered along with the device on a CD-ROM.</p>\n<p>A device driver performs the following jobs \u2212</p>\n<ul class=\"list\">\n<li>To accept request from the device independent software above to it.</li>\n<li>Interact with the device controller to take and give I/O and perform required error handling</li>\n<li>Making sure that the request is executed successfully</li>\n</ul>\n<p>How a device driver handles a request is as follows: Suppose a request comes to read a block N. If the driver is idle at the time a request arrives, it starts carrying out the request immediately. Otherwise, if the driver is already busy with some other request, it places the new request in the queue of pending requests.</p>\n<h2>Interrupt handlers</h2>\n<p>An interrupt handler, also known as an interrupt service routine or ISR, is a piece of software or more specifically a callback function in an operating system or more specifically in a device driver, whose execution is triggered by the reception of an interrupt.</p>\n<p>When the interrupt happens, the interrupt procedure does whatever it has to in order to handle the interrupt, updates data structures and wakes up process that was waiting for an interrupt to happen.</p>\n<p>The interrupt mechanism accepts an address \u2500 a number that selects a specific interrupt handling routine/function from a small set. In most architectures, this address is an offset stored in a table called the interrupt vector table. This vector contains the memory addresses of specialized interrupt handlers.</p>\n<h2>Device-Independent I/O Software</h2>\n<p>The basic function of the device-independent software is to perform the I/O functions that are common to all devices and to provide a uniform interface to the user-level software. Though it is difficult to write completely device independent software but we can write some modules which are common among all the devices. Following is a list of functions of device-independent I/O Software \u2212</p>\n<ul class=\"list\">\n<li>Uniform interfacing for device drivers</li>\n<li>Device naming - Mnemonic names mapped to Major and Minor device numbers</li>\n<li>Device protection</li>\n<li>Providing a device-independent block size</li>\n<li>Buffering because data coming off a device cannot be stored in final destination.</li>\n<li>Storage allocation on block devices</li>\n<li>Allocation and releasing dedicated devices</li>\n<li>Error Reporting</li>\n</ul>\n<h2>User-Space I/O Software</h2>\n<p>These are the libraries which provide richer and simplified interface to access the functionality of the kernel or ultimately interactive with the device drivers. Most of the user-level I/O software consists of library procedures with some exception like spooling system which is a way of dealing with dedicated I/O devices in a multiprogramming system.</p>\n<p>I/O Libraries (e.g., stdio) are in user-space to provide an interface to the OS resident device-independent I/O SW. For example putchar(), getchar(), printf() and scanf() are example of user level I/O library stdio available in C programming.</p>\n<h2>Kernel I/O Subsystem</h2>\n<p>Kernel I/O Subsystem is responsible to provide many services related to I/O. Following are some of the services provided.</p>\n<ul class=\"list\">\n<li><p><b>Scheduling</b> \u2212 Kernel schedules a set of I/O requests to determine a good order in which to execute them. When an application issues a blocking I/O system call, the request is placed on the queue for that device. The Kernel I/O scheduler rearranges the order of the queue to improve the overall system efficiency and the average response time experienced by the applications.</p></li>\n<li><p><b>Buffering</b> \u2212 Kernel I/O Subsystem maintains a memory area known as <b>buffer</b> that stores data while they are transferred between two devices or between a device with an application operation. Buffering is done to cope with a speed mismatch between the producer and consumer of a data stream or to adapt between devices that have different data transfer sizes.</p></li>\n<li><p><b>Caching</b> \u2212 Kernel maintains cache memory which is region of fast memory that holds copies of data. Access to the cached copy is more efficient than access to the original.</p></li>\n<li><p><b>Spooling and Device Reservation</b> \u2212 A spool is a buffer that holds output for a device, such as a printer, that cannot accept interleaved data streams. The spooling system copies the queued spool files to the printer one at a time. In some operating systems, spooling is managed by a system daemon process. In other operating systems, it is handled by an in kernel thread.</p></li>\n<li><p><b>Error Handling</b> \u2212 An operating system that uses protected memory can guard against many kinds of hardware and application errors.</p></li>\n</ul>\n<h1>Operating System - File System</h1>\n<h2>File</h2>\n<p>A file is a named collection of related information that is recorded on secondary storage such as magnetic disks, magnetic tapes and optical disks. In general, a file is a sequence of bits, bytes, lines or records whose meaning is defined by the files creator and user.</p>\n<h2>File Structure</h2>\n<p>A File Structure should be according to a required format that the operating system can understand.</p>\n<ul class=\"list\">\n<li><p>A file has a certain defined structure according to its type.</p></li>\n<li><p>A text file is a sequence of characters organized into lines.</p></li>\n<li><p>A source file is a sequence of procedures and functions.</p></li>\n<li><p>An object file is a sequence of bytes organized into blocks that are understandable by the machine.</p></li>\n<li><p>When operating system defines different file structures, it also contains the code to support these file structure. Unix, MS-DOS support minimum number of file structure.</p></li>\n</ul>\n<h2>File Type</h2>\n<p>File type refers to the ability of the operating system to distinguish different types of file such as text files source files and binary files etc. Many operating systems support many types of files. Operating system like MS-DOS and UNIX have the following types of files \u2212</p>\n<h3>Ordinary files</h3>\n<ul class=\"list\">\n<li>These are the files that contain user information.</li>\n<li>These may have text, databases or executable program.</li>\n<li>The user can apply various operations on such files like add, modify, delete or even remove the entire file.</li>\n</ul>\n<h3>Directory files</h3>\n<ul class=\"list\">\n<li>These files contain list of file names and other information related to these files.</li>\n</ul>\n<h3>Special files</h3>\n<ul class=\"list\">\n<li>These files are also known as device files.</li>\n<li>These files represent physical device like disks, terminals, printers, networks, tape drive etc.</li>\n</ul>\n<p>These files are of two types \u2212</p>\n<ul class=\"list\">\n<li><p><b>Character special files</b> \u2212 data is handled character by character as in case of terminals or printers.</p></li>\n<li><p><b>Block special files</b> \u2212 data is handled in blocks as in the  case of disks and tapes.</p></li>\n</ul>\n<h2>File Access Mechanisms</h2>\n<p>File access mechanism refers to the manner in which the records of a file may be accessed. There are several ways to access files \u2212</p>\n<ul class=\"list\">\n<li>Sequential access</li>\n<li>Direct/Random access</li>\n<li>Indexed sequential access</li>\n</ul>\n<h3>Sequential access</h3>\n<p>A sequential access is that in which the records are accessed in some sequence, i.e., the information in the file is processed in order, one record after the other. This access method is the most primitive one. Example: Compilers usually access files in this fashion.</p>\n<h3>Direct/Random access</h3>\n<ul class=\"list\">\n<li><p>Random access file organization provides, accessing the records directly.</p></li>\n<li><p>Each record has its own address on the file with by the help of which it can be directly accessed for reading or writing.</p></li>\n<li><p>The records need not be in any sequence within the file and they need not be in adjacent locations on the storage medium.</p></li>\n</ul>\n<h3>Indexed sequential access</h3>\n<ul class=\"list\">\n<li>This mechanism is built up on base of sequential access.</li>\n<li>An index is created for each file which contains pointers to various blocks.</li>\n<li>Index is searched sequentially and its pointer is used to access the file directly.</li>\n</ul>\n<h2>Space Allocation</h2>\n<p>Files are allocated disk spaces by operating system. Operating systems deploy following three main ways to allocate disk space to files.</p>\n<ul class=\"list\">\n<li>Contiguous Allocation</li>\n<li>Linked Allocation</li>\n<li>Indexed Allocation</li>\n</ul>\n<h3>Contiguous Allocation</h3>\n<ul class=\"list\">\n<li>Each file occupies a contiguous address space on disk.</li>\n<li>Assigned disk address is in linear order.</li>\n<li>Easy to implement.</li>\n<li>External fragmentation is a major issue with this type of allocation technique.</li>\n</ul>\n<h3>Linked Allocation</h3>\n<ul class=\"list\">\n<li>Each file carries a list of links to disk blocks.</li>\n<li>Directory contains link / pointer to first block of a file.</li>\n<li>No external fragmentation</li>\n<li>Effectively used in sequential access file.</li>\n<li>Inefficient in case of  direct access file.</li>\n</ul>\n<h3>Indexed Allocation</h3>\n<ul class=\"list\">\n<li>Provides solutions to problems of contiguous and linked allocation.</li>\n<li>A index block is created having all pointers to files.</li>\n<li>Each file has its own index block which stores the addresses of disk space occupied by the file.</li>\n<li>Directory contains the addresses of index blocks of files.</li>\n</ul>\n<h1>Operating System - Security</h1>\n<p>Security refers to providing a protection system to computer system resources such as CPU, memory, disk, software programs and most importantly data/information stored in the computer system. If a computer program is run by an unauthorized user, then he/she may cause severe damage to computer or data stored in it. So a computer system must be protected against unauthorized access, malicious access to system memory, viruses, worms etc. We're going to discuss following topics in this chapter.</p>\n<ul class=\"list\">\n<li>Authentication</li>\n<li>One Time passwords</li>\n<li>Program Threats</li>\n<li>System Threats</li>\n<li>Computer Security Classifications</li>\n</ul>\n<h2>Authentication</h2>\n<p>Authentication refers to identifying each user of the system and associating the executing programs with those users. It is the responsibility of the Operating System to create a protection system which ensures that a user who is running a particular program is authentic. Operating Systems generally identifies/authenticates users using following three ways \u2212</p>\n<ul class=\"list\">\n<li><p><b>Username / Password</b> \u2212 User need to enter a registered username and password with Operating system to login into the system.</p></li>\n<li><p><b>User card/key</b> \u2212 User need to punch card in card slot, or enter key generated by key generator in option provided by operating system to login into the system.</p></li>\n<li><p><b>User attribute - fingerprint/ eye retina pattern/ signature</b> \u2212 User need to pass his/her attribute via designated input device used by operating system to login into the system.</p></li>\n</ul>\n<h2>One Time passwords</h2>\n<p>One-time passwords provide additional security along with normal authentication. In One-Time Password system, a unique password is required every time user tries to login into the system. Once a one-time password is used, then it cannot be used again. One-time password are implemented in various ways.</p>\n<ul class=\"list\">\n<li><p><b>Random numbers</b> \u2212 Users are provided cards having numbers printed along with corresponding alphabets. System asks for numbers corresponding to few alphabets randomly chosen.</p></li>\n<li><p><b>Secret key</b> \u2212 User are provided a hardware device which can create a secret id mapped with user id. System asks for such secret id which is to be generated every time prior to login.</p></li>\n<li><p><b>Network password</b> \u2212 Some commercial applications send one-time passwords to user on registered mobile/ email which is required to be entered prior to login.</p></li>\n</ul>\n<h2>Program Threats</h2>\n<p>Operating system's processes and kernel do the designated task as instructed. If a user program made these process do malicious tasks, then it is known as <b>Program Threats</b>. One of the common example of program threat is a program installed in a computer which can store and send user credentials via network to some hacker. Following is the list of some well-known program threats.</p>\n<ul class=\"list\">\n<li><p><b>Trojan Horse</b> \u2212 Such program traps user login credentials and stores them to send to malicious user who can later on login to computer and can access system resources.</p></li>\n<li><p><b>Trap Door</b> \u2212 If a program which is designed to work as required, have a security hole in its code and perform illegal action without knowledge of user then it is called to have a trap door.</p></li>\n<li><p><b>Logic Bomb</b> \u2212 Logic bomb is a situation when a program misbehaves only when certain conditions met otherwise it works as a genuine program. It is harder to detect.</p></li>\n<li><p><b>Virus</b> \u2212 Virus as name suggest can replicate themselves on computer system. They are highly dangerous and can modify/delete user files, crash systems. A virus is generatlly a small code embedded in a program. As user accesses the program, the virus starts getting embedded in other files/ programs and can make system unusable for user</p></li>\n</ul>\n<h2>System Threats</h2>\n<p>System threats refers to misuse of system services and network connections to put user in trouble. System threats can be used to launch program threats on a complete network called as program attack. System threats creates such an environment that operating system resources/ user files are misused. Following is the list of some well-known system threats.</p>\n<ul class=\"list\">\n<li><p><b>Worm</b> \u2212 Worm is a process which can choked down a system performance by using system resources to extreme levels. A Worm process generates its multiple copies where each copy uses system resources, prevents all other processes to get required resources. Worms processes can even shut down an entire network.</p></li>\n<li><p><b>Port Scanning</b> \u2212 Port scanning is a mechanism or means by which a hacker can detects system vulnerabilities to make an attack on the system.</p></li>\n<li><p><b>Denial of Service</b> \u2212 Denial of service attacks normally prevents user to make legitimate use of the system. For example, a user may not be able to use internet if denial of service attacks browser's content settings.</p></li>\n</ul>\n<h2>Computer Security Classifications</h2>\n<p>As per the U.S. Department of Defense Trusted Computer System's Evaluation Criteria there are four security classifications in computer systems: A, B, C, and D. This is widely used specifications to determine and model the security of systems and of security solutions. Following is the brief description of each classification.</p>\n<table class=\"table table-bordered\">\n<tr>\n<th style=\"width:5%;\">S.N.</th>\n<th style=\"text-align:center\">Classification Type &amp; Description</th>\n</tr>\n<tr>\n<td>1</td>\n<td><p><b>Type A</b></p>\n<p>Highest Level. Uses formal design specifications and verification techniques. Grants a high degree of assurance of process security.</p></td>\n</tr>\n<tr>\n<td>2</td>\n<td><p><b>Type B</b></p>\n<p>Provides mandatory protection system. Have all the properties of a class C2 system. Attaches a sensitivity label to each object. It is of three types.</p>\n<ul class=\"list\">\n<li><p><b>B1</b> \u2212 Maintains the security label of each object in the system. Label is used for making decisions to access control.</p></li>\n<li><p><b>B2</b> \u2212 Extends the sensitivity labels to each system resource, such as storage objects, supports covert channels and auditing of events.</p></li>\n<li><p><b>B3</b> \u2212 Allows creating lists or user groups for access-control to grant access or revoke access to a given named object.</p></li>\n</ul>\n</td>\n</tr>\n<tr>\n<td>3</td>\n<td><p><b>Type C</b></p>\n<p>Provides protection and user accountability using audit capabilities. It is of two types.</p>\n<ul class=\"list\">\n<li><p><b>C1</b> \u2212 Incorporates controls so that users can protect their private information and keep other users from accidentally reading / deleting their data. UNIX versions are mostly Cl class.</p></li>\n<li><p><b>C2</b> \u2212 Adds an individual-level access control to the capabilities of a Cl level system.</p></li>\n</ul>\n</td>\n</tr>\n<tr>\n<td>4</td>\n<td><p><b>Type D</b></p>\n<p>Lowest level. Minimum protection. MS-DOS, Window 3.1 fall in this category.</p></td>\n</tr>\n</table>\n<h1>Operating System - Linux</h1>\n<p>Linux is one of popular version of UNIX operating System. It is open source as its source code is freely available. It is free to use. Linux was designed considering UNIX compatibility. Its functionality list is quite similar to that of UNIX.</p>\n<h2>Components of Linux System</h2>\n<p>Linux Operating System has primarily three components</p>\n<ul class=\"list\">\n<li><p><b>Kernel</b> \u2212 Kernel is the core part of Linux. It is responsible for all major activities of this operating system. It consists of various modules and it interacts directly with the underlying hardware. Kernel provides the required abstraction to hide low level hardware details to system or application programs.</p></li>\n<li><p><b>System Library</b> \u2212 System libraries are special functions or programs using which application programs or system utilities accesses Kernel's features. These libraries implement most of the functionalities of the operating system and do not requires kernel module's code access rights.</p></li>\n<li><p><b>System Utility</b> \u2212 System Utility programs are responsible to do specialized, individual level tasks.</p></li>\n</ul>\n<img alt=\"Linux Operating System\" src=\"/operating_system/images/linux_os.jpg\"/>\n<h2>Kernel Mode vs User Mode</h2>\n<p>Kernel component code executes in a special privileged mode called <b>kernel mode</b> with full access to all resources of the computer. This code represents a single process, executes in single address space and do not require any context switch and hence is very efficient and fast. Kernel runs each processes and provides system services to processes, provides protected access to hardware to processes.</p>\n<p>Support code which is not required to run in kernel mode is in System Library. User programs and other system programs works in <b>User Mode</b> which has no access to system hardware and kernel code. User programs/ utilities use System libraries to access Kernel functions to get system's low level tasks.</p>\n<h2>Basic Features</h2>\n<p>Following are some of the important features of Linux Operating System.</p>\n<ul class=\"list\">\n<li><p><b>Portable</b> \u2212 Portability means software can works on different types of hardware in same way. Linux kernel and application programs supports their installation on any kind of hardware platform.</p></li>\n<li><p><b>Open Source</b> \u2212 Linux source code is freely available and it is community based development project. Multiple teams work in collaboration to enhance the capability of Linux operating system and it is continuously evolving.</p></li>\n<li><p><b>Multi-User</b> \u2212 Linux is a multiuser system means multiple users can access system resources like memory/ ram/ application programs at same time.</p></li>\n<li><p><b>Multiprogramming</b> \u2212 Linux is a multiprogramming system means multiple applications can run at same time.</p></li>\n<li><p><b>Hierarchical File System</b> \u2212 Linux provides a standard file structure in which system files/ user files are arranged.</p></li>\n<li><p><b>Shell</b> \u2212 Linux provides a special interpreter program which can be used to execute commands of the operating system. It can be used to do various types of operations, call application programs. etc.</p></li>\n<li><p><b>Security</b> \u2212 Linux provides user security using authentication features like password protection/ controlled access to specific files/ encryption of data.</p></li>\n</ul>\n<h2>Architecture</h2>\n<p>The following illustration shows the architecture of a Linux system \u2212</p>\n<img alt=\"Linux Operating System Architecture\" src=\"/operating_system/images/linux_architecture.jpg\"/>\n<p>The architecture of a Linux System consists of the following layers \u2212</p>\n<ul class=\"list\">\n<li><p><b>Hardware layer</b> \u2212 Hardware consists of all peripheral devices (RAM/ HDD/ CPU etc).</p></li>\n<li><p><b>Kernel</b> \u2212 It is the core component of Operating System, interacts directly with hardware, provides low level services to upper layer components.</p></li>\n<li><p><b>Shell</b> \u2212 An interface to kernel, hiding complexity of kernel's functions from users. The shell takes commands from the user and executes kernel's functions.</p></li>\n<li><p><b>Utilities</b> \u2212 Utility programs that provide the user most of the functionalities of an operating systems.</p></li>\n</ul>\n<hr/>\n<div class=\"pre-btn\">\n<a href=\"/operating_system/os_exams_questions_answers.htm\"><i class=\"icon icon-arrow-circle-o-left big-font\"></i> Previous Page</a>\n</div>\n<div class=\"print-btn center\">\n<a href=\"/cgi-bin/printpage.cgi\" target=\"_blank\"><i class=\"icon icon-print big-font\"></i> Print</a>\n</div>\n<div class=\"nxt-btn\">\n<a href=\"/operating_system/os_useful_resources.htm\">Next Page <i class=\"icon icon-arrow-circle-o-right big-font\"></i>\u00a0</a>\n</div>\n<hr/>\n<!-- PRINTING ENDS HERE -->\n<div class=\"bottomgooglead\">\n<div class=\"bottomadtag\">Advertisements</div>\n<script><!--\nvar width = 580;\nvar height = 400;\nvar format = \"580x400_as\";\nif( window.innerWidth < 468 ){\n   width = 300;\n   height = 250;\n   format = \"300x250_as\";\n}\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = width;\ngoogle_ad_height = height;\ngoogle_ad_format = format;\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n</div>\n</div>\n<div class=\"row\">\n<div class=\"col-md-3\" id=\"rightbar\">\n<div class=\"simple-ad\">\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'https://www.tutorialspoint.com/operating_system/os_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/facebookIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'https://www.tutorialspoint.com/operating_system/os_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/twitterIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'https://www.tutorialspoint.com/operating_system/os_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/linkedinIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=https://www.tutorialspoint.com/operating_system/os_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/googlePlusIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=https://www.tutorialspoint.com/operating_system/os_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/StumbleUponIcon.jpg\"/>\n</a>\n<a href=\"javascript:void(0)\" onclick=\"var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=https://www.tutorialspoint.com/operating_system/os_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;\">\n<img alt=\"img\" src=\"/images/reddit.jpg\"/>\n</a>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 250;\ngoogle_ad_format = \"300x250_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"pub-7133395778201029\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 600;\ngoogle_ad_format = \"300x600_as\";\ngoogle_ad_type = \"image\";\ngoogle_ad_channel =\"\";\n//--></script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n<div class=\"rightgooglead\">\n<script><!--\ngoogle_ad_client = \"ca-pub-2537027957187252\";\n/* Right Side Ad */\ngoogle_ad_slot = \"right_side_ad\";\ngoogle_ad_width = 300;\ngoogle_ad_height = 250;\n//-->\n</script>\n<script src=\"https://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"footer-copyright\">\n<div class=\"container\">\n<div class=\"row\">\n<div class=\"col-md-1\">\n<a class=\"logo\" href=\"index.htm\"> <img alt=\"Tutorials Point\" class=\"img-responsive\" src=\"/scripts/img/logo-footer.png\"/> </a>\n</div>\n<div class=\"col-md-4 col-sm-12 col-xs-12\">\n<nav id=\"sub-menu\">\n<ul>\n<li><a href=\"/about/about_privacy.htm\">Privacy Policy</a></li>\n<li><a href=\"/about/about_cookies.htm\">Cookies Policy</a></li>\n<li><a href=\"/about/contact_us.htm\">Contact</a></li>\n</ul>\n</nav>\n</div>\n<div class=\"col-md-3 col-sm-12 col-xs-12\">\n<p>\u00a9 Copyright 2019. All Rights Reserved.</p>\n</div>\n<div class=\"col-md-4 col-sm-12 col-xs-12\">\n<div class=\"news-group\">\n<input autocomplete=\"off\" class=\"form-control-foot search\" id=\"textemail\" name=\"textemail\" onblur=\"if (this.value == '') {this.value = 'Enter email for newsletter...';}\" onfocus=\"if (this.value == 'Enter email for newsletter...') {this.value = '';}\" placeholder=\"Enter email for newsletter\" type=\"text\"/>\n<span class=\"input-group-btn\"> <button class=\"btn btn-default btn-footer\" id=\"btnemail\" onclick=\"javascript:void(0);\" type=\"submit\">go</button> </span>\n<div id=\"newsresponse\"></div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"privacy-banner\">\n<div>\n<p>\n      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.\n      <a href=\"javascript:void(0)\" id=\"banner-accept\">Accept</a>\n<a href=\"/about/about_cookies.htm\" id=\"banner-learn\" target=\"_blank\">Learn more</a>\n</p>\n</div>\n</div>\n<script>\n// Banner Trigger if Not Closed\nif (!localStorage.bannerClosed) {\n  document.getElementById('privacy-banner').style.display = \"inherit\";\n} else {\n  document.getElementById('privacy-banner').style.display = \"none\";\n}\ndocument.getElementById('banner-accept').addEventListener('click', function() {\n  document.getElementById('privacy-banner').style.display = \"none\";\n  localStorage.bannerClosed = 'true';\n});\nif (navigator.userAgent.match(/Opera|OPR\\//)) {\n  document.getElementById('privacy-banner').style.display = \"inherit\";\n}\n</script>\n<!-- Libs -->\n<script src=\"/theme/js/custom-min.js?v=7\"></script>\n<script src=\"https://www.google-analytics.com/urchin.js\">\n</script>\n<script>\n_uacct = \"UA-232293-6\";\nurchinTracker();\n$('.pg-icon').click(function(){\n   $('.wrapLoader').show();\n});\n</script>\n\n\n\n", "url": "https://www.tutorialspoint.com/operating_system/os_quick_guide.htm", "title_html": "<h1>Operating System - Quick Guide</h1>"}